{"name":"Lean.Elab.Tactic.ElabTerm","instances":[],"imports":["Init","Lean.Meta.Tactic.Constructor","Lean.Meta.Tactic.Assert","Lean.Meta.Tactic.Clear","Lean.Meta.Tactic.Rename","Lean.Elab.Tactic.Basic","Lean.Elab.SyntheticMVars"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L302-L309","name":"Lean.Elab.Tactic.evalNativeDecide","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalNativeDecide","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L279-L289","name":"Lean.Elab.Tactic.evalDecide","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalDecide","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L250-L265","name":"Lean.Elab.Tactic.evalRename","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalRename","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L232-L248","name":"Lean.Elab.Tactic.elabAsFVar","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabAsFVar","doc":"Elaborate `stx`. If it a free variable, return it. Otherwise, assert it, and return the free variable.\nNote that, the main goal is updated when `Meta.assert` is used in the second case. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L226-L227","name":"Lean.Elab.Tactic.evalWithUnfoldingAll","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithUnfoldingAll","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L223-L224","name":"Lean.Elab.Tactic.evalWithReducibleAndInstances","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithReducibleAndInstances","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L220-L221","name":"Lean.Elab.Tactic.evalWithReducible","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalWithReducible","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L214-L218","name":"Lean.Elab.Tactic.evalConstructor","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalConstructor","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L209-L212","name":"Lean.Elab.Tactic.evalApply","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalApply","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L206-L207","name":"Lean.Elab.Tactic.getFVarIds","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.getFVarIds","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L198-L204","name":"Lean.Elab.Tactic.getFVarId","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.getFVarId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L191-L196","name":"Lean.Elab.Tactic.evalApplyLikeTactic","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalApplyLikeTactic","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L151-L189","name":"Lean.Elab.Tactic.elabTermForApply","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTermForApply","doc":"Given a tactic\n```\napply f\n```\nwe want the `apply` tactic to create all metavariables. The following\ndefinition will return `@f` for `f`. That is, it will **not** create\nmetavariables for implicit arguments.\nA similar method is also used in Lean 3.\nThis method is useful when applying lemmas such as:\n```\ntheorem infLeRight {s t : Set α} : s ⊓ t ≤ t\n```\nwhere `s ≤ t` here is defined as\n```\n∀ {x : α}, x ∈ s → x ∈ t\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L118-L131","name":"Lean.Elab.Tactic.evalSpecialize","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalSpecialize","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L113-L116","name":"Lean.Elab.Tactic.evalRefine'","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalRefine'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L108-L111","name":"Lean.Elab.Tactic.evalRefine","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalRefine","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L97-L106","name":"Lean.Elab.Tactic.refineCore","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.refineCore","doc":"If `allowNaturalHoles == true`, then we allow the resultant expression to contain unassigned \"natural\" metavariables.\nRecall that \"natutal\" metavariables are created for explicit holes `_` and implicit arguments. They are meant to be\nfilled by typing constraints.\n\"Synthetic\" metavariables are meant to be filled by tactics and are usually created using the synthetic hole notation `?<hole-name>`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L90-L91","name":"Lean.Elab.Tactic.elabTermWithHoles","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTermWithHoles","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L73-L88","name":"Lean.Elab.Tactic.withCollectingNewGoalsFrom","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.withCollectingNewGoalsFrom","doc":"Execute `k`, and collect new \"holes\" in the resulting expression.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L61-L68","name":"Lean.Elab.Tactic.evalExact","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.evalExact","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L57-L59","name":"Lean.Elab.Tactic.filterOldMVars","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.filterOldMVars","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L53-L55","name":"Lean.Elab.Tactic.logUnassignedAndAbort","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.logUnassignedAndAbort","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L49-L51","name":"Lean.Elab.Tactic.closeMainGoalUsing","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.closeMainGoalUsing","doc":"Try to close main goal using `x target`, where `target` is the type of the main goal.  "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L35-L46","name":"Lean.Elab.Tactic.elabTermEnsuringType","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTermEnsuringType","doc":"Elaborate `stx` in the current `MVarContext`. If given, the `expectedType` will be used to help\nelaboration and then a `TypeMismatchError` will be thrown if the elaborated type doesn't match.  "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L27-L31","name":"Lean.Elab.Tactic.elabTerm.go","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTerm.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Tactic/ElabTerm.lean#L20-L31","name":"Lean.Elab.Tactic.elabTerm","docLink":"./Lean/Elab/Tactic/ElabTerm.html#Lean.Elab.Tactic.elabTerm","doc":"Elaborate `stx` in the current `MVarContext`. If given, the `expectedType` will be used to help\nelaboration but not enforced (use `elabTermEnsuringType` to enforce an expected type). "}]}