{"name":"Lean.Elab.Term","instances":[{"typeNames":["Lean.Elab.Term.SyntheticMVarKind"],"name":"Lean.Elab.Term.instInhabitedSyntheticMVarKind","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.SyntheticMVarKind"],"name":"Lean.Elab.Term.instToStringSyntheticMVarKind","className":"ToString"},{"typeNames":["Lean.Elab.Term.SyntheticMVarDecl"],"name":"Lean.Elab.Term.instInhabitedSyntheticMVarDecl","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.MVarErrorKind"],"name":"Lean.Elab.Term.instInhabitedMVarErrorKind","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.MVarErrorKind"],"name":"Lean.Elab.Term.instToStringMVarErrorKind","className":"ToString"},{"typeNames":["Lean.Elab.Term.MVarErrorInfo"],"name":"Lean.Elab.Term.instInhabitedMVarErrorInfo","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.LetRecToLift"],"name":"Lean.Elab.Term.instInhabitedLetRecToLift","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.State"],"name":"Lean.Elab.Term.instInhabitedState","className":"Inhabited"},{"typeNames":["Lean.Elab.Tactic.State"],"name":"Lean.Elab.Tactic.instInhabitedState","className":"Inhabited"},{"typeNames":["Lean.Elab.Tactic.Snapshot"],"name":"Lean.Elab.Tactic.instInhabitedSnapshot","className":"Inhabited"},{"typeNames":["Lean.Elab.Tactic.CacheKey"],"name":"Lean.Elab.Tactic.instBEqCacheKey","className":"BEq"},{"typeNames":["Lean.Elab.Tactic.CacheKey"],"name":"Lean.Elab.Tactic.instHashableCacheKey","className":"Hashable"},{"typeNames":["Lean.Elab.Tactic.CacheKey"],"name":"Lean.Elab.Tactic.instInhabitedCacheKey","className":"Inhabited"},{"typeNames":["Lean.Elab.Tactic.Cache"],"name":"Lean.Elab.Tactic.instInhabitedCache","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instMonadTermElabM","className":"Monad"},{"typeNames":["Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instInhabitedTermElabM","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.SavedState"],"name":"Lean.Elab.Term.instInhabitedSavedState","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.SavedState","Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instMonadBacktrackSavedStateTermElabM","className":"Lean.MonadBacktrack"},{"typeNames":["Lean.Elab.Term.TermElabResult"],"name":"Lean.Elab.Term.instInhabitedTermElabResult","className":"Inhabited"},{"typeNames":["Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instAddErrorMessageContextTermElabM","className":"Lean.AddErrorMessageContext"},{"typeNames":["Lean.Elab.Term.LVal"],"name":"Lean.Elab.Term.instToStringLVal","className":"ToString"},{"typeNames":["Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instMonadMacroAdapterTermElabM","className":"Lean.Elab.MonadMacroAdapter"},{"typeNames":["Lean.Elab.Term.TermElabM"],"name":"Lean.Elab.Term.instMetaEvalTermElabM","className":"Lean.MetaEval"}],"imports":["Init","Lean.Deprecated","Lean.Meta.AppBuilder","Lean.Meta.CollectMVars","Lean.Meta.Coe","Lean.Elab.Config","Lean.Elab.Level","Lean.Elab.DeclModifiers"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1836-L1837","name":"Lean.Elab.withoutModifyingStateWithInfoAndMessages","docLink":"./Lean/Elab/Term.html#Lean.Elab.withoutModifyingStateWithInfoAndMessages","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1826-L1831","name":"Lean.Elab.Term.exprToSyntax","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.exprToSyntax","doc":"Helper function for \"embedding\" an `Expr` in `Syntax`.\nIt creates a named hole `?m` and immediately assigns `e` to it.\nExamples:\n```lean\nlet e := mkConst ``Nat.zero\n`(Nat.succ $(← exprToSyntax e))\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1811-L1815","name":"Lean.Elab.Term.expandDeclId","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.expandDeclId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1806-L1809","name":"Lean.Elab.Term.universeConstraintsCheckpoint","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.universeConstraintsCheckpoint","doc":"Execute `x` and then tries to solve pending universe constraints.\nNote that, stuck constraints will not be discarded.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1795-L1800","name":"Lean.Elab.Term.instMetaEvalTermElabM","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instMetaEvalTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1788-L1793","name":"Lean.Elab.Term.TermElabM.toIO","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM.toIO","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1785-L1786","name":"Lean.Elab.Term.TermElabM.run'","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM.run'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1782-L1783","name":"Lean.Elab.Term.TermElabM.run","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM.run","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1767-L1779","name":"Lean.Elab.Term.resolveId?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveId?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1758-L1765","name":"Lean.Elab.Term.resolveName'","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveName'","doc":"Similar to `resolveName`, but creates identifiers for the main part and each projection with position information derived from `ident`.\nExample: Assume resolveName `v.head.bla.boo` produces `(v.head, [\"bla\", \"boo\"])`, then this method produces\n`(v.head, id, [f₁, f₂])` where `id` is an identifier for `v.head`, and `f₁` and `f₂` are identifiers for fields `\"bla\"` and `\"boo\"`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1744-L1752","name":"Lean.Elab.Term.resolveName.process","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveName.process","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1726-L1752","name":"Lean.Elab.Term.resolveName","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1710-L1717","name":"Lean.Elab.Term.mkConst","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkConst","doc":"Create an `Expr.const` using the given name and explicit levels.\nRemark: fresh universe metavariables are created if the constant has more universe\nparameters than `explicitLevels`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1697-L1704","name":"Lean.Elab.Term.isLocalIdent?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isLocalIdent?","doc":"Return true iff `stx` is a `Syntax.ident`, and it is a local variable. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1679-L1693","name":"Lean.Elab.Term.resolveLocalName.loop","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveLocalName.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1650-L1655","name":"Lean.Elab.Term.resolveLocalName.go","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveLocalName.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1566-L1694","name":"Lean.Elab.Term.resolveLocalName","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.resolveLocalName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1560-L1564","name":"Lean.Elab.Term.isLetRecAuxMVar","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isLetRecAuxMVar","doc":"Return true if mvarId is an auxiliary metavariable created for compiling `let rec` or it\nis delayed assigned to one. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1551-L1554","name":"Lean.Elab.Term.mkAuxName","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkAuxName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1544-L1549","name":"Lean.Elab.Term.addAutoBoundImplicits'","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addAutoBoundImplicits'","doc":"Similar to `autoBoundImplicits`, but immediately if the resulting array of expressions contains metavariables,\nit immediately use `mkForallFVars` + `forallBoundedTelescope` to convert them into free variables.\nThe type `type` is modified during the process if type depends on `xs`.\nWe use this method to simplify the conversion of code using `autoBoundImplicitsOld` to `autoBoundImplicits`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1524-L1536","name":"Lean.Elab.Term.addAutoBoundImplicits.go","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addAutoBoundImplicits.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1520-L1536","name":"Lean.Elab.Term.addAutoBoundImplicits","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addAutoBoundImplicits","doc":"Return `autoBoundImplicits ++ xs`\nThis methoid throws an error if a variable in `autoBoundImplicits` depends on some `x` in `xs`.\nThe `autoBoundImplicits` may contain free variables created by the auto-implicit feature, and unassigned free variables.\nIt avoids the hack used at `autoBoundImplicitsOld`.\n\nRemark: we cannot simply replace every occurrence of `addAutoBoundImplicitsOld` with this one because a particular\nuse-case may not be able to handle the metavariables in the array being given to `k`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1494-L1509","name":"Lean.Elab.Term.collectUnassignedMVars.go","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.collectUnassignedMVars.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1486-L1509","name":"Lean.Elab.Term.collectUnassignedMVars","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.collectUnassignedMVars","doc":"Collect unassigned metavariables in `type` that are not already in `init` and not satisfying `except`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1480-L1481","name":"Lean.Elab.Term.withAutoBoundImplicitForbiddenPred","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withAutoBoundImplicitForbiddenPred","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1477-L1478","name":"Lean.Elab.Term.withoutAutoBoundImplicit","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutAutoBoundImplicit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1461-L1472","name":"Lean.Elab.Term.withAutoBoundImplicit.loop","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withAutoBoundImplicit.loop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1457-L1475","name":"Lean.Elab.Term.withAutoBoundImplicit","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withAutoBoundImplicit","doc":"Enable auto-bound implicits, and execute `k` while catching auto bound implicit exceptions. When an exception is caught,\na new local declaration is created, registered, and `k` is tried to be executed again. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1449-L1452","name":"Lean.Elab.Term.elabType","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.elabType","doc":"Elaborate `stx` and ensure result is a type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1437-L1446","name":"Lean.Elab.Term.ensureType","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ensureType","doc":"Make sure `e` is a type by inferring its type and making sure it is a `Expr.sort`\nor is unifiable with `Expr.sort`, or can be coerced into one. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1401-L1406","name":"Lean.Elab.Term.mkInstMVar","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkInstMVar","doc":"Create a new metavariable with the given type, and try to synthesize it.\nIt type class resolution cannot be executed (e.g., it is stuck because of metavariables in `type`),\nregister metavariable as a pending one.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1392-L1394","name":"Lean.Elab.Term.adaptExpander","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.adaptExpander","doc":"Adapt a syntax transformation to a regular, term-producing elaborator. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1376-L1389","name":"Lean.Elab.Term.commitIfNoErrors?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.commitIfNoErrors?","doc":"Execute `x` and return `some` if no new errors were recorded or exceptions was thrown. Otherwise, return `none` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1371-L1373","name":"Lean.Elab.Term.elabTermEnsuringType","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.elabTermEnsuringType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1368-L1369","name":"Lean.Elab.Term.elabTerm","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.elabTerm","doc":"Main function for elaborating terms.\nIt extracts the elaboration methods from the environment using the node kind.\nRecall that the environment has a mapping from `SyntaxNodeKind` to `TermElab` methods.\nIt creates a fresh macro scope for executing the elaboration method.\nAll unlogged trace messages produced by the elaboration method are logged using\nthe position information at `stx`. If the elaboration method throws an `Exception.error` and `errToSorry == true`,\nthe error is logged and a synthetic sorry expression is returned.\nIf the elaboration throws `Exception.postpone` and `catchExPostpone == true`,\na new synthetic metavariable of kind `SyntheticMVarKind.postponed` is created, registered,\nand returned.\nThe option `catchExPostpone == false` is used to implement `resumeElabTerm`\nto prevent the creation of another synthetic metavariable when resuming the elaboration.\n\nIf `implicitLambda == true`, then disable implicit lambdas feature for the given syntax, but not for its subterms.\nWe use this flag to implement, for example, the `@` modifier. If `Context.implicitLambda == false`, then this parameter has no effect.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1348-L1349","name":"Lean.Elab.Term.addDotCompletionInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addDotCompletionInfo","doc":"Store in the `InfoTree` that `e` is a \"dot\"-completion target. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1254-L1258","name":"Lean.Elab.Term.blockImplicitLambda","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.blockImplicitLambda","doc":"Block usage of implicit lambdas if `stx` is `@f` or `@f arg1 ...` or `fun` with an implicit binder annotation. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1247-L1251","name":"Lean.Elab.Term.mkNoImplicitLambdaAnnotation","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkNoImplicitLambdaAnnotation","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1244-L1245","name":"Lean.Elab.Term.hasNoImplicitLambdaAnnotation","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.hasNoImplicitLambdaAnnotation","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1196-L1199","name":"Lean.Elab.Term.instMonadMacroAdapterTermElabM","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instMonadMacroAdapterTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1134-L1136","name":"Lean.Elab.Term.postponeElabTerm","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.postponeElabTerm","doc":"Postpone the elaboration of `stx`, return a metavariable that acts as a placeholder, and\nensures the info tree is updated and a hole id is introduced.\nWhen `stx` is elaborated, new info nodes are created and attached to the new hole id in the info tree.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1122-L1127","name":"Lean.Elab.Term.withInfoContext'","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withInfoContext'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1119-L1120","name":"Lean.Elab.Term.addTermInfo'","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addTermInfo'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1110-L1117","name":"Lean.Elab.Term.addTermInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.addTermInfo","doc":"Pushes a new leaf node to the info tree associating the expression `e` to the syntax `stx`.\nAs a result, when the user hovers over `stx` they will see the type of `e`, and if `e`\nis a constant they will see the constant's doc string.\n\n* `expectedType?`: the expected type of `e` at the point of elaboration, if available\n* `lctx?`: the local context in which to interpret `e` (otherwise it will use `← getLCtx`)\n* `elaborator`: a declaration name used as an alternative target for go-to-definition\n* `isBinder`: if true, this will be treated as defining `e` (which should be a local constant)\n  for the purpose of go-to-definition on local variables\n* `force`: In patterns, the effect of `addTermInfo` is usually suppressed and replaced\n  by a `patternWithRef?` annotation which will be turned into a term info on the\n  post-match-elaboration expression. This flag overrides that behavior and adds the term\n  info immediately. (See https://github.com/leanprover/lean4/pull/1664.)\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1088-L1093","name":"Lean.Elab.Term.mkTermInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkTermInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1079-L1086","name":"Lean.Elab.Term.isTacticOrPostponedHole?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isTacticOrPostponedHole?","doc":"Return `some mvarId` if `e` corresponds to a hole that is going to be filled \"later\" by executing a tactic or resuming elaboration.\n\nWe do not save `ofTermInfo` for this kind of node in the `InfoTree`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1069-L1072","name":"Lean.Elab.Term.removeSaveInfoAnnotation","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.removeSaveInfoAnnotation","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1066-L1067","name":"Lean.Elab.Term.isSaveInfoAnnotation?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isSaveInfoAnnotation?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1060-L1064","name":"Lean.Elab.Term.mkSaveInfoAnnotation","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkSaveInfoAnnotation","doc":"Create an auxiliary annotation to make sure we create a `Info` even if `e` is a metavariable.\nSee `mkTermInfo`.\n\nWe use this functions because some elaboration functions elaborate subterms that may not be immediately\npart of the resulting term. Example:\n```\nlet_mvar% ?m := b; wait_if_type_mvar% ?m; body\n```\nIf the type of `b` is not known, then `wait_if_type_mvar% ?m; body` is postponed and just return a fresh\nmetavariable `?n`. The elaborator for\n```\nlet_mvar% ?m := b; wait_if_type_mvar% ?m; body\n```\nreturns `mkSaveInfoAnnotation ?n` to make sure the info nodes created when elaborating `b` are \"saved\".\nThis is a bit hackish, but elaborators like `let_mvar%` are rare.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1040-L1041","name":"Lean.Elab.Term.getSyntheticMVarDecl?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getSyntheticMVarDecl?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1024-L1027","name":"Lean.Elab.Term.withSavedContext","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withSavedContext","doc":"Execute `x` with the context saved using `saveContext`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1011-L1019","name":"Lean.Elab.Term.saveContext","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.saveContext","doc":"Save relevant context for term elaboration postponement.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L1003-L1006","name":"Lean.Elab.Term.tryPostponeIfHasMVars","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryPostponeIfHasMVars","doc":"Throws `Exception.postpone`, if `expectedType?` contains unassigned metavariables.\nIf `mayPostpone == false`, it throws error `msg`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L990-L997","name":"Lean.Elab.Term.tryPostponeIfHasMVars?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryPostponeIfHasMVars?","doc":"Throws `Exception.postpone`, if `expectedType?` contains unassigned metavariables.\nIt is a noop if `mayPostpone == false`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L981-L984","name":"Lean.Elab.Term.tryPostponeIfNoneOrMVar","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryPostponeIfNoneOrMVar","doc":"If `e? = some e`, then `tryPostponeIfMVar e`, otherwise it is just `tryPostpone`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L976-L978","name":"Lean.Elab.Term.tryPostponeIfMVar","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryPostponeIfMVar","doc":"If `mayPostpone == true` and `e`'s head is a metavariable, throw `Exception.postpone`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L972-L973","name":"Lean.Elab.Term.isMVarApp","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isMVarApp","doc":"Return `true` if `e` reduces (by unfolding only `[reducible]` declarations) to `?m ...` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L967-L969","name":"Lean.Elab.Term.tryPostpone","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryPostpone","doc":"If `mayPostpone == true`, throw `Expection.postpone`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L961-L964","name":"Lean.Elab.Term.exceptionToSorry","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.exceptionToSorry","doc":"Log the given exception, and create an synthetic sorry for representing the failed\nelaboration step with exception `ex`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L940-L945","name":"Lean.Elab.Term.ensureHasType","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ensureHasType","doc":"If `expectedType?` is `some t`, then ensure `t` and type of `e` are definitionally equal.\nIf they are not, then try coercions. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L927-L935","name":"Lean.Elab.Term.ensureHasTypeAux","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ensureHasTypeAux","doc":"If `expectedType?` is `some t`, then ensure `t` and `eType` are definitionally equal.\nIf they are not, then try coercions.\n\nArgument `f?` is used only for generating error messages. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L819-L821","name":"Lean.Elab.Term.isMonadApp","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isMonadApp","doc":"Return `true` if `type` is of the form `m α` where `m` is a `Monad`.\nNote that we reduce `type` using transparency `[reducible]`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L800-L804","name":"Lean.Elab.Term.isTypeApp?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.isTypeApp?","doc":"Return `some (m, α)` if `type` can be reduced to an application of the form `m α` using `[reducible]` transparency. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L763-L782","name":"Lean.Elab.Term.mkCoe","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkCoe","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L753-L761","name":"Lean.Elab.Term.tryCoeThunk?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.tryCoeThunk?","doc":"The coercion from `α` to `Thunk α` cannot be implemented using an instance because it would\neagerly evaluate `e`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L746-L747","name":"Lean.Elab.Term.synthesizeCoeInstMVarCore","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.synthesizeCoeInstMVarCore","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L741-L744","name":"Lean.Elab.Term.maxCoeSize","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.maxCoeSize","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L736-L739","name":"Lean.Elab.Term.autoLift","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.autoLift","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L690-L734","name":"Lean.Elab.Term.synthesizeInstMVarCore","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.synthesizeInstMVarCore","doc":"Try to synthesize metavariable using type class resolution.\nThis method assumes the local context and local instances of `instMVar` coincide\nwith the current local context and local instances.\nReturn `true` if the instance was synthesized successfully, and `false` if\nthe instance contains unassigned metavariables that are blocking the type class\nresolution procedure. Throw an exception if resolution or assignment irrevocably fails.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L677-L680","name":"Lean.Elab.Term.containsPendingMVar","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.containsPendingMVar","doc":"Return `true` if `e` contains a pending metavariable. Remark: it also visits let-declarations. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L651-L672","name":"Lean.Elab.Term.ContainsPendingMVar.visit","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ContainsPendingMVar.visit","doc":"See `containsPostponedTerm` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L648-L648","name":"Lean.Elab.Term.ContainsPendingMVar.M","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ContainsPendingMVar.M","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L643-L644","name":"Lean.Elab.Term.withoutMacroStackAtErr","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutMacroStackAtErr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L622-L641","name":"Lean.Elab.Term.throwTypeMismatchError","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.throwTypeMismatchError","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L616-L620","name":"Lean.Elab.Term.mkTypeMismatchError","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkTypeMismatchError","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L613-L614","name":"Lean.Elab.Term.applyAttributes","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.applyAttributes","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L610-L611","name":"Lean.Elab.Term.applyAttributesAt","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.applyAttributesAt","doc":"Apply given attributes **at** a given application time "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L591-L592","name":"Lean.Elab.Term.mkFreshIdent","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkFreshIdent","doc":"Auxiliary method for creating a `Syntax.ident` containing\na fresh name. This method is intended for creating fresh binder names.\nIt is just a thin layer on top of `mkFreshUserName`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L584-L585","name":"Lean.Elab.Term.mkFreshBinderName","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkFreshBinderName","doc":"Auxiliary method for creating fresh binder names.\nDo not confuse with the method for creating fresh free/meta variable ids. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L574-L579","name":"Lean.Elab.Term.levelMVarToParam","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.levelMVarToParam","doc":"Convert unassigned universe level metavariables into parameters.\nThe new parameter names are fresh names of the form `u_i` with regard to `ctx.levelNames`, which is updated with the new names. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L568-L569","name":"Lean.Elab.Term.mkExplicitBinder","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkExplicitBinder","doc":"Creates syntax for `(` <ident> `:` <type> `)` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L564-L565","name":"Lean.Elab.Term.withoutPostponing","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutPostponing","doc":"Execute `x` without allowing it to postpone elaboration tasks.\nThat is, `tryPostpone` is a noop. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L556-L559","name":"Lean.Elab.Term.ensureNoUnassignedMVars","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ensureNoUnassignedMVars","doc":"Ensure metavariables registered using `registerMVarErrorInfos` (and used in the given declaration) have been assigned. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L529-L553","name":"Lean.Elab.Term.logUnassignedUsingErrorInfos","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.logUnassignedUsingErrorInfos","doc":"Try to log errors for the unassigned metavariables `pendingMVarIds`.\n\nReturn `true` if there were \"unfilled holes\", and we should \"abort\" declaration.\nTODO: try to fill \"all\" holes using synthetic \"sorry's\"\n\nRemark: We only log the \"unfilled holes\" as new errors if no error has been logged so far. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L517-L520","name":"Lean.Elab.Term.MVarErrorInfo.logError.appendExtra","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo.logError.appendExtra","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L512-L515","name":"Lean.Elab.Term.MVarErrorInfo.logError.addArgName","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo.logError.addArgName","doc":"Append `mvarErrorInfo` argument name (if available) to the message.\nRemark: if the argument name contains macro scopes we do not append it. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L496-L520","name":"Lean.Elab.Term.MVarErrorInfo.logError","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo.logError","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L490-L494","name":"Lean.Elab.Term.throwMVarError","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.throwMVarError","doc":"Auxiliary method for reporting errors of the form \"... contains metavariables ...\".\nThis kind of error is thrown, for example, at `Match.lean` where elaboration\ncannot continue if there are metavariables in patterns.\nWe only want to log it if we haven't logged any error so far. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L480-L483","name":"Lean.Elab.Term.registerCustomErrorIfMVar","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerCustomErrorIfMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L477-L478","name":"Lean.Elab.Term.getMVarErrorInfo?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getMVarErrorInfo?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L474-L475","name":"Lean.Elab.Term.registerMVarErrorCustomInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerMVarErrorCustomInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L471-L472","name":"Lean.Elab.Term.registerMVarErrorImplicitArgInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerMVarErrorImplicitArgInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L468-L469","name":"Lean.Elab.Term.registerMVarErrorHoleInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerMVarErrorHoleInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L465-L466","name":"Lean.Elab.Term.registerMVarErrorInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerMVarErrorInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L462-L463","name":"Lean.Elab.Term.registerSyntheticMVarWithCurrRef","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerSyntheticMVarWithCurrRef","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L459-L460","name":"Lean.Elab.Term.registerSyntheticMVar","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.registerSyntheticMVar","doc":"Add the given metavariable to the list of pending synthetic metavariables.\nThe method `synthesizeSyntheticMVars` is used to process the metavariables on this list. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L452-L454","name":"Lean.Elab.Term.withMacroExpansion","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withMacroExpansion","doc":"Elaborate `x` with `stx` on the macro stack "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L448-L449","name":"Lean.Elab.Term.elabLevel","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.elabLevel","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L439-L446","name":"Lean.Elab.Term.liftLevelM","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.liftLevelM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L434-L435","name":"Lean.Elab.Term.ppGoal","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.ppGoal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L431-L432","name":"Lean.Elab.Term.traceAtCmdPos","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.traceAtCmdPos","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L427-L429","name":"Lean.Elab.Term.throwErrorIfErrors","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.throwErrorIfErrors","doc":"For testing `TermElabM` methods. The #eval command will sign the error. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L423-L424","name":"Lean.Elab.Term.withoutErrToSorry","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutErrToSorry","doc":"Execute `x` without converting errors (i.e., exceptions) to `sorry` applications.\nRecall that when `errToSorry = true`, the method `elabTerm` catches exceptions and convert them into `sorry` applications.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L416-L417","name":"Lean.Elab.Term.withoutErrToSorryImp","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutErrToSorryImp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L411-L414","name":"Lean.Elab.Term.withAuxDecl","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withAuxDecl","doc":"Declare an auxiliary local declaration `shortDeclName : type` for elaborating recursive declaration `declName`,\nupdate the mapping `auxDeclToFullName`, and then execute `k`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L402-L405","name":"Lean.Elab.Term.withLevelNames","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withLevelNames","doc":"Execute `x` using `levelNames` as the universe level parameter names. See `getLevelNames`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L398-L399","name":"Lean.Elab.Term.setLevelNames","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.setLevelNames","doc":"Update the universe level parameter names. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L394-L395","name":"Lean.Elab.Term.withDeclName","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withDeclName","doc":"Execute `x` with `declName? := name`. See `getDeclName? "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L391-L391","name":"Lean.Elab.Term.getMVarDecl","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getMVarDecl","doc":"Return the declaration of the given metavariable "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L389-L389","name":"Lean.Elab.Term.getLetRecsToLift","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getLetRecsToLift","doc":"Return the list of nested `let rec` declarations that need to be lifted. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L387-L387","name":"Lean.Elab.Term.getDeclName?","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getDeclName?","doc":"Return the name of the declaration being elaborated if available. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L381-L384","name":"Lean.Elab.Term.instToStringLVal","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instToStringLVal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L377-L379","name":"Lean.Elab.Term.LVal.isFieldName","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LVal.isFieldName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L373-L375","name":"Lean.Elab.Term.LVal.getRef","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LVal.getRef","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L367-L371","name":"Lean.Elab.Term.LVal","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LVal","doc":"Auxiliary datatatype for presenting a Lean lvalue modifier.\nWe represent a unelaborated lvalue as a `Syntax` (or `Expr`) and `List LVal`.\nExample: `a.foo.1` is represented as the `Syntax` `a` and the list\n`[LVal.fieldName \"foo\", LVal.fieldIdx 1]`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L359-L359","name":"Lean.Elab.Term.termElabAttribute","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.termElabAttribute","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L357-L357","name":"Lean.Elab.Term.mkTermElabAttribute","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkTermElabAttribute","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L353-L354","name":"Lean.Elab.Term.mkTermElabAttributeUnsafe","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.mkTermElabAttributeUnsafe","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L350-L351","name":"Lean.Elab.Term.withoutSavingRecAppSyntax","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutSavingRecAppSyntax","doc":"Execute `x` without storing `Syntax` for recursive applications. See `saveRecAppSyntax` field at `Context`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L327-L334","name":"Lean.Elab.Term.withoutModifyingElabMetaStateWithInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.withoutModifyingElabMetaStateWithInfo","doc":"Execute `x` but discard changes performed at `Term.State` and `Meta.State`.\nRecall that the `Environment` and `InfoState` are at `Core.State`. Thus, any updates to it will\nbe preserved. This method is useful for performing computations where all\nmetavariable must be resolved or discarded.\nThe `InfoTree`s are not discarded, however, and wrapped in `InfoTree.Context`\nto store their metavariable context. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L312-L318","name":"Lean.Elab.Term.instAddErrorMessageContextTermElabM","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instAddErrorMessageContextTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L307-L310","name":"Lean.Elab.Term.getFVarLocalDecl!","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getFVarLocalDecl!","doc":"Given a free variable `fvar`, return its declaration.\nThis function panics if `fvar` is not a free variable.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L300-L301","name":"Lean.Elab.Term.getLevelNames","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.getLevelNames","doc":"Return the universe level names explicitly provided by the user.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L292-L295","name":"Lean.Elab.Term.commitIfDidNotPostpone","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.commitIfDidNotPostpone","doc":"Execute `x`, but keep state modifications only if `x` did not postpone.\nThis method is useful to implement elaboration functions that cannot decide whether\nthey need to postpone or not without updating the state. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L283-L286","name":"Lean.Elab.Term.applyResult","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.applyResult","doc":"Apply the result/exception and state captured with `observing`.\nWe use this method to implement overloaded notation and symbols. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L263-L278","name":"Lean.Elab.Term.observing","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.observing","doc":"Execute `x`, save resulting expression and new state.\nWe remove any `Info` created by `x`.\nThe info nodes are committed when we execute `applyResult`.\nWe use `observing` to implement overloaded notation and decls.\nWe want to save `Info` nodes for the chosen alternative.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L253-L254","name":"Lean.Elab.Term.instInhabitedTermElabResult","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedTermElabResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L251-L251","name":"Lean.Elab.Term.TermElabResult","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L247-L249","name":"Lean.Elab.Term.instMonadBacktrackSavedStateTermElabM","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instMonadBacktrackSavedStateTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L238-L245","name":"Lean.Elab.Term.SavedState.restore","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedState.restore","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L235-L236","name":"Lean.Elab.Term.saveState","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.saveState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L233-L233","name":"Lean.Elab.Term.instInhabitedSavedState","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedSavedState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L230-L233","name":"Lean.Elab.Term.SavedState","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedState","doc":"Backtrackable state for the `TermElabM` monad.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L224-L225","name":"Lean.Elab.Term.instInhabitedTermElabM","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L220-L220","name":"Lean.Elab.Term.instMonadTermElabM","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instMonadTermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L216-L216","name":"Lean.Elab.Term.TermElab","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElab","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L215-L215","name":"Lean.Elab.Term.TermElabM","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.TermElabM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L158-L213","name":"Lean.Elab.Term.Context","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.Context","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L152-L152","name":"Lean.Elab.Tactic.instInhabitedCache","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instInhabitedCache","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L149-L152","name":"Lean.Elab.Tactic.Cache","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.Cache","doc":"Cache for the `save` tactic.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L144-L144","name":"Lean.Elab.Tactic.instInhabitedCacheKey","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instInhabitedCacheKey","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L144-L144","name":"Lean.Elab.Tactic.instHashableCacheKey","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instHashableCacheKey","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L144-L144","name":"Lean.Elab.Tactic.instBEqCacheKey","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instBEqCacheKey","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L141-L144","name":"Lean.Elab.Tactic.CacheKey","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.CacheKey","doc":"Key for the cache used to implement the `save` tactic.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L136-L136","name":"Lean.Elab.Tactic.instInhabitedSnapshot","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instInhabitedSnapshot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L130-L136","name":"Lean.Elab.Tactic.Snapshot","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.Snapshot","doc":"Snapshots are used to implement the `save` tactic.\nThis tactic caches the state of the system, and allows us to \"replay\"\nexpensive proofs efficiently. This is only relevant implementing the\nLSP server.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L122-L122","name":"Lean.Elab.Tactic.instInhabitedState","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.instInhabitedState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L120-L122","name":"Lean.Elab.Tactic.State","docLink":"./Lean/Elab/Term.html#Lean.Elab.Tactic.State","doc":"State of the `TacticM` monad.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L111-L111","name":"Lean.Elab.Term.instInhabitedState","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedState","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L105-L111","name":"Lean.Elab.Term.State","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.State","doc":"State of the `TermElabM` monad.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L100-L100","name":"Lean.Elab.Term.instInhabitedLetRecToLift","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedLetRecToLift","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L89-L100","name":"Lean.Elab.Term.LetRecToLift","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.LetRecToLift","doc":"Nested `let rec` expressions are eagerly lifted by the elaborator.\nWe store the information necessary for performing the lifting here.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L83-L83","name":"Lean.Elab.Term.instInhabitedMVarErrorInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedMVarErrorInfo","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L78-L83","name":"Lean.Elab.Term.MVarErrorInfo","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorInfo","doc":"We can optionally associate an error context with metavariables.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L69-L73","name":"Lean.Elab.Term.instToStringMVarErrorKind","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instToStringMVarErrorKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L67-L67","name":"Lean.Elab.Term.instInhabitedMVarErrorKind","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedMVarErrorKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L60-L67","name":"Lean.Elab.Term.MVarErrorKind","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.MVarErrorKind","doc":"We can optionally associate an error context with a metavariable (see `MVarErrorInfo`).\nWe have three different kinds of error context.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L54-L54","name":"Lean.Elab.Term.instInhabitedSyntheticMVarDecl","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedSyntheticMVarDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L51-L54","name":"Lean.Elab.Term.SyntheticMVarDecl","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SyntheticMVarDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L44-L49","name":"Lean.Elab.Term.instToStringSyntheticMVarKind","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instToStringSyntheticMVarKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L42-L42","name":"Lean.Elab.Term.instInhabitedSyntheticMVarKind","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.instInhabitedSyntheticMVarKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L29-L42","name":"Lean.Elab.Term.SyntheticMVarKind","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SyntheticMVarKind","doc":"We use synthetic metavariables as placeholders for pending elaboration steps. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Term.lean#L20-L26","name":"Lean.Elab.Term.SavedContext","docLink":"./Lean/Elab/Term.html#Lean.Elab.Term.SavedContext","doc":"Saved context for postponed terms and tactics to be executed. "}]}