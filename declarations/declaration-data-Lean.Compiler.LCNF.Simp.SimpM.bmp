{"name":"Lean.Compiler.LCNF.Simp.SimpM","instances":[{"typeNames":["Lean.Compiler.LCNF.Simp.SimpM","Bool.false"],"name":"Lean.Compiler.LCNF.Simp.instMonadFVarSubstSimpMFalse","className":"Lean.Compiler.LCNF.MonadFVarSubst"},{"typeNames":["Lean.Compiler.LCNF.Simp.SimpM"],"name":"Lean.Compiler.LCNF.Simp.instMonadFVarSubstStateSimpM","className":"Lean.Compiler.LCNF.MonadFVarSubstState"}],"imports":["Init","Lean.Compiler.ImplementedByAttr","Lean.Compiler.LCNF.Renaming","Lean.Compiler.LCNF.ElimDead","Lean.Compiler.LCNF.AlphaEqv","Lean.Compiler.LCNF.PrettyPrinter","Lean.Compiler.LCNF.Bind","Lean.Compiler.LCNF.Simp.JpCases","Lean.Compiler.LCNF.Simp.FunDeclInfo","Lean.Compiler.LCNF.Simp.Config"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L305-L311","name":"Lean.Compiler.LCNF.Simp.addFVarSubst","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.addFVarSubst","doc":"Similar to `LCNF.addFVarSubst`. That is, add the entry\n`fvarId ↦ fvarId'` to the free variable substitution.\nIf `fvarId` has a non-internal binder name `n`, but `fvarId'` does not,\nthis method also adds the entry `fvarId' ↦ n` to the `binderRenaming` map.\nThe goal is to preserve user provided names.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L294-L296","name":"Lean.Compiler.LCNF.Simp.eraseFunDecl","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.eraseFunDecl","doc":"Erase the given local function declaration from the local context,\nand set the `simplified` flag to true.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L286-L288","name":"Lean.Compiler.LCNF.Simp.eraseLetDecl","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.eraseLetDecl","doc":"Erase the given let-declaration from the local context,\nand set the `simplified` flag to true.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L251-L280","name":"Lean.Compiler.LCNF.Simp.betaReduce","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.betaReduce","doc":"LCNF \"Beta-reduce\". The equivalent of `(fun params => code) args`.\nIf `mustInline` is true, the local function declarations in the resulting code are marked as `.mustInline`.\nSee comment at `updateFunDeclInfo`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L240-L244","name":"Lean.Compiler.LCNF.Simp.shouldInlineLocal","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.shouldInlineLocal","doc":"Return `true` if the given local function declaration should be inlined.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L234-L235","name":"Lean.Compiler.LCNF.Simp.isSmall","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.isSmall","doc":"Return `true` if the given code is considered \"small\".\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L226-L229","name":"Lean.Compiler.LCNF.Simp.isOnceOrMustInline","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.isOnceOrMustInline","doc":"Return true if the given local function declaration or join point id is marked as\n`once` or `mustInline`. We use this information to decide whether to inline them.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L214-L220","name":"Lean.Compiler.LCNF.Simp.withAddMustInline","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.withAddMustInline","doc":"Execute `x` with `fvarId` set as `mustInline`.\nAfter execution the original setting is restored.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L192-L208","name":"Lean.Compiler.LCNF.Simp.withIncRecDepth.throwMaxRecDepth","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.withIncRecDepth.throwMaxRecDepth","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L184-L208","name":"Lean.Compiler.LCNF.Simp.withIncRecDepth","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.withIncRecDepth","doc":"Similar to the default `Lean.withIncRecDepth`, but include the `inlineStack` in the error messsage.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L169-L179","name":"Lean.Compiler.LCNF.Simp.withInlining","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.withInlining","doc":"Execute `x` with an updated `inlineStack`. If `value` is of the form `const ...`, add `const` to the stack.\nOtherwise, do not change the `inlineStack`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L160-L163","name":"Lean.Compiler.LCNF.Simp.updateFunDeclInfo","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.updateFunDeclInfo","doc":"Traverse `code` and update function occurrence map.\nThis map is used to decide whether we inline local functions or not.\nIf `mustInline := true`, then all local function declarations occurring in\n`code` are tagged as `.mustInline`.\nRecall that we use `.mustInline` for local function declarations occurring in type class instances.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L156-L157","name":"Lean.Compiler.LCNF.Simp.addFunHoOcc","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.addFunHoOcc","doc":"Add a new occurrence of local function `fvarId` in argument position . "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L152-L153","name":"Lean.Compiler.LCNF.Simp.addFunOcc","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.addFunOcc","doc":"Add a new occurrence of local function `fvarId`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L148-L149","name":"Lean.Compiler.LCNF.Simp.addMustInline","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.addMustInline","doc":"Mark the local function declaration or join point with the given id as a \"must inline\". "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L144-L145","name":"Lean.Compiler.LCNF.Simp.incInlineLocal","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.incInlineLocal","doc":"Increment `inlineLocal` performance counter. It is the number of inlined local function and join point declarations. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L140-L141","name":"Lean.Compiler.LCNF.Simp.incInline","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.incInline","doc":"Increment `inline` performance counter. It is the number of inlined global declarations. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L136-L137","name":"Lean.Compiler.LCNF.Simp.incVisited","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.incVisited","doc":"Increment `visited` performance counter. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L132-L133","name":"Lean.Compiler.LCNF.Simp.markSimplified","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.markSimplified","doc":"Set the `simplified` flag to `true`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L118-L129","name":"Lean.Compiler.LCNF.Simp.withDiscrCtor","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.withDiscrCtor","doc":"Execute `x` with the information that `discr = ctorName ctorFields`.\nWe use this information to simplify nested cases on the same discriminant.\n\nRemark: we do not perform the reverse direction at this phase.\nThat is, we do not replace occurrences of `ctorName ctorFields` with `discr`.\nWe wait more type information to be erased.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L103-L108","name":"Lean.Compiler.LCNF.Simp.getIndInfo?","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.getIndInfo?","doc":"If `type` is an inductive datatype, return its universe levels and parameters.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L94-L98","name":"Lean.Compiler.LCNF.Simp.findCtor","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.findCtor","doc":"Use `findExpr`, and if the result is a free variable, check whether it is in the map `discrCtorMap`.\nWe use this method when simplifying projections and cases-constructor.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L87-L88","name":"Lean.Compiler.LCNF.Simp.instMonadFVarSubstStateSimpM","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.instMonadFVarSubstStateSimpM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L84-L85","name":"Lean.Compiler.LCNF.Simp.instMonadFVarSubstSimpMFalse","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.instMonadFVarSubstSimpMFalse","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L82-L82","name":"Lean.Compiler.LCNF.Simp.SimpM","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.SimpM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L44-L80","name":"Lean.Compiler.LCNF.Simp.State","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.State","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/Simp/SimpM.lean#L19-L42","name":"Lean.Compiler.LCNF.Simp.Context","docLink":"./Lean/Compiler/LCNF/Simp/SimpM.html#Lean.Compiler.LCNF.Simp.Context","doc":""}]}