{"name":"Lean.Meta.Tactic.Simp.Main","instances":[{"typeNames":["Lean.Meta.Simp.M"],"name":"Lean.Meta.Simp.instInhabitedM","className":"Inhabited"}],"imports":["Init","Lean.Meta.Transform","Lean.Meta.Tactic.Replace","Lean.Meta.Tactic.UnifyEq","Lean.Meta.Tactic.Simp.Rewrite"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L982-L1011","name":"Lean.Meta.dsimpGoal","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.dsimpGoal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L966-L980","name":"Lean.Meta.simpTargetStar","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.simpTargetStar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L930-L964","name":"Lean.Meta.simpGoal","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.simpGoal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L922-L928","name":"Lean.Meta.simpLocalDecl","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.simpLocalDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L910-L920","name":"Lean.Meta.applySimpResultToLocalDecl","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.applySimpResultToLocalDecl","doc":"Simplify `simp` result to the given local declaration. Return `none` if the goal was closed.\nThis method assumes `mvarId` is not assigned, and we are already using `mvarId`s local context. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L894-L905","name":"Lean.Meta.applySimpResultToLocalDeclCore","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.applySimpResultToLocalDeclCore","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L889-L892","name":"Lean.Meta.simpStep","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.simpStep","doc":"Simplify `prop` (which is inhabited by `proof`). Return `none` if the goal was closed. Return `some (proof', prop')`\notherwise, where `proof' : prop'` and `prop'` is the simplified `prop`.\n\nThis method assumes `mvarId` is not assigned, and we are already using `mvarId`s local context. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L880-L882","name":"Lean.Meta.applySimpResultToFVarId","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.applySimpResultToFVarId","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L865-L878","name":"Lean.Meta.applySimpResultToProp","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.applySimpResultToProp","doc":"Apply the result `r` for `prop` (which is inhabited by `proof`). Return `none` if the goal was closed. Return `some (proof', prop')`\notherwise, where `proof' : prop'` and `prop'` is the simplified `prop`.\n\nThis method assumes `mvarId` is not assigned, and we are already using `mvarId`s local context. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L854-L858","name":"Lean.Meta.simpTarget","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.simpTarget","doc":"Simplify the given goal target (aka type). Return `none` if the goal was closed. Return `some mvarId'` otherwise,\nwhere `mvarId'` is the simplified new goal. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L839-L849","name":"Lean.Meta.simpTargetCore","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.simpTargetCore","doc":"See `simpTarget`. This method assumes `mvarId` is not assigned, and we are already using `mvarId`s local context. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L829-L836","name":"Lean.Meta.applySimpResultToTarget","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.applySimpResultToTarget","doc":"Auxiliary method.\nGiven the current `target` of `mvarId`, apply `r` which is a new target and proof that it is equaal to the current one.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L821-L823","name":"Lean.Meta.dsimp","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.dsimp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L815-L819","name":"Lean.Meta.simp","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.simp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L807-L808","name":"Lean.Meta.Simp.DefaultMethods.methods","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.DefaultMethods.methods","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L803-L804","name":"Lean.Meta.Simp.DefaultMethods.post","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.DefaultMethods.post","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L800-L801","name":"Lean.Meta.Simp.DefaultMethods.pre","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.DefaultMethods.pre","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L778-L798","name":"Lean.Meta.Simp.DefaultMethods.discharge?","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.DefaultMethods.discharge?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L761-L774","name":"Lean.Meta.Simp.dischargeEqnThmHypothesis?.go?","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.dischargeEqnThmHypothesis?.go?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L752-L774","name":"Lean.Meta.Simp.dischargeEqnThmHypothesis?","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.dischargeEqnThmHypothesis?","doc":"Tries to solve `e` using `unifyEq?`.\nIt assumes that `isEqnThmHypothesis e` is `true`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L739-L746","name":"Lean.Meta.Simp.dischargeUsingAssumption?","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.dischargeUsingAssumption?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L737-L737","name":"Lean.Meta.Simp.Discharge","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.Discharge","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L732-L735","name":"Lean.Meta.Simp.isEqnThmHypothesis.go","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.isEqnThmHypothesis.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L729-L735","name":"Lean.Meta.Simp.isEqnThmHypothesis","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.isEqnThmHypothesis","doc":"Return true if `e` is of the form `(x : α) → ... → s = t → ... → False`\n\nRecall that this kind of proposition is generated by Lean when creating equations for\nfunctions and match-expressions with overlapping cases.\nExample: the following `match`-expression has overlapping cases.\n```\ndef f (x y : Nat) :=\n  match x, y with\n  | Nat.succ n, Nat.succ m => ...\n  | _, _ => 0\n```\nThe second equation is of the form\n```\n(x y : Nat) → ((n m : Nat) → x = Nat.succ n → y = Nat.succ m → False) → f x y = 0\n```\nThe hypothesis `(n m : Nat) → x = Nat.succ n → y = Nat.succ m → False` is essentially\nsaying the first case is not applicable.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L702-L708","name":"Lean.Meta.Simp.dsimpMain","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.dsimpMain","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L693-L700","name":"Lean.Meta.Simp.main","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.main","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L687-L691","name":"Lean.Meta.Simp.simp.cacheResult","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.cacheResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L655-L685","name":"Lean.Meta.Simp.simp.simpLet","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpLet","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L640-L653","name":"Lean.Meta.Simp.simp.simpForall","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpForall","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L605-L638","name":"Lean.Meta.Simp.simp.simpArrow","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpArrow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L594-L603","name":"Lean.Meta.Simp.simp.simpLambda","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpLambda","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L579-L592","name":"Lean.Meta.Simp.simp.withNewLemmas","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.withNewLemmas","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L576-L577","name":"Lean.Meta.Simp.simp.simpConst","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpConst","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L566-L574","name":"Lean.Meta.Simp.simp.simpApp","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpApp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L553-L564","name":"Lean.Meta.Simp.simp.congr","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.congr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L512-L551","name":"Lean.Meta.Simp.simp.trySimpCongrTheorem?","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.trySimpCongrTheorem?","doc":"Try to rewrite `e` children using the given congruence theorem "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L482-L509","name":"Lean.Meta.Simp.simp.processCongrHypothesis","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.processCongrHypothesis","doc":"Process the given congruence theorem hypothesis. Return true if it made \"progress\". "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L474-L479","name":"Lean.Meta.Simp.simp.congrDefault","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.congrDefault","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L385-L472","name":"Lean.Meta.Simp.simp.tryAutoCongrTheorem?","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.tryAutoCongrTheorem?","doc":"Try to use automatically generated congruence theorems. See `mkCongrSimp?`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L367-L382","name":"Lean.Meta.Simp.simp.mkCongrSimp?","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.mkCongrSimp?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L353-L365","name":"Lean.Meta.Simp.simp.visitFn","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.visitFn","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L335-L351","name":"Lean.Meta.Simp.simp.congrArgs","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.congrArgs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L309-L333","name":"Lean.Meta.Simp.simp.simpProj","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpProj","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L298-L307","name":"Lean.Meta.Simp.simp.simpLit","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpLit","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L283-L296","name":"Lean.Meta.Simp.simp.simpStep","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpStep","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L262-L281","name":"Lean.Meta.Simp.simp.simpLoop","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp.simpLoop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L246-L691","name":"Lean.Meta.Simp.simp","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.simp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L240-L244","name":"Lean.Meta.Simp.removeUnnecessaryCasts.elimDummyEqRec","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.removeUnnecessaryCasts.elimDummyEqRec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L237-L238","name":"Lean.Meta.Simp.removeUnnecessaryCasts.isDummyEqRec","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.removeUnnecessaryCasts.isDummyEqRec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L224-L244","name":"Lean.Meta.Simp.removeUnnecessaryCasts","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.removeUnnecessaryCasts","doc":"Given the application `e`, remove unnecessary casts of the form `Eq.rec a rfl` and `Eq.ndrec a rfl`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L209-L221","name":"Lean.Meta.Simp.getSimpLetCase","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.getSimpLetCase","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L204-L207","name":"Lean.Meta.Simp.SimpLetCase","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.SimpLetCase","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L199-L202","name":"Lean.Meta.Simp.lambdaTelescopeDSimp.go","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.lambdaTelescopeDSimp.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L196-L202","name":"Lean.Meta.Simp.lambdaTelescopeDSimp","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.lambdaTelescopeDSimp","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L193-L194","name":"Lean.Meta.Simp.instInhabitedM","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.instInhabitedM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L72-L73","name":"Lean.Meta.Simp.isOfNatNatLit","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.isOfNatNatLit","doc":"Return true if `e` is of the form `ofNat n` where `n` is a kernel Nat literal "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L57-L63","name":"Lean.Meta.Simp.mkCongr","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.mkCongr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L52-L55","name":"Lean.Meta.Simp.mkCongrFun","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.mkCongrFun","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L41-L50","name":"Lean.Meta.Simp.Result.getProof'","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.Result.getProof'","doc":"Similar to `Result.getProof`, but adds a `mkExpectedTypeHint` if `proof?` is `none`\n(i.e., result is definitionally equal to input), but we cannot establish that\n`source` and `r.expr` are definitionally when using `TransparencyMode.reducible`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L32-L35","name":"Lean.Meta.Simp.Result.getProof","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.Result.getProof","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L23-L30","name":"Lean.Meta.Simp.Config.updateArith","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.Config.updateArith","doc":"Helper method for bootstrapping purposes. It disables `arith` if support theorems have not been defined yet.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L17-L18","name":"Lean.Meta.Simp.throwCongrHypothesisFailed","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.throwCongrHypothesisFailed","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Meta/Tactic/Simp/Main.lean#L14-L15","name":"Lean.Meta.Simp.congrHypothesisExceptionId","docLink":"./Lean/Meta/Tactic/Simp/Main.html#Lean.Meta.Simp.congrHypothesisExceptionId","doc":""}]}