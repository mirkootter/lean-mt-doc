{"name":"Lean.Elab.Match","instances":[{"typeNames":["Lean.Elab.Term.Discr"],"name":"Lean.Elab.Term.instInhabitedDiscr","className":"Inhabited"}],"imports":["Init","Lean.Meta.Match.Match","Lean.Meta.GeneralizeVars","Lean.Meta.ForEachExpr","Lean.Elab.AuxDiscr","Lean.Elab.BindersUtil","Lean.Elab.PatternVar","Lean.Elab.Quotation.Precheck","Lean.Elab.SyntheticMVars"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L1268-L1280","name":"Lean.Elab.Term.elabNoMatch","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.elabNoMatch","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L1251-L1262","name":"Lean.Elab.Term.elabMatch.elabMatchDefault","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.elabMatch.elabMatchDefault","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L1245-L1262","name":"Lean.Elab.Term.elabMatch","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.elabMatch","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L1009-L1019","name":"Lean.Elab.Term.reportMatcherResultErrors","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.reportMatcherResultErrors","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L1004-L1007","name":"Lean.Elab.Term.match.ignoreUnusedAlts","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.match.ignoreUnusedAlts","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L1001-L1002","name":"Lean.Elab.Term.mkMatcher","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.mkMatcher","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L837-L843","name":"Lean.Elab.Term.GeneralizeResult","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.GeneralizeResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L731-L732","name":"Lean.Elab.Term.withDepElimPatterns","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.withDepElimPatterns","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L717-L726","name":"Lean.Elab.Term.ToDepElimPattern.main.unpack.go","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.main.unpack.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L716-L727","name":"Lean.Elab.Term.ToDepElimPattern.main.unpack","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.main.unpack","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L692-L714","name":"Lean.Elab.Term.ToDepElimPattern.main.pack","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.main.pack","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L673-L727","name":"Lean.Elab.Term.ToDepElimPattern.main","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.main","doc":"Main method for `withDepElimPatterns`.\n- `PatternVarDecls`: are the explicit pattern variables provided by the user.\n- `ps`: are the patterns provided by the user.\n- `matchType`: the expected typ for this branch. It depends on the explicit pattern variables and the implicit ones that are still represented as metavariables,\n   and are found by this function.\n- `k` is the continuation that is executed in an updated local context with the all pattern variables (explicit and implicit). Note that, `patternVarDecls` are all\n   replaced since they may depend on implicit pattern variables (i.e., metavariables) that are converted into new free variables by this method.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L646-L662","name":"Lean.Elab.Term.ToDepElimPattern.savePatternInfo.go","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.savePatternInfo.go","doc":"The `Bool` context is true iff we are inside of an \"inaccessible\" pattern. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L642-L662","name":"Lean.Elab.Term.ToDepElimPattern.savePatternInfo","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.savePatternInfo","doc":"Save pattern information in the info tree, and remove `patternWithRef?` annotations.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L602-L602","name":"Lean.Elab.Term.ToDepElimPattern.TopSortM","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.TopSortM","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L597-L600","name":"Lean.Elab.Term.ToDepElimPattern.TopSort.State","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.TopSort.State","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L533-L551","name":"Lean.Elab.Term.ToDepElimPattern.normalize.processInaccessible","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.normalize.processInaccessible","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L523-L531","name":"Lean.Elab.Term.ToDepElimPattern.normalize.processVar","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.normalize.processVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L518-L521","name":"Lean.Elab.Term.ToDepElimPattern.normalize.addVar","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.normalize.addVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L466-L551","name":"Lean.Elab.Term.ToDepElimPattern.normalize","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.normalize","doc":"Normalize the pattern and collect all patterns variables (explicit and implicit).\nThis method is the one that decides where the inaccessible annotations must be inserted.\nThe pattern variables are both free variables (for explicit pattern variables) and metavariables (for implicit ones).\nRecall that `mkLambdaFVars` now allows us to abstract both free variables and metavariables.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L391-L395","name":"Lean.Elab.Term.ToDepElimPattern.isExplicitPatternVar","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.isExplicitPatternVar","doc":"Return true iff `e` is an explicit pattern variable provided by the user. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L388-L388","name":"Lean.Elab.Term.ToDepElimPattern.M","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.M","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L376-L386","name":"Lean.Elab.Term.ToDepElimPattern.Context","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.Context","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L373-L374","name":"Lean.Elab.Term.ToDepElimPattern.State","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ToDepElimPattern.State","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L219-L222","name":"Lean.Elab.Term.PatternElabException","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.PatternElabException","doc":"Auxiliary structure for storing an type mismatch exception when processing the\npattern #`idx` of some alternative. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L181-L182","name":"Lean.Elab.Term.PatternVarDecl","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.PatternVarDecl","doc":"We convert the collected `PatternVar`s intro `PatternVarDecl` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L170-L178","name":"Lean.Elab.Term.precheckMatch","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.precheckMatch","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L165-L167","name":"Lean.Elab.Term.elabInaccessible","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.elabInaccessible","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L143-L146","name":"Lean.Elab.Term.expandMacrosInPatterns","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.expandMacrosInPatterns","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L73-L79","name":"Lean.Elab.Term.ElabMatchTypeAndDiscrsResult","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.ElabMatchTypeAndDiscrsResult","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L71-L71","name":"Lean.Elab.Term.instInhabitedDiscr","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.instInhabitedDiscr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L67-L71","name":"Lean.Elab.Term.Discr","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.Discr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Elab/Match.lean#L49-L53","name":"Lean.Elab.Term.isAtomicDiscr?","docLink":"./Lean/Elab/Match.html#Lean.Elab.Term.isAtomicDiscr?","doc":"We treat `@x` as atomic to avoid unnecessary extra local declarations from being\ninserted into the local context. Recall that `expandMatchAltsIntoMatch` uses `@` modifier.\nThus this is kind of discriminant is quite common.\n\nRemark: if the discriminat is `Systax.missing`, we abort the elaboration of the `match`-expression.\nThis can happen due to error recovery. Example\n```\nexample : (p ∨ p) → p := fun h => match\n```\nIf we don't abort, the elaborator loops because we will keep trying to expand\n```\nmatch\n```\ninto\n```\nlet d := <Syntax.missing>; match\n```\nRecall that `Syntax.setArg stx i arg` is a no-op when `i` is out-of-bounds. "}]}