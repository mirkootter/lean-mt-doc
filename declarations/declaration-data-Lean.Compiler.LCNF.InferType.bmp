{"name":"Lean.Compiler.LCNF.InferType","instances":[],"imports":["Init","Lean.Compiler.LCNF.CompilerM","Lean.Compiler.LCNF.Types","Lean.Compiler.LCNF.PhaseExt","Lean.Compiler.LCNF.OtherDecl"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L421-L425","name":"Lean.Compiler.LCNF.compatibleTypes","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.compatibleTypes","doc":"Return true if the LCNF types `a` and `b` are compatible.\n\nRemark: `a` and `b` can be type formers (e.g., `List`, or `fun (α : Type) => Nat → Nat × α`)\n\nRemark: We may need to eta-expand type formers to establish whether they are compatible or not.\nFor example, suppose we have\n```\nfun (x : B) => Id B ◾ ◾\nId B ◾\n```\nWe must eta-expand `Id B ◾` to `fun (x : B) => Id B ◾ x`. Note that, we use `x` instead of `◾` to\nmake the implementation simpler and skip the check whether `B` is a type former type. However,\nthis simplification should not affect correctness since `◾` is compatible with everything.\n\nRemark: see comment at `isErasedCompatible`.\n\nRemark: because of \"erasure confusion\" see note above, we assume `◾` (aka `lcErasure`) is compatible with everything.\nThis is a simplification. We used to use `isErasedCompatible`, but this only address item 1.\nFor item 2, we would have to modify the `toLCNFType` function and make sure a type former is erased if the expected\ntype is not always a type former (see `S.mk` type and example in the note above).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L414-L418","name":"Lean.Compiler.LCNF.InferType.compatibleTypes","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.compatibleTypes","doc":"Return true if the LCNF types `a` and `b` are compatible.\n\nRemark: `a` and `b` can be type formers (e.g., `List`, or `fun (α : Type) => Nat → Nat × α`)\n\nRemark: We may need to eta-expand type formers to establish whether they are compatible or not.\nFor example, suppose we have\n```\nfun (x : B) => Id B ◾ ◾\nId B ◾\n```\nWe must eta-expand `Id B ◾` to `fun (x : B) => Id B ◾ x`. Note that, we use `x` instead of `◾` to\nmake the implementation simpler and skip the check whether `B` is a type former type. However,\nthis simplification should not affect correctness since `◾` is compatible with everything.\n\nRemark: see comment at `isErasedCompatible`.\n\nRemark: because of \"erasure confusion\" see note above, we assume `◾` (aka `lcErasure`) is compatible with everything.\nThis is a simplification. We used to use `isErasedCompatible`, but this only address item 1.\nFor item 2, we would have to modify the `toLCNFType` function and make sure a type former is erased if the expected\ntype is not always a type former (see `S.mk` type and example in the note above).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L381-L390","name":"Lean.Compiler.LCNF.InferType.compatibleTypesFull.etaExpand?","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.compatibleTypesFull.etaExpand?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L342-L390","name":"Lean.Compiler.LCNF.InferType.compatibleTypesFull","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.compatibleTypesFull","doc":"Complete check for `compatibleTypes`. It eta-expands type formers. See comment at `compatibleTypes`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L314-L337","name":"Lean.Compiler.LCNF.compatibleTypesQuick","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.compatibleTypesQuick","doc":"Quick check for `compatibleTypes`. It is not monadic, but it is incomplete\nbecause it does not eta-expand type formers. See comment at `compatibleTypes`.\n\nRemark: if the result is `true`, then `a` and `b` are indeed compatible.\nIf it is `false`, we must use the full-check.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L294-L305","name":"Lean.Compiler.LCNF.isErasedCompatible.go","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.isErasedCompatible.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L291-L305","name":"Lean.Compiler.LCNF.isErasedCompatible","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.isErasedCompatible","doc":"Return `true` if `type` should be erased. See item 1 in the note above where `x ◾ ◾` is\na proposition and should be erased when the universe level parameter is set to 0.\n\nRemark: `predVars` is a bitmask that indicates whether de-bruijn variables are predicates or not.\nThat is, `#i` is a predicate if `predVars[predVars.size - i - 1] = true`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L276-L282","name":"Lean.Compiler.LCNF.mkCasesResultType","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.mkCasesResultType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L266-L273","name":"Lean.Compiler.LCNF.instantiateForall.go","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.instantiateForall.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L263-L274","name":"Lean.Compiler.LCNF.instantiateForall","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.instantiateForall","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L259-L261","name":"Lean.Compiler.LCNF.mkAuxJpDecl'","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.mkAuxJpDecl'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L256-L257","name":"Lean.Compiler.LCNF.mkAuxJpDecl","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.mkAuxJpDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L251-L254","name":"Lean.Compiler.LCNF.mkAuxFunDecl","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.mkAuxFunDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L248-L249","name":"Lean.Compiler.LCNF.mkForallParams","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.mkForallParams","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L245-L246","name":"Lean.Compiler.LCNF.mkAuxLetDecl","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.mkAuxLetDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L242-L243","name":"Lean.Compiler.LCNF.AltCore.inferType","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.AltCore.inferType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L237-L240","name":"Lean.Compiler.LCNF.Code.inferParamType","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.Code.inferParamType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L229-L235","name":"Lean.Compiler.LCNF.Code.inferType","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.Code.inferType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L223-L227","name":"Lean.Compiler.LCNF.mkLcCast","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.mkLcCast","doc":"Create `lcCast expectedType e : expectedType` "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L217-L220","name":"Lean.Compiler.LCNF.getLevel","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.getLevel","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L214-L215","name":"Lean.Compiler.LCNF.inferType","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.inferType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L201-L209","name":"Lean.Compiler.LCNF.InferType.inferLambdaType.go","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.inferLambdaType.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L198-L209","name":"Lean.Compiler.LCNF.InferType.inferLambdaType","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.inferLambdaType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L183-L196","name":"Lean.Compiler.LCNF.InferType.inferForallType.go","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.inferForallType.go","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L180-L196","name":"Lean.Compiler.LCNF.InferType.inferForallType","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.inferForallType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L171-L178","name":"Lean.Compiler.LCNF.InferType.getLevel?","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.getLevel?","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L139-L169","name":"Lean.Compiler.LCNF.InferType.inferProjType","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.inferProjType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L136-L137","name":"Lean.Compiler.LCNF.InferType.inferAppType","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.inferAppType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L120-L134","name":"Lean.Compiler.LCNF.InferType.inferAppTypeCore","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.inferAppTypeCore","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L105-L118","name":"Lean.Compiler.LCNF.InferType.inferType","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.inferType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L94-L101","name":"Lean.Compiler.LCNF.InferType.inferConstType","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.inferConstType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L89-L92","name":"Lean.Compiler.LCNF.InferType.withLocalDecl","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.withLocalDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L85-L87","name":"Lean.Compiler.LCNF.InferType.mkForallParams","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.mkForallParams","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L76-L83","name":"Lean.Compiler.LCNF.InferType.mkForallFVars","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.mkForallFVars","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L71-L74","name":"Lean.Compiler.LCNF.InferType.getType","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.getType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L66-L69","name":"Lean.Compiler.LCNF.InferType.getBinderName","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.getBinderName","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Compiler/LCNF/InferType.lean#L64-L64","name":"Lean.Compiler.LCNF.InferType.InferTypeM","docLink":"./Lean/Compiler/LCNF/InferType.html#Lean.Compiler.LCNF.InferType.InferTypeM","doc":"We use a regular local context to store temporary local declarations\ncreated during type inference.\n"}]}