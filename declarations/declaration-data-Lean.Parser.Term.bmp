{"name":"Lean.Parser.Term","instances":[{"typeNames":["Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil","Lean.TSyntax","List.cons","Lean.SyntaxNodeKind","Lean.Name.mkStr4","List.nil"],"name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","className":"Coe"}],"imports":["Init","Lean.Parser.Attr","Lean.Parser.Level"],"declarations":[{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L488-L488","name":"Lean.Parser.Level.quot","docLink":"./Lean/Parser/Term.html#Lean.Parser.Level.quot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L486-L486","name":"Lean.Parser.Tactic.quotSeq","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.quotSeq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L485-L485","name":"Lean.Parser.Tactic.quot","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.quot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L481-L481","name":"Lean.Parser.Term.dotIdent","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dotIdent","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L479-L479","name":"Lean.Parser.Term.dynamicQuot","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dynamicQuot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L477-L477","name":"Lean.Parser.Term.stateRefT","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.stateRefT","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L474-L474","name":"Lean.Parser.Term.macroLastArg","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroLastArg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L473-L473","name":"Lean.Parser.Term.macroDollarArg","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroDollarArg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L472-L472","name":"Lean.Parser.Term.macroArg","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.macroArg","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L469-L469","name":"Lean.Parser.Term.assert","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.assert","doc":"`assert! cond` panics if `cond` evaluates to `false`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L467-L467","name":"Lean.Parser.Term.dbgTrace","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.dbgTrace","doc":"`dbg_trace e; body` evaluates to `body` and prints `e` (which can be an\ninterpolated string literal) to stderr. It should only be used for debugging.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L462-L462","name":"Lean.Parser.Term.unreachable","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.unreachable","doc":"A shorthand for `panic! \"unreachable code has been reached\"`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L460-L460","name":"Lean.Parser.Term.panic","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.panic","doc":"`panic! msg` formally evaluates to `@Inhabited.default α` if the expected type\n`α` implements `Inhabited`.\nAt runtime, `msg` and the file position are printed to stderr unless the C\nfunction `lean_set_panic_messages(false)` has been executed before. If the C\nfunction `lean_set_exit_on_panic(true)` has been executed before, the process is\nthen aborted.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L450-L450","name":"Lean.Parser.Term.attr.quot","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attr.quot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L449-L449","name":"Lean.Parser.Term.matchDiscr.quot","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr.quot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L448-L448","name":"Lean.Parser.Term.bracketedBinder.quot","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder.quot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L447-L447","name":"Lean.Parser.Term.bracketedBinderF","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinderF","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L446-L446","name":"Lean.Parser.Term.funBinder.quot","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funBinder.quot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L443-L443","name":"Lean.Parser.Term.subst","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.subst","doc":"`h ▸ e` is a macro built on top of `Eq.rec` and `Eq.symm` definitions.\nGiven `h : a = b` and `e : p a`, the term `h ▸ e` has type `p b`.\nYou can also view `h ▸ e` as a \"type casting\" operation where you change the type of `e` by using `h`.\nSee the Chapter \"Quantifiers and Equality\" in the manual \"Theorem Proving in Lean\" for additional information.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L435-L435","name":"Lean.Parser.Term.pipeCompletion","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.pipeCompletion","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L434-L434","name":"Lean.Parser.Term.pipeProj","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.pipeProj","doc":"`e |>.x` is a shorthand for `(e).x`. It is especially useful for avoiding parentheses with repeated applications. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L431-L431","name":"Lean.Parser.Term.namedPattern","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.namedPattern","doc":"`x@e` matches the pattern `e` and binds its value to the identifier `x`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L429-L429","name":"Lean.Parser.Term.explicitUniv","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicitUniv","doc":"`x.{u, ...}` explicitly specifies the universes `u, ...` of the constant `x`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L424-L426","name":"Lean.Parser.Term.isIdent","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.isIdent","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L422-L422","name":"Lean.Parser.Term.arrow","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.arrow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L421-L421","name":"Lean.Parser.Term.completion","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.completion","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L420-L420","name":"Lean.Parser.Term.proj","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.proj","doc":"The *extended field notation* `e.f` is roughly short for `T.f e` where `T` is the type of `e`.\nMore precisely,\n* if `e` is of a function type, `e.f` is translated to `Function.f (p := e)` where `p` is the first explicit parameter of function type\n* if `e` is of a named type `T ...` and there is a declaration `T.f` (possibly from `export`), `e.f` is translated to `T.f (p := e)` where\n  `p` is the first explicit parameter of type `T ...`\n* otherwise, if `e` is of a structure type, the above is repeated for every base type of the structure.\n\nThe field index notation `e.i`, where `i` is a positive number, is short for accessing the `i`-th field (1-indexed) of `e` if it is of a structure type. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L409-L409","name":"Lean.Parser.Term.app","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.app","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L402-L405","name":"Lean.Parser.Term.argument","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.argument","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L401-L401","name":"Lean.Parser.Term.ellipsis","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ellipsis","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L400-L400","name":"Lean.Parser.Term.namedArgument","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.namedArgument","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L398-L398","name":"Lean.Parser.Term.noErrorIfUnused","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noErrorIfUnused","doc":"Helper parser for marking `match`-alternatives that should not trigger errors if unused.\nWe use them to implement `macro_rules` and `elab_rules`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L392-L392","name":"Lean.Parser.Term.defaultOrOfNonempty","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.defaultOrOfNonempty","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L390-L390","name":"Lean.Parser.Term.waitIfContainsMVar","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfContainsMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L389-L389","name":"Lean.Parser.Term.waitIfTypeContainsMVar","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeContainsMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L388-L388","name":"Lean.Parser.Term.waitIfTypeMVar","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.waitIfTypeMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L387-L387","name":"Lean.Parser.Term.letMVar","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letMVar","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L385-L385","name":"Lean.Parser.Term.noImplicitLambda","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noImplicitLambda","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L384-L384","name":"Lean.Parser.Term.ensureExpectedType","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ensureExpectedType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L383-L383","name":"Lean.Parser.Term.ensureTypeOf","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ensureTypeOf","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L382-L382","name":"Lean.Parser.Term.typeOf","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeOf","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L381-L381","name":"Lean.Parser.Term.withDeclName","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.withDeclName","doc":"* `with_decl_name% id e` elaborates `e` in a context while changing the effective\n  declaration name to `id`.\n* `with_decl_name% ?id e` does the same, but resolves `id` as a new definition name\n  (appending the current namespaces).\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L374-L374","name":"Lean.Parser.Term.declName","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.declName","doc":"A macro which evaluates to the name of the currently elaborating declaration. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L371-L371","name":"Lean.Parser.Term.forInMacro'","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L370-L370","name":"Lean.Parser.Term.forInMacro","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forInMacro","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L368-L368","name":"Lean.Parser.Term.binop_lazy","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binop_lazy","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L367-L367","name":"Lean.Parser.Term.binop","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binop","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L366-L366","name":"Lean.Parser.Term.binrel_no_prop","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binrel_no_prop","doc":"Similar to `binrel`, but coerce `Prop` arguments into `Bool`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L364-L364","name":"Lean.Parser.Term.binrel","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binrel","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L362-L362","name":"Lean.Parser.Term.noindex","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.noindex","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L360-L360","name":"Lean.Parser.Term.matchAltsWhereDecls","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltsWhereDecls","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L357-L357","name":"Lean.Parser.Term.whereDecls","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.whereDecls","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L354-L354","name":"Lean.Parser.Term.letrec","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letrec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L352-L352","name":"Lean.Parser.Term.letRecDecls","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecls","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L351-L351","name":"Lean.Parser.Term.letRecDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letRecDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L350-L350","name":"Lean.Parser.Term.attributes","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attributes","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L348-L348","name":"Lean.Parser.Term.attrInstance","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attrInstance","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L347-L347","name":"Lean.Parser.Term.attrKind","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.attrKind","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L346-L346","name":"Lean.Parser.Term.local","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.local","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L345-L345","name":"Lean.Parser.Term.scoped","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.scoped","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L343-L343","name":"Lean.Parser.Term.have","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.have","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L342-L342","name":"Lean.Parser.Term.haveDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L341-L341","name":"Lean.Parser.Term.haveEqnsDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveEqnsDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L340-L340","name":"Lean.Parser.Term.haveIdDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L339-L339","name":"Lean.Parser.Term.haveIdLhs","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.haveIdLhs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L336-L336","name":"Lean.Parser.Term.let_tmp","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_tmp","doc":"`let`-declaration that is only included in the elaborated term if variable is still there.\nIt is often used when building macros.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L331-L331","name":"Lean.Parser.Term.let_delayed","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_delayed","doc":"`let_delayed x := v; b` is similar to `let x := v; b`, but `b` is elaborated before `v`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L327-L327","name":"Lean.Parser.Term.let_fun","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let_fun","doc":"`let_fun x := v; b` is syntax sugar for `(fun x => b) v`. It is very similar to `let x := v; b`, but they are not equivalent.\nIn `let_fun`, the value `v` has been abstracted away and cannot be accessed in `b`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L322-L322","name":"Lean.Parser.Term.let","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.let","doc":"`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare local functions too.\n```\nlet double := fun x => 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example, assume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L302-L302","name":"Lean.Parser.Term.letDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L300-L300","name":"Lean.Parser.Term.letEqnsDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letEqnsDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L287-L287","name":"Lean.Parser.Term.letPatDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letPatDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L286-L286","name":"Lean.Parser.Term.letIdDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L285-L285","name":"Lean.Parser.Term.letIdLhs","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdLhs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L283-L283","name":"Lean.Parser.Term.letIdBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.letIdBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L281-L281","name":"Lean.Parser.Term.doubleQuotedName","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.doubleQuotedName","doc":"A resolved name literal. Evaluates to the full name of the given constant if\nexistent in the current context, or else fails.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L274-L274","name":"Lean.Parser.Term.quotedName","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.quotedName","doc":"A literal of type `Name`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L272-L272","name":"Lean.Parser.Term.borrowed","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.borrowed","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L270-L270","name":"Lean.Parser.Term.trailing_parser","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.trailing_parser","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L269-L269","name":"Lean.Parser.Term.leading_parser","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.leading_parser","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L268-L268","name":"Lean.Parser.Term.withAnonymousAntiquot","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.withAnonymousAntiquot","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L267-L267","name":"Lean.Parser.Term.optExprPrecedence","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optExprPrecedence","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L265-L265","name":"Lean.Parser.Term.fun","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.fun","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L264-L264","name":"Lean.Parser.Term.basicFun","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.basicFun","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L262-L262","name":"Lean.Parser.Term.funBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L261-L261","name":"Lean.Parser.Term.funStrictImplicitBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funStrictImplicitBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L260-L260","name":"Lean.Parser.Term.funImplicitBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.funImplicitBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L258-L258","name":"Lean.Parser.Term.nomatch","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.nomatch","doc":"Empty match/ex falso. `nomatch e` is of arbitrary type `α : Sort u` if\nLean can show that an empty set of patterns is exhaustive given `e`'s type,\ne.g. because it has no constructors.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L252-L252","name":"Lean.Parser.Term.match","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.match","doc":"Pattern matching. `match e, ... with | p, ... => f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" <|> \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo <|> \"bar\") ...\n```\nthey are not.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L220-L220","name":"Lean.Parser.Term.motive","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.motive","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L218-L218","name":"Lean.Parser.Term.generalizingParam","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.generalizingParam","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L217-L217","name":"Lean.Parser.Term.falseVal","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.falseVal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L216-L216","name":"Lean.Parser.Term.trueVal","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.trueVal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L214-L214","name":"Lean.Parser.Term.matchDiscr","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchDiscr","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L211-L212","name":"Lean.Parser.Term.matchAlts","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlts","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L208-L209","name":"Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instCoeTSyntaxConsSyntaxNodeKindMkStr4Nil","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L206-L206","name":"Lean.Parser.Term.matchAltExpr","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAltExpr","doc":"Useful for syntax quotations. Note that generic patterns such as `` `(matchAltExpr| | ... => $rhs) `` should also\nwork with other `rhsParser`s (of arity 1). "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L200-L202","name":"Lean.Parser.Term.matchAlt","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.matchAlt","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L198-L198","name":"Lean.Parser.Term.forall","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.forall","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L195-L195","name":"Lean.Parser.Term.depArrow","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.depArrow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L177-L178","name":"Lean.Parser.Term.bracketedBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.bracketedBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L176-L176","name":"Lean.Parser.Term.instBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.instBinder","doc":"Instance-implicit binder. In regular applications without `@`, it is automatically inserted and solved by typeclass inference of the specified class. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L174-L174","name":"Lean.Parser.Term.strictImplicitBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitBinder","doc":"Strict-implicit binder. In contrast to `{ ... }` regular implicit binders, a strict-implicit binder is inserted automatically only when at least one subsequent explicit parameter is specified. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L172-L172","name":"Lean.Parser.Term.strictImplicitRightBracket","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitRightBracket","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L171-L171","name":"Lean.Parser.Term.strictImplicitLeftBracket","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.strictImplicitLeftBracket","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L170-L170","name":"Lean.Parser.Term.implicitBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.implicitBinder","doc":"Implicit binder. In regular applications without `@`, it is automatically inserted and solved by unification whenever all explicit parameters before it are specified. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L168-L168","name":"Lean.Parser.Term.explicitBinder","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicitBinder","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L167-L167","name":"Lean.Parser.Term.binderDefault","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderDefault","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L166-L166","name":"Lean.Parser.Term.binderTactic","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderTactic","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L165-L165","name":"Lean.Parser.Term.binderType","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L164-L164","name":"Lean.Parser.Term.binderIdent","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.binderIdent","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L163-L163","name":"Lean.Parser.Term.inaccessible","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.inaccessible","doc":"`.(e)` marks an \"inaccessible pattern\", which does not influence evaluation of the pattern match, but may be necessary for type-checking.\nIn contrast to regular patterns, `e` may be an arbitrary term of the appropriate type.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L158-L158","name":"Lean.Parser.Term.explicit","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.explicit","doc":"`@x` disables automatic insertion of implicit parameters of the constant `x`.\n`@e` for any term `e` also disables the insertion of implicit lambdas at this position.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L153-L153","name":"Lean.Parser.Term.optType","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optType","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L152-L152","name":"Lean.Parser.Term.typeSpec","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeSpec","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L148-L151","name":"Lean.Parser.Term.structInst","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInst","doc":"Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be\ninherited. If `e` is itself a variable called `x`, it can be elided:\n`fun y => { x := 1, y }`.\nA *structure update* of an existing value can be given via `with`:\n`{ point with x := 1 }`.\nThe structure type can be specified if not inferable:\n`{ x := 1, y := 2 : Point }`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L138-L138","name":"Lean.Parser.Term.optEllipsis","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optEllipsis","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L137-L137","name":"Lean.Parser.Term.structInstFieldAbbrev","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstFieldAbbrev","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L136-L136","name":"Lean.Parser.Term.structInstField","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstField","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L135-L135","name":"Lean.Parser.Term.structInstLVal","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstLVal","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L134-L134","name":"Lean.Parser.Term.structInstArrayRef","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.structInstArrayRef","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L133-L133","name":"Lean.Parser.Term.show","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.show","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L132-L132","name":"Lean.Parser.Term.suffices","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.suffices","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L131-L131","name":"Lean.Parser.Term.sufficesDecl","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sufficesDecl","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L130-L130","name":"Lean.Parser.Term.showRhs","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.showRhs","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L129-L129","name":"Lean.Parser.Term.fromTerm","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.fromTerm","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L128-L128","name":"Lean.Parser.Term.optIdent","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optIdent","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L127-L127","name":"Lean.Parser.Term.anonymousCtor","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.anonymousCtor","doc":"The *anonymous constructor* `⟨e, ...⟩` is equivalent to `c e ...` if the\nexpected type is an inductive type with a single constructor `c`.\nIf more terms are given than `c` has parameters, the remaining arguments\nare turned into a new anonymous constructor application. For example,\n`⟨a, b, c⟩ : α × (β × γ)` is equivalent to `⟨a, ⟨b, c⟩⟩`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L119-L119","name":"Lean.Parser.Term.paren","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.paren","doc":"Parentheses, used for\n- Grouping expressions, e.g., `a * (b + c)`.\n- Creating tuples, e.g., `(a, b, c)` is notation for `Prod.mk a (Prod.mk b c)`.\n- Performing type ascription, e.g., `(0 : Int)` instructs Lean to process `0` as a value of type `Int`.\n- Creating `Unit.unit`, `()` is just a shorthand for `Unit.unit`.\n- Creating simple functions when combined with `·`. Here are some examples:\n  - `(· + 1)` is shorthand for `fun x => x + 1`\n  - `(· + ·)` is shorthand for `fun x y => x + y`\n  - `(f · a b)` is shorthand for `fun x => f x a b`\n  - `(h (· + 1) ·)` is shorthand for `fun x => h (fun y => y + 1) x`\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L106-L106","name":"Lean.Parser.Term.parenSpecial","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.parenSpecial","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L105-L105","name":"Lean.Parser.Term.tupleTail","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.tupleTail","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L104-L104","name":"Lean.Parser.Term.typeAscription","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.typeAscription","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L103-L103","name":"Lean.Parser.Term.cdot","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.cdot","doc":"A placeholder for an implicit lambda abstraction's variable. The lambda abstraction is scoped to the surrounding parentheses.\nFor example, `(· + ·)` is equivalent to `fun x y => x + y`.\n"},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L98-L98","name":"Lean.Parser.Term.sorry","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sorry","doc":"A temporary placeholder for a missing proof or value. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L96-L96","name":"Lean.Parser.Term.syntheticHole","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.syntheticHole","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L95-L95","name":"Lean.Parser.Term.hole","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.hole","doc":"A placeholder term, to be synthesized by unification. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L93-L93","name":"Lean.Parser.Term.prop","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.prop","doc":"The universe of propositions. `Prop ≡ Sort 0`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L91-L91","name":"Lean.Parser.Term.sort","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.sort","doc":"A specific universe in Lean's infinite hierarchy of universes. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L89-L89","name":"Lean.Parser.Term.type","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.type","doc":"A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L87-L87","name":"Lean.Parser.Term.char","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.char","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L86-L86","name":"Lean.Parser.Term.str","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.str","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L85-L85","name":"Lean.Parser.Term.scientific","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.scientific","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L84-L84","name":"Lean.Parser.Term.num","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.num","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L83-L83","name":"Lean.Parser.Term.ident","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.ident","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L80-L80","name":"Lean.Parser.Term.optSemicolon","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.optSemicolon","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L77-L77","name":"Lean.Parser.Term.byTactic'","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic'","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L69-L69","name":"Lean.Parser.Term.byTactic","docLink":"./Lean/Parser/Term.html#Lean.Parser.Term.byTactic","doc":"`by tac` constructs a term of the expected type by running the tactic(s) `tac`. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L62-L62","name":"Lean.Parser.semicolonOrLinebreak","docLink":"./Lean/Parser/Term.html#Lean.Parser.semicolonOrLinebreak","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L61-L61","name":"Lean.Parser.darrow","docLink":"./Lean/Parser/Term.html#Lean.Parser.darrow","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L56-L57","name":"Lean.Parser.Tactic.seq1","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.seq1","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L52-L53","name":"Lean.Parser.Tactic.tacticSeq","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L50-L51","name":"Lean.Parser.Tactic.tacticSeqBracketed","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeqBracketed","doc":"The syntax `{ tacs }` is an alternative syntax for `· tacs`.\nIt runs the tactics in sequence, and fails if the goal is not solved. "},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L46-L47","name":"Lean.Parser.Tactic.tacticSeq1Indented","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.tacticSeq1Indented","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L39-L40","name":"Lean.Parser.Tactic.sepBy1IndentSemicolon","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepBy1IndentSemicolon","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L35-L36","name":"Lean.Parser.Tactic.sepByIndentSemicolon","docLink":"./Lean/Parser/Term.html#Lean.Parser.Tactic.sepByIndentSemicolon","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L29-L30","name":"Lean.Parser.convParser","docLink":"./Lean/Parser/Term.html#Lean.Parser.convParser","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L26-L27","name":"Lean.Parser.tacticParser","docLink":"./Lean/Parser/Term.html#Lean.Parser.tacticParser","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L19-L19","name":"Lean.Parser.Command.docComment","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.docComment","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L17-L17","name":"Lean.Parser.Command.commentBody.formatter","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.formatter","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L16-L16","name":"Lean.Parser.Command.commentBody.parenthesizer","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody.parenthesizer","doc":""},{"sourceLink":"https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Lean/Parser/Term.lean#L13-L14","name":"Lean.Parser.Command.commentBody","docLink":"./Lean/Parser/Term.html#Lean.Parser.Command.commentBody","doc":""}]}