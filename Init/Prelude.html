<html lang="en"><head><meta charset="UTF-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1"></meta><link rel="stylesheet" href=".././style.css"></link><link rel="stylesheet" href=".././src/pygments.css"></link><link rel="shortcut icon" href=".././favicon.ico"></link><link rel="prefetch" href=".././/declarations/declaration-data.bmp" as="image"></link><title>Init.Prelude</title><script defer="true" src=".././mathjax-config.js"></script><script defer="true" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script defer="true" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script>const SITE_ROOT=".././";</script><script>const MODULE_NAME="Init.Prelude";</script><script type="module" src=".././nav.js"></script><script type="module" src=".././search.js"></script><script type="module" src=".././how-about.js"></script><script type="module" src=".././instances.js"></script><script type="module" src=".././importedBy.js"></script></head><body><input id="nav_toggle" type="checkbox"></input><header><h1><label for="nav_toggle"></label>Documentation</h1><p class="header_filename break_within">Init.Prelude</p><form action="https://google.com/search" method="get" id="search_form"><input type="hidden" name="sitesearch" value="https://leanprover-community.github.io/mathlib_docs"></input><input type="text" name="q" autocomplete="off"></input><button>Google site search</button></form></header><nav class="internal_nav"><h3><a class="break_within" href="#top">Init.Prelude</a></h3><p class="gh_nav_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean">source</a></p><div class="imports"><details><summary>Imports</summary><ul></ul></details><details><summary>Imported by</summary><ul id="imported-by-Init.Prelude" class="imported-by-list"></ul></details></div><div class="nav_link"><a class="break_within" href="#id">id</a></div><div class="nav_link"><a class="break_within" href="#Function.comp">Function.comp</a></div><div class="nav_link"><a class="break_within" href="#Function.const">Function.const</a></div><div class="nav_link"><a class="break_within" href="#inferInstance">inferInstance</a></div><div class="nav_link"><a class="break_within" href="#inferInstanceAs">inferInstanceAs</a></div><div class="nav_link"><a class="break_within" href="#PUnit">PUnit</a></div><div class="nav_link"><a class="break_within" href="#Unit">Unit</a></div><div class="nav_link"><a class="break_within" href="#Unit.unit">Unit.unit</a></div><div class="nav_link"><a class="break_within" href="#lcErased">lcErased</a></div><div class="nav_link"><a class="break_within" href="#lcAny">lcAny</a></div><div class="nav_link"><a class="break_within" href="#lcProof">lcProof</a></div><div class="nav_link"><a class="break_within" href="#lcCast">lcCast</a></div><div class="nav_link"><a class="break_within" href="#lcUnreachable">lcUnreachable</a></div><div class="nav_link"><a class="break_within" href="#True">True</a></div><div class="nav_link"><a class="break_within" href="#False">False</a></div><div class="nav_link"><a class="break_within" href="#Empty">Empty</a></div><div class="nav_link"><a class="break_within" href="#PEmpty">PEmpty</a></div><div class="nav_link"><a class="break_within" href="#Not">Not</a></div><div class="nav_link"><a class="break_within" href="#False.elim">False.elim</a></div><div class="nav_link"><a class="break_within" href="#absurd">absurd</a></div><div class="nav_link"><a class="break_within" href="#Eq">Eq</a></div><div class="nav_link"><a class="break_within" href="#rfl">rfl</a></div><div class="nav_link"><a class="break_within" href="#id_eq">id_eq</a></div><div class="nav_link"><a class="break_within" href="#Eq.subst">Eq.subst</a></div><div class="nav_link"><a class="break_within" href="#Eq.symm">Eq.symm</a></div><div class="nav_link"><a class="break_within" href="#Eq.trans">Eq.trans</a></div><div class="nav_link"><a class="break_within" href="#cast">cast</a></div><div class="nav_link"><a class="break_within" href="#congrArg">congrArg</a></div><div class="nav_link"><a class="break_within" href="#congr">congr</a></div><div class="nav_link"><a class="break_within" href="#congrFun">congrFun</a></div><div class="nav_link"><a class="break_within" href="#Quot.lcInv">Quot.lcInv</a></div><div class="nav_link"><a class="break_within" href="#HEq">HEq</a></div><div class="nav_link"><a class="break_within" href="#HEq.rfl">HEq.rfl</a></div><div class="nav_link"><a class="break_within" href="#eq_of_heq">eq_of_heq</a></div><div class="nav_link"><a class="break_within" href="#Prod">Prod</a></div><div class="nav_link"><a class="break_within" href="#PProd">PProd</a></div><div class="nav_link"><a class="break_within" href="#MProd">MProd</a></div><div class="nav_link"><a class="break_within" href="#And">And</a></div><div class="nav_link"><a class="break_within" href="#Or">Or</a></div><div class="nav_link"><a class="break_within" href="#Or.intro_left">Or.intro_left</a></div><div class="nav_link"><a class="break_within" href="#Or.intro_right">Or.intro_right</a></div><div class="nav_link"><a class="break_within" href="#Or.elim">Or.elim</a></div><div class="nav_link"><a class="break_within" href="#Bool">Bool</a></div><div class="nav_link"><a class="break_within" href="#Subtype">Subtype</a></div><div class="nav_link"><a class="break_within" href="#optParam">optParam</a></div><div class="nav_link"><a class="break_within" href="#outParam">outParam</a></div><div class="nav_link"><a class="break_within" href="#namedPattern">namedPattern</a></div><div class="nav_link"><a class="break_within" href="#sorryAx">sorryAx</a></div><div class="nav_link"><a class="break_within" href="#eq_false_of_ne_true">eq_false_of_ne_true</a></div><div class="nav_link"><a class="break_within" href="#eq_true_of_ne_false">eq_true_of_ne_false</a></div><div class="nav_link"><a class="break_within" href="#ne_false_of_eq_true">ne_false_of_eq_true</a></div><div class="nav_link"><a class="break_within" href="#ne_true_of_eq_false">ne_true_of_eq_false</a></div><div class="nav_link"><a class="break_within" href="#Inhabited">Inhabited</a></div><div class="nav_link"><a class="break_within" href="#Nonempty">Nonempty</a></div><div class="nav_link"><a class="break_within" href="#Classical.choice">Classical.choice</a></div><div class="nav_link"><a class="break_within" href="#Nonempty.elim">Nonempty.elim</a></div><div class="nav_link"><a class="break_within" href="#instNonempty">instNonempty</a></div><div class="nav_link"><a class="break_within" href="#Classical.ofNonempty">Classical.ofNonempty</a></div><div class="nav_link"><a class="break_within" href="#instNonemptyForAll">instNonemptyForAll</a></div><div class="nav_link"><a class="break_within" href="#instNonemptyForAll_1">instNonemptyForAll_1</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedSort">instInhabitedSort</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedForAll">instInhabitedForAll</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedForAll_1">instInhabitedForAll_1</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedBool">instInhabitedBool</a></div><div class="nav_link"><a class="break_within" href="#PLift">PLift</a></div><div class="nav_link"><a class="break_within" href="#PLift.up_down">PLift.up_down</a></div><div class="nav_link"><a class="break_within" href="#PLift.down_up">PLift.down_up</a></div><div class="nav_link"><a class="break_within" href="#NonemptyType">NonemptyType</a></div><div class="nav_link"><a class="break_within" href="#NonemptyType.type">NonemptyType.type</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedNonemptyType">instInhabitedNonemptyType</a></div><div class="nav_link"><a class="break_within" href="#ULift">ULift</a></div><div class="nav_link"><a class="break_within" href="#ULift.up_down">ULift.up_down</a></div><div class="nav_link"><a class="break_within" href="#ULift.down_up">ULift.down_up</a></div><div class="nav_link"><a class="break_within" href="#Decidable">Decidable</a></div><div class="nav_link"><a class="break_within" href="#Decidable.decide">Decidable.decide</a></div><div class="nav_link"><a class="break_within" href="#DecidablePred">DecidablePred</a></div><div class="nav_link"><a class="break_within" href="#DecidableRel">DecidableRel</a></div><div class="nav_link"><a class="break_within" href="#DecidableEq">DecidableEq</a></div><div class="nav_link"><a class="break_within" href="#decEq">decEq</a></div><div class="nav_link"><a class="break_within" href="#decide_eq_true">decide_eq_true</a></div><div class="nav_link"><a class="break_within" href="#decide_eq_false">decide_eq_false</a></div><div class="nav_link"><a class="break_within" href="#of_decide_eq_true">of_decide_eq_true</a></div><div class="nav_link"><a class="break_within" href="#of_decide_eq_false">of_decide_eq_false</a></div><div class="nav_link"><a class="break_within" href="#of_decide_eq_self_eq_true">of_decide_eq_self_eq_true</a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqBool">instDecidableEqBool</a></div><div class="nav_link"><a class="break_within" href="#BEq">BEq</a></div><div class="nav_link"><a class="break_within" href="#instBEq">instBEq</a></div><div class="nav_link"><a class="break_within" href="#dite">dite</a></div><div class="nav_link"><a class="break_within" href="#ite">ite</a></div><div class="nav_link"><a class="break_within" href="#instDecidableAnd">instDecidableAnd</a></div><div class="nav_link"><a class="break_within" href="#instDecidableOr">instDecidableOr</a></div><div class="nav_link"><a class="break_within" href="#instDecidableNot">instDecidableNot</a></div><div class="nav_link"><a class="break_within" href="#cond">cond</a></div><div class="nav_link"><a class="break_within" href="#or">or</a></div><div class="nav_link"><a class="break_within" href="#and">and</a></div><div class="nav_link"><a class="break_within" href="#not">not</a></div><div class="nav_link"><a class="break_within" href="#Nat">Nat</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedNat">instInhabitedNat</a></div><div class="nav_link"><a class="break_within" href="#OfNat">OfNat</a></div><div class="nav_link"><a class="break_within" href="#instOfNatNat">instOfNatNat</a></div><div class="nav_link"><a class="break_within" href="#LE">LE</a></div><div class="nav_link"><a class="break_within" href="#LT">LT</a></div><div class="nav_link"><a class="break_within" href="#GE.ge">GE.ge</a></div><div class="nav_link"><a class="break_within" href="#GT.gt">GT.gt</a></div><div class="nav_link"><a class="break_within" href="#max">max</a></div><div class="nav_link"><a class="break_within" href="#min">min</a></div><div class="nav_link"><a class="break_within" href="#Trans">Trans</a></div><div class="nav_link"><a class="break_within" href="#instTransEq">instTransEq</a></div><div class="nav_link"><a class="break_within" href="#instTransEq_1">instTransEq_1</a></div><div class="nav_link"><a class="break_within" href="#HAdd">HAdd</a></div><div class="nav_link"><a class="break_within" href="#HSub">HSub</a></div><div class="nav_link"><a class="break_within" href="#HMul">HMul</a></div><div class="nav_link"><a class="break_within" href="#HDiv">HDiv</a></div><div class="nav_link"><a class="break_within" href="#HMod">HMod</a></div><div class="nav_link"><a class="break_within" href="#HPow">HPow</a></div><div class="nav_link"><a class="break_within" href="#HAppend">HAppend</a></div><div class="nav_link"><a class="break_within" href="#HOrElse">HOrElse</a></div><div class="nav_link"><a class="break_within" href="#HAndThen">HAndThen</a></div><div class="nav_link"><a class="break_within" href="#HAnd">HAnd</a></div><div class="nav_link"><a class="break_within" href="#HXor">HXor</a></div><div class="nav_link"><a class="break_within" href="#HOr">HOr</a></div><div class="nav_link"><a class="break_within" href="#HShiftLeft">HShiftLeft</a></div><div class="nav_link"><a class="break_within" href="#HShiftRight">HShiftRight</a></div><div class="nav_link"><a class="break_within" href="#Add">Add</a></div><div class="nav_link"><a class="break_within" href="#Sub">Sub</a></div><div class="nav_link"><a class="break_within" href="#Mul">Mul</a></div><div class="nav_link"><a class="break_within" href="#Neg">Neg</a></div><div class="nav_link"><a class="break_within" href="#Div">Div</a></div><div class="nav_link"><a class="break_within" href="#Mod">Mod</a></div><div class="nav_link"><a class="break_within" href="#Pow">Pow</a></div><div class="nav_link"><a class="break_within" href="#Append">Append</a></div><div class="nav_link"><a class="break_within" href="#OrElse">OrElse</a></div><div class="nav_link"><a class="break_within" href="#AndThen">AndThen</a></div><div class="nav_link"><a class="break_within" href="#AndOp">AndOp</a></div><div class="nav_link"><a class="break_within" href="#Xor">Xor</a></div><div class="nav_link"><a class="break_within" href="#OrOp">OrOp</a></div><div class="nav_link"><a class="break_within" href="#Complement">Complement</a></div><div class="nav_link"><a class="break_within" href="#ShiftLeft">ShiftLeft</a></div><div class="nav_link"><a class="break_within" href="#ShiftRight">ShiftRight</a></div><div class="nav_link"><a class="break_within" href="#instHAdd">instHAdd</a></div><div class="nav_link"><a class="break_within" href="#instHSub">instHSub</a></div><div class="nav_link"><a class="break_within" href="#instHMul">instHMul</a></div><div class="nav_link"><a class="break_within" href="#instHDiv">instHDiv</a></div><div class="nav_link"><a class="break_within" href="#instHMod">instHMod</a></div><div class="nav_link"><a class="break_within" href="#instHPow">instHPow</a></div><div class="nav_link"><a class="break_within" href="#instHAppend">instHAppend</a></div><div class="nav_link"><a class="break_within" href="#instHOrElse">instHOrElse</a></div><div class="nav_link"><a class="break_within" href="#instHAndThen">instHAndThen</a></div><div class="nav_link"><a class="break_within" href="#instHAnd">instHAnd</a></div><div class="nav_link"><a class="break_within" href="#instHXor">instHXor</a></div><div class="nav_link"><a class="break_within" href="#instHOr">instHOr</a></div><div class="nav_link"><a class="break_within" href="#instHShiftLeft">instHShiftLeft</a></div><div class="nav_link"><a class="break_within" href="#instHShiftRight">instHShiftRight</a></div><div class="nav_link"><a class="break_within" href="#Membership">Membership</a></div><div class="nav_link"><a class="break_within" href="#Nat.add">Nat.add</a></div><div class="nav_link"><a class="break_within" href="#instAddNat">instAddNat</a></div><div class="nav_link"><a class="break_within" href="#Nat.mul">Nat.mul</a></div><div class="nav_link"><a class="break_within" href="#instMulNat">instMulNat</a></div><div class="nav_link"><a class="break_within" href="#Nat.pow">Nat.pow</a></div><div class="nav_link"><a class="break_within" href="#instPowNat">instPowNat</a></div><div class="nav_link"><a class="break_within" href="#Nat.beq">Nat.beq</a></div><div class="nav_link"><a class="break_within" href="#instBEqNat">instBEqNat</a></div><div class="nav_link"><a class="break_within" href="#Nat.eq_of_beq_eq_true">Nat.eq_of_beq_eq_true</a></div><div class="nav_link"><a class="break_within" href="#Nat.ne_of_beq_eq_false">Nat.ne_of_beq_eq_false</a></div><div class="nav_link"><a class="break_within" href="#Nat.decEq">Nat.decEq</a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqNat">instDecidableEqNat</a></div><div class="nav_link"><a class="break_within" href="#Nat.ble">Nat.ble</a></div><div class="nav_link"><a class="break_within" href="#Nat.le">Nat.le</a></div><div class="nav_link"><a class="break_within" href="#instLENat">instLENat</a></div><div class="nav_link"><a class="break_within" href="#Nat.lt">Nat.lt</a></div><div class="nav_link"><a class="break_within" href="#instLTNat">instLTNat</a></div><div class="nav_link"><a class="break_within" href="#Nat.not_succ_le_zero">Nat.not_succ_le_zero</a></div><div class="nav_link"><a class="break_within" href="#Nat.not_lt_zero">Nat.not_lt_zero</a></div><div class="nav_link"><a class="break_within" href="#Nat.zero_le">Nat.zero_le</a></div><div class="nav_link"><a class="break_within" href="#Nat.succ_le_succ">Nat.succ_le_succ</a></div><div class="nav_link"><a class="break_within" href="#Nat.zero_lt_succ">Nat.zero_lt_succ</a></div><div class="nav_link"><a class="break_within" href="#Nat.le_step">Nat.le_step</a></div><div class="nav_link"><a class="break_within" href="#Nat.le_trans">Nat.le_trans</a></div><div class="nav_link"><a class="break_within" href="#Nat.lt_trans">Nat.lt_trans</a></div><div class="nav_link"><a class="break_within" href="#Nat.le_succ">Nat.le_succ</a></div><div class="nav_link"><a class="break_within" href="#Nat.le_succ_of_le">Nat.le_succ_of_le</a></div><div class="nav_link"><a class="break_within" href="#Nat.le_refl">Nat.le_refl</a></div><div class="nav_link"><a class="break_within" href="#Nat.succ_pos">Nat.succ_pos</a></div><div class="nav_link"><a class="break_within" href="#Nat.pred">Nat.pred</a></div><div class="nav_link"><a class="break_within" href="#Nat.pred_le_pred">Nat.pred_le_pred</a></div><div class="nav_link"><a class="break_within" href="#Nat.le_of_succ_le_succ">Nat.le_of_succ_le_succ</a></div><div class="nav_link"><a class="break_within" href="#Nat.le_of_lt_succ">Nat.le_of_lt_succ</a></div><div class="nav_link"><a class="break_within" href="#Nat.eq_or_lt_of_le">Nat.eq_or_lt_of_le</a></div><div class="nav_link"><a class="break_within" href="#Nat.lt_or_ge">Nat.lt_or_ge</a></div><div class="nav_link"><a class="break_within" href="#Nat.not_succ_le_self">Nat.not_succ_le_self</a></div><div class="nav_link"><a class="break_within" href="#Nat.lt_irrefl">Nat.lt_irrefl</a></div><div class="nav_link"><a class="break_within" href="#Nat.lt_of_le_of_lt">Nat.lt_of_le_of_lt</a></div><div class="nav_link"><a class="break_within" href="#Nat.le_antisymm">Nat.le_antisymm</a></div><div class="nav_link"><a class="break_within" href="#Nat.lt_of_le_of_ne">Nat.lt_of_le_of_ne</a></div><div class="nav_link"><a class="break_within" href="#Nat.le_of_ble_eq_true">Nat.le_of_ble_eq_true</a></div><div class="nav_link"><a class="break_within" href="#Nat.ble_self_eq_true">Nat.ble_self_eq_true</a></div><div class="nav_link"><a class="break_within" href="#Nat.ble_succ_eq_true">Nat.ble_succ_eq_true</a></div><div class="nav_link"><a class="break_within" href="#Nat.ble_eq_true_of_le">Nat.ble_eq_true_of_le</a></div><div class="nav_link"><a class="break_within" href="#Nat.not_le_of_not_ble_eq_true">Nat.not_le_of_not_ble_eq_true</a></div><div class="nav_link"><a class="break_within" href="#Nat.decLe">Nat.decLe</a></div><div class="nav_link"><a class="break_within" href="#Nat.decLt">Nat.decLt</a></div><div class="nav_link"><a class="break_within" href="#Nat.sub">Nat.sub</a></div><div class="nav_link"><a class="break_within" href="#instSubNat">instSubNat</a></div><div class="nav_link"><a class="break_within" href="#System.Platform.getNumBits">System.Platform.getNumBits</a></div><div class="nav_link"><a class="break_within" href="#System.Platform.numBits">System.Platform.numBits</a></div><div class="nav_link"><a class="break_within" href="#System.Platform.numBits_eq">System.Platform.numBits_eq</a></div><div class="nav_link"><a class="break_within" href="#Fin">Fin</a></div><div class="nav_link"><a class="break_within" href="#Fin.eq_of_val_eq">Fin.eq_of_val_eq</a></div><div class="nav_link"><a class="break_within" href="#Fin.val_eq_of_eq">Fin.val_eq_of_eq</a></div><div class="nav_link"><a class="break_within" href="#Fin.ne_of_val_ne">Fin.ne_of_val_ne</a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqFin">instDecidableEqFin</a></div><div class="nav_link"><a class="break_within" href="#instLTFin">instLTFin</a></div><div class="nav_link"><a class="break_within" href="#instLEFin">instLEFin</a></div><div class="nav_link"><a class="break_within" href="#Fin.decLt">Fin.decLt</a></div><div class="nav_link"><a class="break_within" href="#Fin.decLe">Fin.decLe</a></div><div class="nav_link"><a class="break_within" href="#UInt8.size">UInt8.size</a></div><div class="nav_link"><a class="break_within" href="#UInt8">UInt8</a></div><div class="nav_link"><a class="break_within" href="#UInt8.ofNatCore">UInt8.ofNatCore</a></div><div class="nav_link"><a class="break_within" href="#UInt8.decEq">UInt8.decEq</a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqUInt8">instDecidableEqUInt8</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedUInt8">instInhabitedUInt8</a></div><div class="nav_link"><a class="break_within" href="#UInt16.size">UInt16.size</a></div><div class="nav_link"><a class="break_within" href="#UInt16">UInt16</a></div><div class="nav_link"><a class="break_within" href="#UInt16.ofNatCore">UInt16.ofNatCore</a></div><div class="nav_link"><a class="break_within" href="#UInt16.decEq">UInt16.decEq</a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqUInt16">instDecidableEqUInt16</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedUInt16">instInhabitedUInt16</a></div><div class="nav_link"><a class="break_within" href="#UInt32.size">UInt32.size</a></div><div class="nav_link"><a class="break_within" href="#UInt32">UInt32</a></div><div class="nav_link"><a class="break_within" href="#UInt32.ofNatCore">UInt32.ofNatCore</a></div><div class="nav_link"><a class="break_within" href="#UInt32.toNat">UInt32.toNat</a></div><div class="nav_link"><a class="break_within" href="#UInt32.decEq">UInt32.decEq</a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqUInt32">instDecidableEqUInt32</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedUInt32">instInhabitedUInt32</a></div><div class="nav_link"><a class="break_within" href="#instLTUInt32">instLTUInt32</a></div><div class="nav_link"><a class="break_within" href="#instLEUInt32">instLEUInt32</a></div><div class="nav_link"><a class="break_within" href="#UInt32.decLt">UInt32.decLt</a></div><div class="nav_link"><a class="break_within" href="#UInt32.decLe">UInt32.decLe</a></div><div class="nav_link"><a class="break_within" href="#instDecidableLtUInt32InstLTUInt32">instDecidableLtUInt32InstLTUInt32</a></div><div class="nav_link"><a class="break_within" href="#instDecidableLeUInt32InstLEUInt32">instDecidableLeUInt32InstLEUInt32</a></div><div class="nav_link"><a class="break_within" href="#UInt64.size">UInt64.size</a></div><div class="nav_link"><a class="break_within" href="#UInt64">UInt64</a></div><div class="nav_link"><a class="break_within" href="#UInt64.ofNatCore">UInt64.ofNatCore</a></div><div class="nav_link"><a class="break_within" href="#UInt64.decEq">UInt64.decEq</a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqUInt64">instDecidableEqUInt64</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedUInt64">instInhabitedUInt64</a></div><div class="nav_link"><a class="break_within" href="#USize.size">USize.size</a></div><div class="nav_link"><a class="break_within" href="#usize_size_eq">usize_size_eq</a></div><div class="nav_link"><a class="break_within" href="#USize">USize</a></div><div class="nav_link"><a class="break_within" href="#USize.ofNatCore">USize.ofNatCore</a></div><div class="nav_link"><a class="break_within" href="#USize.decEq">USize.decEq</a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqUSize">instDecidableEqUSize</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedUSize">instInhabitedUSize</a></div><div class="nav_link"><a class="break_within" href="#USize.ofNat32">USize.ofNat32</a></div><div class="nav_link"><a class="break_within" href="#Nat.isValidChar">Nat.isValidChar</a></div><div class="nav_link"><a class="break_within" href="#UInt32.isValidChar">UInt32.isValidChar</a></div><div class="nav_link"><a class="break_within" href="#Char">Char</a></div><div class="nav_link"><a class="break_within" href="#Char.ofNatAux">Char.ofNatAux</a></div><div class="nav_link"><a class="break_within" href="#Char.ofNat">Char.ofNat</a></div><div class="nav_link"><a class="break_within" href="#Char.eq_of_val_eq">Char.eq_of_val_eq</a></div><div class="nav_link"><a class="break_within" href="#Char.val_eq_of_eq">Char.val_eq_of_eq</a></div><div class="nav_link"><a class="break_within" href="#Char.ne_of_val_ne">Char.ne_of_val_ne</a></div><div class="nav_link"><a class="break_within" href="#Char.val_ne_of_ne">Char.val_ne_of_ne</a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqChar">instDecidableEqChar</a></div><div class="nav_link"><a class="break_within" href="#Char.utf8Size">Char.utf8Size</a></div><div class="nav_link"><a class="break_within" href="#Option">Option</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedOption">instInhabitedOption</a></div><div class="nav_link"><a class="break_within" href="#Option.getD">Option.getD</a></div><div class="nav_link"><a class="break_within" href="#Option.map">Option.map</a></div><div class="nav_link"><a class="break_within" href="#List">List</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedList">instInhabitedList</a></div><div class="nav_link"><a class="break_within" href="#List.hasDecEq">List.hasDecEq</a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqList">instDecidableEqList</a></div><div class="nav_link"><a class="break_within" href="#List.foldl">List.foldl</a></div><div class="nav_link"><a class="break_within" href="#List.set">List.set</a></div><div class="nav_link"><a class="break_within" href="#List.length">List.length</a></div><div class="nav_link"><a class="break_within" href="#List.lengthTRAux">List.lengthTRAux</a></div><div class="nav_link"><a class="break_within" href="#List.lengthTR">List.lengthTR</a></div><div class="nav_link"><a class="break_within" href="#List.length_cons">List.length_cons</a></div><div class="nav_link"><a class="break_within" href="#List.concat">List.concat</a></div><div class="nav_link"><a class="break_within" href="#List.get">List.get</a></div><div class="nav_link"><a class="break_within" href="#String">String</a></div><div class="nav_link"><a class="break_within" href="#String.decEq">String.decEq</a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqString">instDecidableEqString</a></div><div class="nav_link"><a class="break_within" href="#String.Pos">String.Pos</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedPos">instInhabitedPos</a></div><div class="nav_link"><a class="break_within" href="#instDecidableEqPos">instDecidableEqPos</a></div><div class="nav_link"><a class="break_within" href="#Substring">Substring</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedSubstring">instInhabitedSubstring</a></div><div class="nav_link"><a class="break_within" href="#Substring.bsize">Substring.bsize</a></div><div class="nav_link"><a class="break_within" href="#String.csize">String.csize</a></div><div class="nav_link"><a class="break_within" href="#String.utf8ByteSize">String.utf8ByteSize</a></div><div class="nav_link"><a class="break_within" href="#String.utf8ByteSize.go">String.utf8ByteSize.go</a></div><div class="nav_link"><a class="break_within" href="#instHAddPos">instHAddPos</a></div><div class="nav_link"><a class="break_within" href="#instHSubPos">instHSubPos</a></div><div class="nav_link"><a class="break_within" href="#instHAddPosChar">instHAddPosChar</a></div><div class="nav_link"><a class="break_within" href="#instHAddPosString">instHAddPosString</a></div><div class="nav_link"><a class="break_within" href="#instLEPos">instLEPos</a></div><div class="nav_link"><a class="break_within" href="#instLTPos">instLTPos</a></div><div class="nav_link"><a class="break_within" href="#instDecidableLePosInstLEPos">instDecidableLePosInstLEPos</a></div><div class="nav_link"><a class="break_within" href="#instDecidableLtPosInstLTPos">instDecidableLtPosInstLTPos</a></div><div class="nav_link"><a class="break_within" href="#String.endPos">String.endPos</a></div><div class="nav_link"><a class="break_within" href="#String.toSubstring">String.toSubstring</a></div><div class="nav_link"><a class="break_within" href="#String.toSubstring'">String.toSubstring'</a></div><div class="nav_link"><a class="break_within" href="#unsafeCast">unsafeCast</a></div><div class="nav_link"><a class="break_within" href="#panicCore">panicCore</a></div><div class="nav_link"><a class="break_within" href="#panic">panic</a></div><div class="nav_link"><a class="break_within" href="#GetElem">GetElem</a></div><div class="nav_link"><a class="break_within" href="#Array">Array</a></div><div class="nav_link"><a class="break_within" href="#Array.mkEmpty">Array.mkEmpty</a></div><div class="nav_link"><a class="break_within" href="#Array.empty">Array.empty</a></div><div class="nav_link"><a class="break_within" href="#Array.size">Array.size</a></div><div class="nav_link"><a class="break_within" href="#Array.get">Array.get</a></div><div class="nav_link"><a class="break_within" href="#Array.getD">Array.getD</a></div><div class="nav_link"><a class="break_within" href="#Array.get!">Array.get!</a></div><div class="nav_link"><a class="break_within" href="#instGetElemArrayNatLtInstLTNatSize">instGetElemArrayNatLtInstLTNatSize</a></div><div class="nav_link"><a class="break_within" href="#Array.push">Array.push</a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray0">Array.mkArray0</a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray1">Array.mkArray1</a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray2">Array.mkArray2</a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray3">Array.mkArray3</a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray4">Array.mkArray4</a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray5">Array.mkArray5</a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray6">Array.mkArray6</a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray7">Array.mkArray7</a></div><div class="nav_link"><a class="break_within" href="#Array.mkArray8">Array.mkArray8</a></div><div class="nav_link"><a class="break_within" href="#Array.set">Array.set</a></div><div class="nav_link"><a class="break_within" href="#Array.setD">Array.setD</a></div><div class="nav_link"><a class="break_within" href="#Array.set!">Array.set!</a></div><div class="nav_link"><a class="break_within" href="#Array.appendCore">Array.appendCore</a></div><div class="nav_link"><a class="break_within" href="#Array.appendCore.loop">Array.appendCore.loop</a></div><div class="nav_link"><a class="break_within" href="#List.toArrayAux">List.toArrayAux</a></div><div class="nav_link"><a class="break_within" href="#List.redLength">List.redLength</a></div><div class="nav_link"><a class="break_within" href="#List.toArray">List.toArray</a></div><div class="nav_link"><a class="break_within" href="#Bind">Bind</a></div><div class="nav_link"><a class="break_within" href="#Pure">Pure</a></div><div class="nav_link"><a class="break_within" href="#Functor">Functor</a></div><div class="nav_link"><a class="break_within" href="#Seq">Seq</a></div><div class="nav_link"><a class="break_within" href="#SeqLeft">SeqLeft</a></div><div class="nav_link"><a class="break_within" href="#SeqRight">SeqRight</a></div><div class="nav_link"><a class="break_within" href="#Applicative">Applicative</a></div><div class="nav_link"><a class="break_within" href="#Monad">Monad</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedForAll_2">instInhabitedForAll_2</a></div><div class="nav_link"><a class="break_within" href="#instInhabited">instInhabited</a></div><div class="nav_link"><a class="break_within" href="#instForAllNonemptyNonempty">instForAllNonemptyNonempty</a></div><div class="nav_link"><a class="break_within" href="#Array.sequenceMap">Array.sequenceMap</a></div><div class="nav_link"><a class="break_within" href="#Array.sequenceMap.loop">Array.sequenceMap.loop</a></div><div class="nav_link"><a class="break_within" href="#MonadLift">MonadLift</a></div><div class="nav_link"><a class="break_within" href="#MonadLiftT">MonadLiftT</a></div><div class="nav_link"><a class="break_within" href="#liftM">liftM</a></div><div class="nav_link"><a class="break_within" href="#instMonadLiftT">instMonadLiftT</a></div><div class="nav_link"><a class="break_within" href="#instMonadLiftT_1">instMonadLiftT_1</a></div><div class="nav_link"><a class="break_within" href="#MonadFunctor">MonadFunctor</a></div><div class="nav_link"><a class="break_within" href="#MonadFunctorT">MonadFunctorT</a></div><div class="nav_link"><a class="break_within" href="#instMonadFunctorT">instMonadFunctorT</a></div><div class="nav_link"><a class="break_within" href="#monadFunctorRefl">monadFunctorRefl</a></div><div class="nav_link"><a class="break_within" href="#Except">Except</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedExcept">instInhabitedExcept</a></div><div class="nav_link"><a class="break_within" href="#MonadExceptOf">MonadExceptOf</a></div><div class="nav_link"><a class="break_within" href="#throwThe">throwThe</a></div><div class="nav_link"><a class="break_within" href="#tryCatchThe">tryCatchThe</a></div><div class="nav_link"><a class="break_within" href="#MonadExcept">MonadExcept</a></div><div class="nav_link"><a class="break_within" href="#MonadExcept.ofExcept">MonadExcept.ofExcept</a></div><div class="nav_link"><a class="break_within" href="#instMonadExcept">instMonadExcept</a></div><div class="nav_link"><a class="break_within" href="#MonadExcept.orElse">MonadExcept.orElse</a></div><div class="nav_link"><a class="break_within" href="#MonadExcept.instOrElse">MonadExcept.instOrElse</a></div><div class="nav_link"><a class="break_within" href="#ReaderT">ReaderT</a></div><div class="nav_link"><a class="break_within" href="#instInhabitedReaderT">instInhabitedReaderT</a></div><div class="nav_link"><a class="break_within" href="#ReaderT.run">ReaderT.run</a></div><div class="nav_link"><a class="break_within" href="#ReaderT.instMonadLiftReaderT">ReaderT.instMonadLiftReaderT</a></div><div class="nav_link"><a class="break_within" href="#ReaderT.instMonadExceptOfReaderT">ReaderT.instMonadExceptOfReaderT</a></div><div class="nav_link"><a class="break_within" href="#ReaderT.read">ReaderT.read</a></div><div class="nav_link"><a class="break_within" href="#ReaderT.pure">ReaderT.pure</a></div><div class="nav_link"><a class="break_within" href="#ReaderT.bind">ReaderT.bind</a></div><div class="nav_link"><a class="break_within" href="#ReaderT.instFunctorReaderT">ReaderT.instFunctorReaderT</a></div><div class="nav_link"><a class="break_within" href="#ReaderT.instApplicativeReaderT">ReaderT.instApplicativeReaderT</a></div><div class="nav_link"><a class="break_within" href="#ReaderT.instMonadReaderT">ReaderT.instMonadReaderT</a></div><div class="nav_link"><a class="break_within" href="#ReaderT.instMonadFunctorReaderT">ReaderT.instMonadFunctorReaderT</a></div><div class="nav_link"><a class="break_within" href="#ReaderT.adapt">ReaderT.adapt</a></div><div class="nav_link"><a class="break_within" href="#MonadReaderOf">MonadReaderOf</a></div><div class="nav_link"><a class="break_within" href="#readThe">readThe</a></div><div class="nav_link"><a class="break_within" href="#MonadReader">MonadReader</a></div><div class="nav_link"><a class="break_within" href="#instMonadReader">instMonadReader</a></div><div class="nav_link"><a class="break_within" href="#instMonadReaderOf">instMonadReaderOf</a></div><div class="nav_link"><a class="break_within" href="#instMonadReaderOfReaderT">instMonadReaderOfReaderT</a></div><div class="nav_link"><a class="break_within" href="#MonadWithReaderOf">MonadWithReaderOf</a></div><div class="nav_link"><a class="break_within" href="#withTheReader">withTheReader</a></div><div class="nav_link"><a class="break_within" href="#MonadWithReader">MonadWithReader</a></div><div class="nav_link"><a class="break_within" href="#instMonadWithReader">instMonadWithReader</a></div><div class="nav_link"><a class="break_within" href="#instMonadWithReaderOf">instMonadWithReaderOf</a></div><div class="nav_link"><a class="break_within" href="#instMonadWithReaderOfReaderT">instMonadWithReaderOfReaderT</a></div><div class="nav_link"><a class="break_within" href="#MonadStateOf">MonadStateOf</a></div><div class="nav_link"><a class="break_within" href="#getThe">getThe</a></div><div class="nav_link"><a class="break_within" href="#modifyThe">modifyThe</a></div><div class="nav_link"><a class="break_within" href="#modifyGetThe">modifyGetThe</a></div><div class="nav_link"><a class="break_within" href="#MonadState">MonadState</a></div><div class="nav_link"><a class="break_within" href="#instMonadState">instMonadState</a></div><div class="nav_link"><a class="break_within" href="#modify">modify</a></div><div class="nav_link"><a class="break_within" href="#getModify">getModify</a></div><div class="nav_link"><a class="break_within" href="#instMonadStateOf">instMonadStateOf</a></div><div class="nav_link"><a class="break_within" href="#EStateM.Result">EStateM.Result</a></div><div class="nav_link"><a class="break_within" href="#EStateM.instInhabitedResult">EStateM.instInhabitedResult</a></div><div class="nav_link"><a class="break_within" href="#EStateM">EStateM</a></div><div class="nav_link"><a class="break_within" href="#EStateM.instInhabitedEStateM">EStateM.instInhabitedEStateM</a></div><div class="nav_link"><a class="break_within" href="#EStateM.pure">EStateM.pure</a></div><div class="nav_link"><a class="break_within" href="#EStateM.set">EStateM.set</a></div><div class="nav_link"><a class="break_within" href="#EStateM.get">EStateM.get</a></div><div class="nav_link"><a class="break_within" href="#EStateM.modifyGet">EStateM.modifyGet</a></div><div class="nav_link"><a class="break_within" href="#EStateM.throw">EStateM.throw</a></div><div class="nav_link"><a class="break_within" href="#EStateM.Backtrackable">EStateM.Backtrackable</a></div><div class="nav_link"><a class="break_within" href="#EStateM.tryCatch">EStateM.tryCatch</a></div><div class="nav_link"><a class="break_within" href="#EStateM.orElse">EStateM.orElse</a></div><div class="nav_link"><a class="break_within" href="#EStateM.adaptExcept">EStateM.adaptExcept</a></div><div class="nav_link"><a class="break_within" href="#EStateM.bind">EStateM.bind</a></div><div class="nav_link"><a class="break_within" href="#EStateM.map">EStateM.map</a></div><div class="nav_link"><a class="break_within" href="#EStateM.seqRight">EStateM.seqRight</a></div><div class="nav_link"><a class="break_within" href="#EStateM.instMonadEStateM">EStateM.instMonadEStateM</a></div><div class="nav_link"><a class="break_within" href="#EStateM.instOrElseEStateM">EStateM.instOrElseEStateM</a></div><div class="nav_link"><a class="break_within" href="#EStateM.instMonadStateOfEStateM">EStateM.instMonadStateOfEStateM</a></div><div class="nav_link"><a class="break_within" href="#EStateM.instMonadExceptOfEStateM">EStateM.instMonadExceptOfEStateM</a></div><div class="nav_link"><a class="break_within" href="#EStateM.run">EStateM.run</a></div><div class="nav_link"><a class="break_within" href="#EStateM.run'">EStateM.run'</a></div><div class="nav_link"><a class="break_within" href="#EStateM.dummySave">EStateM.dummySave</a></div><div class="nav_link"><a class="break_within" href="#EStateM.dummyRestore">EStateM.dummyRestore</a></div><div class="nav_link"><a class="break_within" href="#EStateM.nonBacktrackable">EStateM.nonBacktrackable</a></div><div class="nav_link"><a class="break_within" href="#Hashable">Hashable</a></div><div class="nav_link"><a class="break_within" href="#UInt64.toUSize">UInt64.toUSize</a></div><div class="nav_link"><a class="break_within" href="#USize.toUInt64">USize.toUInt64</a></div><div class="nav_link"><a class="break_within" href="#mixHash">mixHash</a></div><div class="nav_link"><a class="break_within" href="#instHashableSubtype">instHashableSubtype</a></div><div class="nav_link"><a class="break_within" href="#String.hash">String.hash</a></div><div class="nav_link"><a class="break_within" href="#instHashableString">instHashableString</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.hash">Lean.Name.hash</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name">Lean.Name</a></div><div class="nav_link"><a class="break_within" href="#Lean.instInhabitedName">Lean.instInhabitedName</a></div><div class="nav_link"><a class="break_within" href="#Lean.instHashableName">Lean.instHashableName</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr">Lean.Name.mkStr</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkNum">Lean.Name.mkNum</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkSimple">Lean.Name.mkSimple</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr1">Lean.Name.mkStr1</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr2">Lean.Name.mkStr2</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr3">Lean.Name.mkStr3</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr4">Lean.Name.mkStr4</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr5">Lean.Name.mkStr5</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr6">Lean.Name.mkStr6</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr7">Lean.Name.mkStr7</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.mkStr8">Lean.Name.mkStr8</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.beq">Lean.Name.beq</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.instBEqName">Lean.Name.instBEqName</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.append">Lean.Name.append</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.instAppendName">Lean.Name.instAppendName</a></div><div class="nav_link"><a class="break_within" href="#Lean.SourceInfo">Lean.SourceInfo</a></div><div class="nav_link"><a class="break_within" href="#Lean.instInhabitedSourceInfo">Lean.instInhabitedSourceInfo</a></div><div class="nav_link"><a class="break_within" href="#Lean.SourceInfo.getPos?">Lean.SourceInfo.getPos?</a></div><div class="nav_link"><a class="break_within" href="#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.Preresolved">Lean.Syntax.Preresolved</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax">Lean.Syntax</a></div><div class="nav_link"><a class="break_within" href="#Lean.SyntaxNodeKinds">Lean.SyntaxNodeKinds</a></div><div class="nav_link"><a class="break_within" href="#Lean.TSyntax">Lean.TSyntax</a></div><div class="nav_link"><a class="break_within" href="#Lean.instInhabitedSyntax">Lean.instInhabitedSyntax</a></div><div class="nav_link"><a class="break_within" href="#Lean.instInhabitedTSyntax">Lean.instInhabitedTSyntax</a></div><div class="nav_link"><a class="break_within" href="#Lean.choiceKind">Lean.choiceKind</a></div><div class="nav_link"><a class="break_within" href="#Lean.nullKind">Lean.nullKind</a></div><div class="nav_link"><a class="break_within" href="#Lean.groupKind">Lean.groupKind</a></div><div class="nav_link"><a class="break_within" href="#Lean.identKind">Lean.identKind</a></div><div class="nav_link"><a class="break_within" href="#Lean.strLitKind">Lean.strLitKind</a></div><div class="nav_link"><a class="break_within" href="#Lean.charLitKind">Lean.charLitKind</a></div><div class="nav_link"><a class="break_within" href="#Lean.numLitKind">Lean.numLitKind</a></div><div class="nav_link"><a class="break_within" href="#Lean.scientificLitKind">Lean.scientificLitKind</a></div><div class="nav_link"><a class="break_within" href="#Lean.nameLitKind">Lean.nameLitKind</a></div><div class="nav_link"><a class="break_within" href="#Lean.fieldIdxKind">Lean.fieldIdxKind</a></div><div class="nav_link"><a class="break_within" href="#Lean.interpolatedStrLitKind">Lean.interpolatedStrLitKind</a></div><div class="nav_link"><a class="break_within" href="#Lean.interpolatedStrKind">Lean.interpolatedStrKind</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getKind">Lean.Syntax.getKind</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.setKind">Lean.Syntax.setKind</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.isOfKind">Lean.Syntax.isOfKind</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getArg">Lean.Syntax.getArg</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.instGetElemSyntaxNatTrue">Lean.Syntax.instGetElemSyntaxNatTrue</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getArgs">Lean.Syntax.getArgs</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getNumArgs">Lean.Syntax.getNumArgs</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getOptional?">Lean.Syntax.getOptional?</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.isMissing">Lean.Syntax.isMissing</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.isNodeOf">Lean.Syntax.isNodeOf</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.isIdent">Lean.Syntax.isIdent</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getId">Lean.Syntax.getId</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.setArgs">Lean.Syntax.setArgs</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.setArg">Lean.Syntax.setArg</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getHeadInfo?">Lean.Syntax.getHeadInfo?</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getHeadInfo?.loop">Lean.Syntax.getHeadInfo?.loop</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getHeadInfo">Lean.Syntax.getHeadInfo</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getPos?">Lean.Syntax.getPos?</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getTailPos?">Lean.Syntax.getTailPos?</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.getTailPos?.loop">Lean.Syntax.getTailPos?.loop</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.SepArray">Lean.Syntax.SepArray</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.TSepArray">Lean.Syntax.TSepArray</a></div><div class="nav_link"><a class="break_within" href="#Lean.TSyntaxArray">Lean.TSyntaxArray</a></div><div class="nav_link"><a class="break_within" href="#Lean.TSyntaxArray.rawImpl">Lean.TSyntaxArray.rawImpl</a></div><div class="nav_link"><a class="break_within" href="#Lean.TSyntaxArray.raw">Lean.TSyntaxArray.raw</a></div><div class="nav_link"><a class="break_within" href="#Lean.TSyntaxArray.mkImpl">Lean.TSyntaxArray.mkImpl</a></div><div class="nav_link"><a class="break_within" href="#Lean.TSyntaxArray.mk">Lean.TSyntaxArray.mk</a></div><div class="nav_link"><a class="break_within" href="#Lean.SourceInfo.fromRef">Lean.SourceInfo.fromRef</a></div><div class="nav_link"><a class="break_within" href="#Lean.mkAtom">Lean.mkAtom</a></div><div class="nav_link"><a class="break_within" href="#Lean.mkAtomFrom">Lean.mkAtomFrom</a></div><div class="nav_link"><a class="break_within" href="#Lean.ParserDescr">Lean.ParserDescr</a></div><div class="nav_link"><a class="break_within" href="#Lean.instInhabitedParserDescr">Lean.instInhabitedParserDescr</a></div><div class="nav_link"><a class="break_within" href="#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></div><div class="nav_link"><a class="break_within" href="#Lean.MacroScope">Lean.MacroScope</a></div><div class="nav_link"><a class="break_within" href="#Lean.reservedMacroScope">Lean.reservedMacroScope</a></div><div class="nav_link"><a class="break_within" href="#Lean.firstFrontendMacroScope">Lean.firstFrontendMacroScope</a></div><div class="nav_link"><a class="break_within" href="#Lean.MonadRef">Lean.MonadRef</a></div><div class="nav_link"><a class="break_within" href="#Lean.instMonadRef">Lean.instMonadRef</a></div><div class="nav_link"><a class="break_within" href="#Lean.replaceRef">Lean.replaceRef</a></div><div class="nav_link"><a class="break_within" href="#Lean.withRef">Lean.withRef</a></div><div class="nav_link"><a class="break_within" href="#Lean.MonadQuotation">Lean.MonadQuotation</a></div><div class="nav_link"><a class="break_within" href="#Lean.MonadRef.mkInfoFromRefPos">Lean.MonadRef.mkInfoFromRefPos</a></div><div class="nav_link"><a class="break_within" href="#Lean.instMonadQuotation">Lean.instMonadQuotation</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.hasMacroScopes">Lean.Name.hasMacroScopes</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.eraseMacroScopes">Lean.Name.eraseMacroScopes</a></div><div class="nav_link"><a class="break_within" href="#Lean.Name.simpMacroScopes">Lean.Name.simpMacroScopes</a></div><div class="nav_link"><a class="break_within" href="#Lean.MacroScopesView">Lean.MacroScopesView</a></div><div class="nav_link"><a class="break_within" href="#Lean.instInhabitedMacroScopesView">Lean.instInhabitedMacroScopesView</a></div><div class="nav_link"><a class="break_within" href="#Lean.MacroScopesView.review">Lean.MacroScopesView.review</a></div><div class="nav_link"><a class="break_within" href="#Lean.extractMacroScopes">Lean.extractMacroScopes</a></div><div class="nav_link"><a class="break_within" href="#Lean.addMacroScope">Lean.addMacroScope</a></div><div class="nav_link"><a class="break_within" href="#Lean.MonadQuotation.addMacroScope">Lean.MonadQuotation.addMacroScope</a></div><div class="nav_link"><a class="break_within" href="#Lean.defaultMaxRecDepth">Lean.defaultMaxRecDepth</a></div><div class="nav_link"><a class="break_within" href="#Lean.maxRecDepthErrorMessage">Lean.maxRecDepthErrorMessage</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.matchesNull">Lean.Syntax.matchesNull</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.matchesIdent">Lean.Syntax.matchesIdent</a></div><div class="nav_link"><a class="break_within" href="#Lean.Syntax.matchesLit">Lean.Syntax.matchesLit</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.instNonemptyMethodsRef">Lean.Macro.instNonemptyMethodsRef</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.Context">Lean.Macro.Context</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.Exception">Lean.Macro.Exception</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.State">Lean.Macro.State</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.instInhabitedState">Lean.Macro.instInhabitedState</a></div><div class="nav_link"><a class="break_within" href="#Lean.MacroM">Lean.MacroM</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro">Lean.Macro</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.instMonadRefMacroM">Lean.Macro.instMonadRefMacroM</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.addMacroScope">Lean.Macro.addMacroScope</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.throwUnsupported">Lean.Macro.throwUnsupported</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.throwError">Lean.Macro.throwError</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.throwErrorAt">Lean.Macro.throwErrorAt</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.withFreshMacroScope">Lean.Macro.withFreshMacroScope</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.withIncRecDepth">Lean.Macro.withIncRecDepth</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.instMonadQuotationMacroM">Lean.Macro.instMonadQuotationMacroM</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.Methods">Lean.Macro.Methods</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.instInhabitedMethods">Lean.Macro.instInhabitedMethods</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.mkMethodsImp">Lean.Macro.mkMethodsImp</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.mkMethods">Lean.Macro.mkMethods</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.instInhabitedMethodsRef">Lean.Macro.instInhabitedMethodsRef</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.getMethodsImp">Lean.Macro.getMethodsImp</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.getMethods">Lean.Macro.getMethods</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.expandMacro?">Lean.Macro.expandMacro?</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.hasDecl">Lean.Macro.hasDecl</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.getCurrNamespace">Lean.Macro.getCurrNamespace</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.resolveNamespace">Lean.Macro.resolveNamespace</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.resolveGlobalName">Lean.Macro.resolveGlobalName</a></div><div class="nav_link"><a class="break_within" href="#Lean.Macro.trace">Lean.Macro.trace</a></div><div class="nav_link"><a class="break_within" href="#Lean.PrettyPrinter.UnexpandM">Lean.PrettyPrinter.UnexpandM</a></div><div class="nav_link"><a class="break_within" href="#Lean.PrettyPrinter.Unexpander">Lean.PrettyPrinter.Unexpander</a></div><div class="nav_link"><a class="break_within" href="#Lean.PrettyPrinter.instMonadQuotationUnexpandM">Lean.PrettyPrinter.instMonadQuotationUnexpandM</a></div></nav><main>
<div class="mod_doc"><h1 class="markdown-heading" id="Init-Prelude">Init.Prelude <a class="hover-link" href="#Init-Prelude">#</a></h1><p>This is the first file in the lean import hierarchy. It is responsible for setting
up basic definitions, most of which lean already has "built in knowledge" about,
so it is important that they be set up in exactly this way. (For example, lean will
use <code><a href=".././Init/Prelude.html#PUnit">PUnit</a></code> in the desugaring of <code>do</code> notation, or in the pattern match compiler.)</p></div><div class="decl" id="id"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L33-L33">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#id">id</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>The identity function. <code><a href=".././Init/Prelude.html#id">id</a></code> takes an implicit argument <code>α : Sort u</code>
(a type in any universe), and an argument <code>a : α</code>, and returns <code>a</code>.</p><p>Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If <code>e</code> has type <code>T</code>,
and <code>T'</code> is definitionally equal to <code>T</code>, then <code>@id T' e</code> typechecks, and lean
knows that this expression has type <code>T'</code> rather than <code>T</code>. This can make a
difference for typeclass inference, since <code>T</code> and <code>T'</code> may have different
typeclass instances on them. <code>show T' from e</code> is sugar for an <code>@id T' e</code>
expression.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#id">id</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></li></ul></details></div></div><div class="decl" id="Function.comp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L52-L53">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Function.comp">Function.comp</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Sort v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <span class="fn">Sort w</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">β</span> → <span class="fn">δ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(g : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">δ</span></span></div></div><p>Function composition is the act of pipelining the result of one function, to the input of another, creating an entirely new function.
Example:</p><pre><code>#eval <a href=".././Init/Prelude.html#Function.comp">Function.comp</a> <a href=".././Init/Data/List/Basic.html#List.reverse">List.reverse</a> (List.drop 2) [3, 2, 4, 1]
-- [1, 4]
</code></pre><p>You can use the notation <code>f ∘ g</code> as shorthand for <code><a href=".././Init/Prelude.html#Function.comp">Function.comp</a> f g</code>.</p><pre><code>#eval (List.reverse ∘ <a href=".././Init/Data/List/Basic.html#List.drop">List.drop</a> 2) [3, 2, 4, 1]
-- [1, 4]
</code></pre><p>A simpler way of thinking about it, is that <code><a href=".././Init/Data/List/Basic.html#List.reverse">List.reverse</a> ∘ <a href=".././Init/Data/List/Basic.html#List.drop">List.drop</a> 2</code>
is equivalent to <code>fun xs => <a href=".././Init/Data/List/Basic.html#List.reverse">List.reverse</a> (List.drop 2 xs)</code>,
the benefit is that the meaning of composition is obvious,
and the representation is compact.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Function.comp">Function.comp</a> <span class="fn">f</span> <span class="fn">g</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> (<span class="fn"><span class="fn">g</span> <span class="fn">x</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="Function.const"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L66-L67">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Function.const">Function.const</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(β : <span class="fn">Sort v</span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span></div></div><p>The constant function. If <code>a : α</code>, then <code><a href=".././Init/Prelude.html#Function.const">Function.const</a> β a : β → α</code> is the
"constant function with value <code>a</code>", that is, <code><a href=".././Init/Prelude.html#Function.const">Function.const</a> β a b = a</code>.</p><pre><code>example (b : Bool) : <a href=".././Init/Prelude.html#Function.const">Function.const</a> <a href=".././Init/Prelude.html#Bool">Bool</a> 10 b = 10 :=
  <a href=".././Init/Prelude.html#rfl">rfl</a>

#check <a href=".././Init/Prelude.html#Function.const">Function.const</a> <a href=".././Init/Prelude.html#Bool">Bool</a> 10
-- <a href=".././Init/Prelude.html#Bool">Bool</a> → <a href=".././Init/Prelude.html#Nat">Nat</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Function.const">Function.const</a> <span class="fn">β</span> <span class="fn">a</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></li></ul></details></div></div><div class="decl" id="inferInstance"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L86-L86">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#inferInstance">inferInstance</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[i : <span class="fn">α</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p><code><a href=".././Init/Prelude.html#inferInstance">inferInstance</a></code> synthesizes a value of any target type by typeclass
inference. This function has the same type signature as the identity
function, but the square brackets on the <code>[i : α]</code> argument means that it will
attempt to construct this argument by typeclass inference. (This will fail if
<code>α</code> is not a <code>class</code>.) Example:</p><pre><code>#check (inferInstance : <a href=".././Init/Prelude.html#Inhabited">Inhabited</a> Nat) -- <a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Nat">Nat</a>

def foo : <a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (Nat × Nat) :=
  <a href=".././Init/Prelude.html#inferInstance">inferInstance</a>

example : foo.default = (default, default) :=
  <a href=".././Init/Prelude.html#rfl">rfl</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">inferInstance</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">i</span></span></li></ul></details></div></div><div class="decl" id="inferInstanceAs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L100-L100">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Sort u</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[i : <span class="fn">α</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p><code><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> α</code> synthesizes a value of any target type by typeclass
inference. This is just like <code><a href=".././Init/Prelude.html#inferInstance">inferInstance</a></code> except that <code>α</code> is given
explicitly instead of being inferred from the target type. It is especially
useful when the target type is some <code>α'</code> which is definitionally equal to <code>α</code>,
but the instance we are looking for is only registered for <code>α</code> (because
typeclass search does not unfold most definitions, but definitional equality
does.) Example:</p><pre><code>#check <a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> (Inhabited Nat) -- <a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Nat">Nat</a>
</code></pre><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">i</span></span></li></ul></details></div></div><div class="decl" id="PUnit"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L109-L111">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#PUnit">PUnit</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Sort u</span></div></div><ul class="constructors"><li class="constructor" id="PUnit.unit"><div class="inductive_ctor_doc"><p><code><a href=".././Init/Prelude.html#PUnit.unit">PUnit.unit</a> : <a href=".././Init/Prelude.html#PUnit">PUnit</a></code> is the canonical element of the unit type.</p></div>unit: <a href=".././Init/Prelude.html#PUnit">PUnit</a></li></ul><p>The unit type, the canonical type with one element, named <code><a href=".././Init/Prelude.html#Unit.unit">unit</a></code> or <code>()</code>.
This is the universe-polymorphic version of <code><a href=".././Init/Prelude.html#Unit">Unit</a></code>; it is preferred to use
<code><a href=".././Init/Prelude.html#Unit">Unit</a></code> instead where applicable.
For more information about universe levels: <a href="https://leanprover.github.io/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects">Types as objects</a></p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-PUnit" class="instances-for-list"></ul></details></div></div><div class="decl" id="Unit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L129-L129">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Unit">Unit</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><p>The unit type, the canonical type with one element, named <code><a href=".././Init/Prelude.html#Unit.unit">unit</a></code> or <code>()</code>.
In other words, it describes only a single value, which consists of said constructor applied
to no arguments whatsoever.
The <code><a href=".././Init/Prelude.html#Unit">Unit</a></code> type is similar to <code>void</code> in languages derived from C.</p><p><code><a href=".././Init/Prelude.html#Unit">Unit</a></code> is actually defined as <code>PUnit.{0}</code> where <code><a href=".././Init/Prelude.html#PUnit">PUnit</a></code> is the universe
polymorphic version. The <code><a href=".././Init/Prelude.html#Unit">Unit</a></code> should be preferred over <code><a href=".././Init/Prelude.html#PUnit">PUnit</a></code> where possible to avoid
unnecessary universe parameters.</p><p>In functional programming, <code><a href=".././Init/Prelude.html#Unit">Unit</a></code> is the return type of things that "return
nothing", since a type with one element conveys no additional information.
When programming with monads, the type <code>m <a href=".././Init/Prelude.html#Unit">Unit</a></code> represents an action that has
some side effects but does not return a value, while <code>m α</code> would be an action
that has side effects and returns a value of type <code>α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></li></ul></details></div></div><div class="decl" id="Unit.unit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L135-L135">source</a></div><div class="attributes">@[matchPattern, inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Unit.unit">Unit.unit</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Unit">Unit</a></div></div><p><code><a href=".././Init/Prelude.html#Unit.unit">Unit.unit</a> : <a href=".././Init/Prelude.html#Unit">Unit</a></code> is the canonical element of the unit type.
It can also be written as <code>()</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Unit.unit">()</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></li></ul></details></div></div><div class="decl" id="lcErased"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L138-L138">source</a></div><div class="decl_header"><span class="decl_kind">unsafe axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#lcErased">lcErased</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><p>Marker for information that has been erased by the code generator.</p></div></div><div class="decl" id="lcAny"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L141-L141">source</a></div><div class="decl_header"><span class="decl_kind">unsafe axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#lcAny">lcAny</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><p>"Any" type in the simpler type system used by the code generator.</p></div></div><div class="decl" id="lcProof"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L152-L152">source</a></div><div class="decl_header"><span class="decl_kind">unsafe axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#lcProof">lcProof</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Prop</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Auxiliary unsafe constant used by the Compiler when erasing proofs from code.</p><p>It may look strange to have an axiom that says "every proposition is true",
since this is obviously unsound, but the <code>unsafe</code> marker ensures that the
kernel will not let this through into regular proofs. The lower levels of the
code generator don't need proofs in terms, so this is used to stub the proofs
out.</p></div></div><div class="decl" id="lcCast"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L157-L157">source</a></div><div class="decl_header"><span class="decl_kind">unsafe axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#lcCast">lcCast</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Sort v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Auxiliary unsafe constant used by the Compiler when erasing casts.</p></div></div><div class="decl" id="lcUnreachable"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L172-L172">source</a></div><div class="decl_header"><span class="decl_kind">unsafe axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#lcUnreachable">lcUnreachable</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Auxiliary unsafe constant used by the Compiler to mark unreachable code.</p><p>Like <code><a href=".././Init/Prelude.html#lcProof">lcProof</a></code>, this is an <code>unsafe axiom</code>, which means that even though it is
not sound, the kernel will not let us use it for regular proofs.</p><p>Executing this expression to actually synthesize a value of type <code>α</code> causes
<strong>immediate undefined behavior</strong>, and the compiler does take advantage of this
to optimize the code assuming that it is not called. If it is not optimized out,
it is likely to appear as a print message saying "unreachable code", but this
behavior is not guaranteed or stable in any way.</p></div></div><div class="decl" id="True"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L179-L182">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#True">True</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Prop</span></div></div><ul class="constructors"><li class="constructor" id="True.intro"><div class="inductive_ctor_doc"><p><code><a href=".././Init/Prelude.html#True">True</a></code> is true, and <code><a href=".././Init/Prelude.html#True.intro">True.intro</a></code> (or more commonly, <code><a href=".././Init/Core.html#trivial">trivial</a></code>)
is the proof.</p></div>intro: <a href=".././Init/Prelude.html#True">True</a></li></ul><p><code><a href=".././Init/Prelude.html#True">True</a></code> is a proposition and has only an introduction rule, <code><a href=".././Init/Prelude.html#True.intro">True.intro</a> : <a href=".././Init/Prelude.html#True">True</a></code>.
In other words, <code><a href=".././Init/Prelude.html#True">True</a></code> is simply true, and has a canonical proof, <code><a href=".././Init/Prelude.html#True.intro">True.intro</a></code>
For more information: <a href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic">Propositional Logic</a></p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-True" class="instances-for-list"></ul></details></div></div><div class="decl" id="False"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L192-L192">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#False">False</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Prop</span></div></div><ul class="constructors"></ul><p><code><a href=".././Init/Prelude.html#False">False</a></code> is the empty proposition. Thus, it has no introduction rules.
It represents a contradiction. <code><a href=".././Init/Prelude.html#False">False</a></code> elimination rule, <code><a href=".././Init/Prelude.html#False.rec">False.rec</a></code>,
expresses the fact that anything follows from a contradiction.
This rule is sometimes called ex falso (short for ex falso sequitur quodlibet),
or the principle of explosion.
For more information: <a href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic">Propositional Logic</a></p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-False" class="instances-for-list"></ul></details></div></div><div class="decl" id="Empty"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L198-L198">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Empty">Empty</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="constructors"></ul><p>The empty type. It has no constructors. The <code><a href=".././Init/Prelude.html#Empty.rec">Empty.rec</a></code>
eliminator expresses the fact that anything follows from the empty type.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Empty" class="instances-for-list"></ul></details></div></div><div class="decl" id="PEmpty"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L205-L205">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#PEmpty">PEmpty</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Sort u</span></div></div><ul class="constructors"></ul><p>The universe-polymorphic empty type. Prefer <code><a href=".././Init/Prelude.html#Empty">Empty</a></code> or <code><a href=".././Init/Prelude.html#False">False</a></code> where
possible.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-PEmpty" class="instances-for-list"></ul></details></div></div><div class="decl" id="Not"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L214-L214">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Not">Not</a></span><span class="decl_args">
<span class="fn">(a : <span class="fn">Prop</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Prop</span></div></div><p><code><a href=".././Init/Prelude.html#Not">Not</a> p</code>, or <code>¬p</code>, is the negation of <code>p</code>. It is defined to be <code>p → <a href=".././Init/Prelude.html#False">False</a></code>,
so if your goal is <code>¬p</code> you can use <code>intro h</code> to turn the goal into
<code>h : p ⊢ <a href=".././Init/Prelude.html#False">False</a></code>, and if you have <code>hn : ¬p</code> and <code>h : p</code> then <code>hn h : <a href=".././Init/Prelude.html#False">False</a></code>
and <code>(hn h).<a href=".././Init/Prelude.html#False.elim">elim</a></code> will prove anything.
For more information: <a href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic">Propositional Logic</a></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span>) <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">a</span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></li></ul></details></div></div><div class="decl" id="False.elim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L226-L227">source</a></div><div class="attributes">@[macroInline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#False.elim">False.elim</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{C : <span class="fn">Sort u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <a href=".././Init/Prelude.html#False">False</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">C</span></div></div><p><code><a href=".././Init/Prelude.html#False.elim">False.elim</a> : <a href=".././Init/Prelude.html#False">False</a> → C</code> says that from <code><a href=".././Init/Prelude.html#False">False</a></code>, any desired proposition
<code>C</code> holds. Also known as ex falso quodlibet (EFQ) or the principle of explosion.</p><p>The target type is actually <code>C : Sort u</code> which means it works for both
propositions and types. When executed, this acts like an "unreachable"
instruction: it is <strong>undefined behavior</strong> to run, but it will probably print
"unreachable code". (You would need to construct a proof of false to run it
anyway, which you can only do using <code>sorry</code> or unsound axioms.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#False.elim">False.elim</a> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#False.rec">False.rec</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn">C</span></span>) <span class="fn">h</span></span></span></li></ul></details></div></div><div class="decl" id="absurd"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L236-L237">source</a></div><div class="attributes">@[macroInline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#absurd">absurd</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Prop</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Sort v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn">a</span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">b</span></div></div><p>Anything follows from two contradictory hypotheses. Example:</p><pre><code>example (hp : p) (hnp : ¬p) : q := <a href=".././Init/Prelude.html#absurd">absurd</a> hp hnp
</code></pre><p>For more information: <a href="https://leanprover.github.io/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic">Propositional Logic</a></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#absurd">absurd</a> <span class="fn">h₁</span> <span class="fn">h₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#False.rec">False.rec</a> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn">b</span></span>) (<span class="fn"><span class="fn">h₂</span> <span class="fn">h₁</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="Eq"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L266-L269">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Eq">Eq</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u_1</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">Prop</span></span></div></div><ul class="constructors"><li class="constructor" id="Eq.refl"><div class="inductive_ctor_doc"><p><code><a href=".././Init/Prelude.html#Eq.refl">Eq.refl</a> a : a = a</code> is reflexivity, the unique constructor of the
equality type. See also <code><a href=".././Init/Prelude.html#rfl">rfl</a></code>, which is usually used instead.</p></div>refl: <span class="fn">∀ {<span class="fn">α</span> : <span class="fn">Sort u_1</span>} (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></span></li></ul><p>The equality relation. It has one introduction rule, <code><a href=".././Init/Prelude.html#Eq.refl">Eq.refl</a></code>.
We use <code>a = b</code> as notation for <code><a href=".././Init/Prelude.html#Eq">Eq</a> a b</code>.
A fundamental property of equality is that it is an equivalence relation.</p><pre><code>variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  <a href=".././Init/Prelude.html#Eq.trans">Eq.trans</a> (Eq.<a href=".././Init/Prelude.html#Eq.trans">trans</a> hab (Eq.<a href=".././Init/Prelude.html#Eq.symm">symm</a> hcb)) hcd
</code></pre><p>Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given <code>h1 : a = b</code> and <code>h2 : p a</code>, we can construct a proof for <code>p b</code> using substitution: <code><a href=".././Init/Prelude.html#Eq.subst">Eq.subst</a> h1 h2</code>.
Example:</p><pre><code>example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  <a href=".././Init/Prelude.html#Eq.subst">Eq.subst</a> h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
</code></pre><p>The triangle in the second presentation is a macro built on top of <code><a href=".././Init/Prelude.html#Eq.subst">Eq.subst</a></code> and <code><a href=".././Init/Prelude.html#Eq.symm">Eq.symm</a></code>, and you can enter it by typing <code>\t</code>.
For more information: <a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality">Equality</a></p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Eq" class="instances-for-list"></ul></details></div></div><div class="decl" id="rfl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L284-L284">source</a></div><div class="attributes">@[matchPattern]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#rfl">rfl</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div><p><code><a href=".././Init/Prelude.html#rfl">rfl</a> : a = a</code> is the unique constructor of the equality type. This is the
same as <code><a href=".././Init/Prelude.html#Eq.refl">Eq.refl</a></code> except that it takes <code>a</code> implicitly instead of explicitly.</p><p>This is a more powerful theorem than it may appear at first, because although
the statement of the theorem is <code>a = a</code>, lean will allow anything that is
definitionally equal to that type. So, for instance, <code>2 + 2 = 4</code> is proven in
lean by <code><a href=".././Init/Prelude.html#rfl">rfl</a></code>, because both sides are the same up to definitional equality.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#rfl">@<a href=".././Init/Prelude.html#rfl">rfl</a></a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#rfl.proof_1">@<a href=".././Init/Prelude.html#rfl.proof_1">rfl.proof_1</a></a></span></li></ul></details></div></div><div class="decl" id="id_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L287-L287">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#id_eq">id_eq</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#id">id</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div><p><code><a href=".././Init/Prelude.html#id">id</a> x = x</code>, as a <code>@[simp]</code> lemma.</p></div></div><div class="decl" id="Eq.subst"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L302-L303">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Eq.subst">Eq.subst</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{motive : <span class="fn"><span class="fn">α</span> → <span class="fn">Prop</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">motive</span> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">motive</span> <span class="fn">b</span></span></div></div><p>The substitution principle for equality. If <code>a = b </code> and <code>P a</code> holds,
then <code>P b</code> also holds. We conventionally use the name <code>motive</code> for <code>P</code> here,
so that you can specify it explicitly using e.g.
<code><a href=".././Init/Prelude.html#Eq.subst">Eq.subst</a> (motive := fun x => x < 5)</code> if it is not otherwise inferred correctly.</p><p>This theorem is the underlying mechanism behind the <code>rw</code> tactic, which is
essentially a fancy algorithm for finding good <code>motive</code> arguments to usefully
apply this theorem to replace occurrences of <code>a</code> with <code>b</code> in the goal or
hypotheses.</p><p>For more information: <a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality">Equality</a></p></div></div><div class="decl" id="Eq.symm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L313-L314">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Eq.symm">Eq.symm</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div><p>Equality is symmetric: if <code>a = b</code> then <code>b = a</code>.</p><p>Because this is in the <code><a href=".././Init/Prelude.html#Eq">Eq</a></code> namespace, if you have a variable <code>h : a = b</code>,
<code>h.<a href=".././Init/Prelude.html#Eq.symm">symm</a></code> can be used as shorthand for <code><a href=".././Init/Prelude.html#Eq.symm">Eq.symm</a> h</code> as a proof of <code>b = a</code>.</p><p>For more information: <a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality">Equality</a></p></div></div><div class="decl" id="Eq.trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L325-L326">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Eq.trans">Eq.trans</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">c</span></span></div></div><p>Equality is transitive: if <code>a = b</code> and <code>b = c</code> then <code>a = c</code>.</p><p>Because this is in the <code><a href=".././Init/Prelude.html#Eq">Eq</a></code> namespace, if you variables or expressions
<code>h₁ : a = b</code> and <code>h₂ : b = c</code>, you can use <code>h₁.<a href=".././Init/Prelude.html#Eq.trans">trans</a> h₂ : a = c</code> as shorthand
for <code><a href=".././Init/Prelude.html#Eq.trans">Eq.trans</a> h₁ h₂</code>.</p><p>For more information: <a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality">Equality</a></p></div></div><div class="decl" id="cast"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L339-L340">source</a></div><div class="attributes">@[macroInline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#cast">cast</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Sort u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>Cast across a type equality. If <code>h : α = β</code> is an equality of types, and
<code>a : α</code>, then <code>a : β</code> will usually not typecheck directly, but this function
will allow you to work around this and embed <code>a</code> in type <code>β</code> as <code><a href=".././Init/Prelude.html#cast">cast</a> h a : β</code>.</p><p>It is best to avoid this function if you can, because it is more complicated
to reason about terms containing casts, but if the types don't match up
definitionally sometimes there isn't anything better you can do.</p><p>For more information: <a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality">Equality</a></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#cast">cast</a> <span class="fn">h</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">h</span> ▸ <span class="fn">a</span></span></span></li></ul></details></div></div><div class="decl" id="congrArg"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L352-L353">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#congrArg">congrArg</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Sort v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a₁</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a₁</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f</span> <span class="fn">a₂</span></span></span></div></div><p>Congruence in the function argument: if <code>a₁ = a₂</code> then <code>f a₁ = f a₂</code> for
any (nondependent) function <code>f</code>. This is more powerful than it might look at first, because
you can also use a lambda expression for <code>f</code> to prove that
<code><something containing a₁> = <something containing a₂></code>. This function is used
internally by tactics like <code><a href=".././Init/Prelude.html#congr">congr</a></code> and <code>simp</code> to apply equalities inside
subterms.</p><p>For more information: <a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality">Equality</a></p></div></div><div class="decl" id="congr"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L362-L363">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#congr">congr</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Sort v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f₁ : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f₂ : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₁ : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a₂ : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">f₁</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">f₂</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">a₁</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a₂</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f₁</span> <span class="fn">a₁</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">f₂</span> <span class="fn">a₂</span></span></span></div></div><p>Congruence in both function and argument. If <code>f₁ = f₂</code> and <code>a₁ = a₂</code> then
<code>f₁ a₁ = f₂ a₂</code>. This only works for nondependent functions; the theorem
statement is more complex in the dependent case.</p><p>For more information: <a href="https://leanprover.github.io/theorem_proving_in_lean4/quantifiers_and_equality.html#equality">Equality</a></p></div></div><div class="decl" id="congrFun"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L366-L367">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#congrFun">congrFun</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <span class="fn">Sort v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{f : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{g : <span class="fn">(<span class="fn">x</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">x</span></span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">f</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">g</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">g</span> <span class="fn">a</span></span></span></div></div><p>Congruence in the function part of an application: If <code>f = g</code> then <code>f a = g a</code>.</p></div></div><div class="mod_doc"><p>Initialize the Quotient Module, which effectively adds the following definitions:</p><pre><code>opaque <a href=".././Init/Prelude.html#Quot">Quot</a> {α : Sort u} (r : α → α → Prop) : Sort u

opaque <a href=".././Init/Prelude.html#Quot.mk">Quot.mk</a> {α : Sort u} (r : α → α → Prop) (a : α) : <a href=".././Init/Prelude.html#Quot">Quot</a> r

opaque <a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a> {α : Sort u} {r : α → α → Prop} {β : Sort v} (f : α → β) :
  (∀ a b : α, r a b → <a href=".././Init/Prelude.html#Eq">Eq</a> (f a) (f b)) → <a href=".././Init/Prelude.html#Quot">Quot</a> r → β

opaque <a href=".././Init/Prelude.html#Quot.ind">Quot.ind</a> {α : Sort u} {r : α → α → Prop} {β : <a href=".././Init/Prelude.html#Quot">Quot</a> r → Prop} :
  (∀ a : α, β (Quot.<a href=".././Init/Prelude.html#Lean.TSyntaxArray.mk">mk</a> r a)) → ∀ q : <a href=".././Init/Prelude.html#Quot">Quot</a> r, β q
</code></pre></div><div class="decl" id="Quot.lcInv"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L432-L432">source</a></div><div class="decl_header"><span class="decl_kind">unsafe axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Quot.lcInv">Quot.lcInv</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">Prop</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(q : <span class="fn"><a href=".././Init/Prelude.html#Quot">Quot</a> <span class="fn">r</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Unsafe auxiliary constant used by the compiler to erase <code><a href=".././Init/Prelude.html#Quot.lift">Quot.lift</a></code>.</p></div></div><div class="decl" id="HEq"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L446-L448">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HEq">HEq</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">α</span> → <span class="fn">{<span class="fn">β</span> : <span class="fn">Sort u</span>} → <span class="fn"><span class="fn">β</span> → <span class="fn">Prop</span></span></span></span></div></div><ul class="constructors"><li class="constructor" id="HEq.refl"><div class="inductive_ctor_doc"><p>Reflexivity of heterogeneous equality.</p></div>refl: <span class="fn">∀ {<span class="fn">α</span> : <span class="fn">Sort u</span>} (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">a</span></span></span></li></ul><p>Heterogeneous equality. <code><a href=".././Init/Prelude.html#HEq">HEq</a> a b</code> asserts that <code>a</code> and <code>b</code> have the same
type, and casting <code>a</code> across the equality yields <code>b</code>, and vice versa.</p><p>You should avoid using this type if you can. Heterogeneous equality does not
have all the same properties as <code><a href=".././Init/Prelude.html#Eq">Eq</a></code>, because the assumption that the types of
<code>a</code> and <code>b</code> are equal is often too weak to prove theorems of interest. One
important non-theorem is the analogue of <code><a href=".././Init/Prelude.html#congr">congr</a></code>: If <code><a href=".././Init/Prelude.html#HEq">HEq</a> f g</code> and <code><a href=".././Init/Prelude.html#HEq">HEq</a> x y</code>
and <code>f x</code> and <code>g y</code> are well typed it does not follow that <code><a href=".././Init/Prelude.html#HEq">HEq</a> (f x) (g y)</code>.
(This does follow if you have <code>f = g</code> instead.) However if <code>a</code> and <code>b</code> have
the same type then <code>a = b</code> and <code><a href=".././Init/Prelude.html#HEq">HEq</a> a b</code> ae equivalent.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-HEq" class="instances-for-list"></ul></details></div></div><div class="decl" id="HEq.rfl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L451-L452">source</a></div><div class="attributes">@[matchPattern]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HEq.rfl">HEq.rfl</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">a</span></span></div></div><p>A version of <code><a href=".././Init/Prelude.html#HEq.refl">HEq.refl</a></code> with an implicit argument.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#HEq.rfl">@<a href=".././Init/Prelude.html#HEq.rfl">HEq.rfl</a></a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#HEq.rfl.proof_1">@<a href=".././Init/Prelude.html#HEq.rfl.proof_1">HEq.rfl.proof_1</a></a></span></li></ul></details></div></div><div class="decl" id="eq_of_heq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L454-L458">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#eq_of_heq">eq_of_heq</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">α</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a' : <span class="fn">α</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#HEq">HEq</a> <span class="fn">a</span> <span class="fn">a'</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a'</span></span></div></div></div></div><div class="decl" id="Prod"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L469-L473">source</a></div><div class="attributes">@[unbox]</div>
<div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Prod">Prod</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max u v)</span></div></div><ul class="structure_fields" id="Prod.mk"><li id="Prod.fst" class="structure_field"><div class="structure_field_doc"><p>The first projection out of a pair. if <code>p : α × β</code> then <code>p.1 : α</code>.</p></div><div class="structure_field_info">fst : <span class="fn">α</span></div></li><li id="Prod.snd" class="structure_field"><div class="structure_field_doc"><p>The second projection out of a pair. if <code>p : α × β</code> then <code>p.2 : β</code>.</p></div><div class="structure_field_info">snd : <span class="fn">β</span></div></li></ul><p>Product type (aka pair). You can use <code>α × β</code> as notation for <code><a href=".././Init/Prelude.html#Prod">Prod</a> α β</code>.
Given <code>a : α</code> and <code>b : β</code>, <code><a href=".././Init/Prelude.html#Prod.mk">Prod.mk</a> a b : <a href=".././Init/Prelude.html#Prod">Prod</a> α β</code>. You can use <code>(a, b)</code>
as notation for <code><a href=".././Init/Prelude.html#Prod.mk">Prod.mk</a> a b</code>. Moreover, <code>(a, b, c)</code> is notation for
<code><a href=".././Init/Prelude.html#Prod.mk">Prod.mk</a> a (Prod.<a href=".././Init/Prelude.html#Lean.TSyntaxArray.mk">mk</a> b c)</code>.
Given <code>p : <a href=".././Init/Prelude.html#Prod">Prod</a> α β</code>, <code>p.1 : α</code> and <code>p.2 : β</code>. They are short for <code><a href=".././Init/Prelude.html#Prod.fst">Prod.fst</a> p</code>
and <code><a href=".././Init/Prelude.html#Prod.snd">Prod.snd</a> p</code> respectively. You can also write <code>p.fst</code> and <code>p.snd</code>.
For more information: <a href="https://leanprover.github.io/theorem_proving_in_lean4/inductive_types.html?highlight=Prod#constructors-with-arguments">Constructors with Arguments</a></p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Prod" class="instances-for-list"></ul></details></div></div><div class="decl" id="PProd"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L481-L485">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#PProd">PProd</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Sort u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Sort v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Sort (max (max 1 u) v)</span></div></div><ul class="structure_fields" id="PProd.mk"><li id="PProd.fst" class="structure_field"><div class="structure_field_doc"><p>The first projection out of a pair. if <code>p : <a href=".././Init/Prelude.html#PProd">PProd</a> α β</code> then <code>p.1 : α</code>.</p></div><div class="structure_field_info">fst : <span class="fn">α</span></div></li><li id="PProd.snd" class="structure_field"><div class="structure_field_doc"><p>The second projection out of a pair. if <code>p : <a href=".././Init/Prelude.html#PProd">PProd</a> α β</code> then <code>p.2 : β</code>.</p></div><div class="structure_field_info">snd : <span class="fn">β</span></div></li></ul><p>Similar to <code><a href=".././Init/Prelude.html#Prod">Prod</a></code>, but <code>α</code> and <code>β</code> can be propositions.
We use this Type internally to automatically generate the <code>brecOn</code> recursor.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-PProd" class="instances-for-list"></ul></details></div></div><div class="decl" id="MProd"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L491-L495">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MProd">MProd</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="MProd.mk"><li id="MProd.fst" class="structure_field"><div class="structure_field_doc"><p>The first projection out of a pair. if <code>p : <a href=".././Init/Prelude.html#MProd">MProd</a> α β</code> then <code>p.1 : α</code>.</p></div><div class="structure_field_info">fst : <span class="fn">α</span></div></li><li id="MProd.snd" class="structure_field"><div class="structure_field_doc"><p>The second projection out of a pair. if <code>p : <a href=".././Init/Prelude.html#MProd">MProd</a> α β</code> then <code>p.2 : β</code>.</p></div><div class="structure_field_info">snd : <span class="fn">β</span></div></li></ul><p>Similar to <code><a href=".././Init/Prelude.html#Prod">Prod</a></code>, but <code>α</code> and <code>β</code> are in the same universe.
We say <code><a href=".././Init/Prelude.html#MProd">MProd</a></code> is the universe monomorphic product type.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-MProd" class="instances-for-list"></ul></details></div></div><div class="decl" id="And"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L502-L510">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#And">And</a></span><span class="decl_args">
<span class="fn">(a : <span class="fn">Prop</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">Prop</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Prop</span></div></div><ul class="structure_ext"><li id="And.intro" class="structure_ext_ctor">intro :: (</li><ul class="structure_ext_fields"><li id="And.left" class="structure_field"><div class="structure_field_doc"><p>Extract the left conjunct from a conjunction. <code>h : a ∧ b</code> then
<code>h.left</code>, also notated as <code>h.1</code>, is a proof of <code>a</code>.</p></div><div class="structure_field_info">left : <span class="fn">a</span></div></li><li id="And.right" class="structure_field"><div class="structure_field_doc"><p>Extract the right conjunct from a conjunction. <code>h : a ∧ b</code> then
<code>h.right</code>, also notated as <code>h.2</code>, is a proof of <code>b</code>.</p></div><div class="structure_field_info">right : <span class="fn">b</span></div></li></ul><li class="structure_ext_ctor">)</li></ul><p><code><a href=".././Init/Prelude.html#And">And</a> a b</code>, or <code>a ∧ b</code>, is the conjunction of propositions. It can be
constructed and destructed like a pair: if <code>ha : a</code> and <code>hb : b</code> then
<code>⟨ha, hb⟩ : a ∧ b</code>, and if <code>h : a ∧ b</code> then <code>h.left : a</code> and <code>h.right : b</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-And" class="instances-for-list"></ul></details></div></div><div class="decl" id="Or"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L518-L522">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Or">Or</a></span><span class="decl_args">
<span class="fn">(a : <span class="fn">Prop</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">Prop</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Prop</span></div></div><ul class="constructors"><li class="constructor" id="Or.inl"><div class="inductive_ctor_doc"><p><code><a href=".././Init/Prelude.html#Or.inl">Or.inl</a></code> is "left injection" into an <code><a href=".././Init/Prelude.html#Or">Or</a></code>. If <code>h : a</code> then <code><a href=".././Init/Prelude.html#Or.inl">Or.inl</a> h : a ∨ b</code>.</p></div>inl: <span class="fn">∀ {<span class="fn">a </span>b : <span class="fn">Prop</span>}, <span class="fn"><span class="fn">a</span> → <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></span></span></li><li class="constructor" id="Or.inr"><div class="inductive_ctor_doc"><p><code><a href=".././Init/Prelude.html#Or.inr">Or.inr</a></code> is "right injection" into an <code><a href=".././Init/Prelude.html#Or">Or</a></code>. If <code>h : b</code> then <code><a href=".././Init/Prelude.html#Or.inr">Or.inr</a> h : a ∨ b</code>.</p></div>inr: <span class="fn">∀ {<span class="fn">a </span>b : <span class="fn">Prop</span>}, <span class="fn"><span class="fn">b</span> → <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></span></span></li></ul><p><code><a href=".././Init/Prelude.html#Or">Or</a> a b</code>, or <code>a ∨ b</code>, is the disjunction of propositions. There are two
constructors for <code><a href=".././Init/Prelude.html#Or">Or</a></code>, called <code><a href=".././Init/Prelude.html#Or.inl">Or.inl</a> : a → a ∨ b</code> and <code><a href=".././Init/Prelude.html#Or.inr">Or.inr</a> : b → a ∨ b</code>,
and you can use <code>match</code> or <code>cases</code> to destruct an <code><a href=".././Init/Prelude.html#Or">Or</a></code> assumption into the
two cases.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Or" class="instances-for-list"></ul></details></div></div><div class="decl" id="Or.intro_left"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L525-L526">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Or.intro_left">Or.intro_left</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Prop</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(b : <span class="fn">Prop</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">a</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></div></div><p>Alias for <code><a href=".././Init/Prelude.html#Or.inl">Or.inl</a></code>.</p></div></div><div class="decl" id="Or.intro_right"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L529-L530">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Or.intro_right">Or.intro_right</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Prop</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">Prop</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn">b</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span></div></div><p>Alias for <code><a href=".././Init/Prelude.html#Or.inr">Or.inr</a></code>.</p></div></div><div class="decl" id="Or.elim"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L536-L539">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Or.elim">Or.elim</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{a : <span class="fn">Prop</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <span class="fn">Prop</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <span class="fn">Prop</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">b</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(left : <span class="fn"><span class="fn">a</span> → <span class="fn">c</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(right : <span class="fn"><span class="fn">b</span> → <span class="fn">c</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">c</span></div></div><p>Proof by cases on an <code><a href=".././Init/Prelude.html#Or">Or</a></code>. If <code>a ∨ b</code>, and both <code>a</code> and <code>b</code> imply
proposition <code>c</code>, then <code>c</code> is true.</p></div></div><div class="decl" id="Bool"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L548-L552">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Bool">Bool</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="constructors"><li class="constructor" id="Bool.false"><div class="inductive_ctor_doc"><p>The boolean value <code>false</code>, not to be confused with the proposition <code><a href=".././Init/Prelude.html#False">False</a></code>.</p></div>false: <a href=".././Init/Prelude.html#Bool">Bool</a></li><li class="constructor" id="Bool.true"><div class="inductive_ctor_doc"><p>The boolean value <code>true</code>, not to be confused with the proposition <code><a href=".././Init/Prelude.html#True">True</a></code>.</p></div>true: <a href=".././Init/Prelude.html#Bool">Bool</a></li></ul><p><code><a href=".././Init/Prelude.html#Bool">Bool</a></code> is the type of boolean values, <code>true</code> and <code>false</code>. Classically,
this is equivalent to <code>Prop</code> (the type of propositions), but the distinction
is important for programming, because values of type <code>Prop</code> are erased in the
code generator, while <code><a href=".././Init/Prelude.html#Bool">Bool</a></code> corresponds to the type called <code><a href=".././Init/Control/Basic.html#bool">bool</a></code> or <code>boolean</code>
in most programming languages.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Bool" class="instances-for-list"></ul></details></div></div><div class="decl" id="Subtype"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L563-L570">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Subtype">Subtype</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(p : <span class="fn"><span class="fn">α</span> → <span class="fn">Prop</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Sort (max 1 u)</span></div></div><ul class="structure_fields" id="Subtype.mk"><li id="Subtype.val" class="structure_field"><div class="structure_field_doc"><p>If <code>s : {x // p x}</code> then <code>s.val : α</code> is the underlying element in the base
type. You can also write this as <code>s.1</code>, or simply as <code>s</code> when the type is
known from context.</p></div><div class="structure_field_info">val : <span class="fn">α</span></div></li><li id="Subtype.property" class="structure_field"><div class="structure_field_doc"><p>If <code>s : {x // p x}</code> then <code>s.2</code> or <code>s.property</code> is the assertion that
<code>p s.1</code>, that is, that <code>s</code> is in fact an element for which <code>p</code> holds.</p></div><div class="structure_field_info">property : <span class="fn"><span class="fn">p</span> <span class="fn">val</span></span></div></li></ul><p><code><a href=".././Init/Prelude.html#Subtype">Subtype</a> p</code>, usually written as <code>{x : α // p x}</code>, is a type which
represents all the elements <code>x : α</code> for which <code>p x</code> is true. It is structurally
a pair-like type, so if you have <code>x : α</code> and <code>h : p x</code> then
<code>⟨x, h⟩ : {x // p x}</code>. An element <code>s : {x // p x}</code> will coerce to <code>α</code> but
you can also make it explicit using <code>s.1</code> or <code>s.val</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Subtype" class="instances-for-list"></ul></details></div></div><div class="decl" id="optParam"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L580-L580">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#optParam">optParam</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Sort u</span>)</span></span>
<span class="decl_args">
<span class="fn">(default : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Sort u</span></div></div><p>Gadget for optional parameter support.</p><p>A binder like <code>(x : α := default)</code> in a declaration is syntax sugar for
<code>x : <a href=".././Init/Prelude.html#optParam">optParam</a> α default</code>, and triggers the elaborator to attempt to use
<code>default</code> to supply the argument if it is not supplied.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <span class="fn">α</span> <span class="fn">default</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">α</span></span></li></ul></details></div></div><div class="decl" id="outParam"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L598-L598">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#outParam">outParam</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Sort u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Sort u</span></div></div><p>Gadget for marking output parameters in type classes.</p><p>For example, the <code><a href=".././Init/Prelude.html#Membership">Membership</a></code> class is defined as:</p><pre><code>class <a href=".././Init/Prelude.html#Membership">Membership</a> (α : <a href=".././Init/Prelude.html#outParam">outParam</a> (Type u)) (γ : Type v)
</code></pre><p>This means that whenever a typeclass goal of the form <code><a href=".././Init/Prelude.html#Membership">Membership</a> ?α ?γ</code> comes
up, lean will wait to solve it until <code>?γ</code> is known, but then it will run
typeclass inference, and take the first solution it finds, for any value of <code>?α</code>,
which thereby determines what <code>?α</code> should be.</p><p>This expresses that in a term like <code>a ∈ s</code>, <code>s</code> might be a <code>Set α</code> or
<code><a href=".././Init/Prelude.html#List">List</a> α</code> or some other type with a membership operation, and in each case
the "member" type <code>α</code> is determined by looking at the container type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">α</span></span></li></ul></details></div></div><div class="decl" id="namedPattern"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L602-L602">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#namedPattern">namedPattern</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">x</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Auxiliary declaration used to implement named patterns like <code>x@h:p</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#namedPattern">namedPattern</a> <span class="fn">x</span> <span class="fn">a</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></li></ul></details></div></div><div class="decl" id="sorryAx"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L621-L621">source</a></div><div class="attributes">@[neverExtract, extern  lean_sorry]</div>
<div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#sorryAx">sorryAx</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Sort u</span>)</span></span>
<span class="decl_args">
<span class="fn">(synthetic : <span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Prelude.html#Bool">Bool</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Auxiliary axiom used to implement <code>sorry</code>.</p><p>The <code>sorry</code> term/tactic expands to <code><a href=".././Init/Prelude.html#sorryAx">sorryAx</a> _ (synthetic := false)</code>. This is a
proof of anything, which is intended for stubbing out incomplete parts of a
proof while still having a syntactically correct proof skeleton. Lean will give
a warning whenever a proof uses <code>sorry</code>, so you aren't likely to miss it, but
you can double check if a theorem depends on <code>sorry</code> by using
<code>#print axioms my_thm</code> and looking for <code><a href=".././Init/Prelude.html#sorryAx">sorryAx</a></code> in the axiom list.</p><p>The <code>synthetic</code> flag is false when written explicitly by the user, but it is
set to <code>true</code> when a tactic fails to prove a goal, or if there is a type error
in the expression. A synthetic <code>sorry</code> acts like a regular one, except that it
suppresses follow-up errors in order to prevent one error from causing a cascade
of other errors because the desired term was not constructed.</p></div></div><div class="decl" id="eq_false_of_ne_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L623-L625">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#eq_false_of_ne_true">eq_false_of_ne_true</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></span> → <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></span></div></div></div></div><div class="decl" id="eq_true_of_ne_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L627-L629">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#eq_true_of_ne_false">eq_true_of_ne_false</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></span> → <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="ne_false_of_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L631-L633">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ne_false_of_eq_true">ne_false_of_eq_true</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span> → <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></span></span></div></div></div></div><div class="decl" id="ne_true_of_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L635-L637">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ne_true_of_eq_false">ne_true_of_eq_false</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{b : <a href=".././Init/Prelude.html#Bool">Bool</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span> → <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></span></span></div></div></div></div><div class="decl" id="Inhabited"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L650-L654">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Inhabited">Inhabited</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Sort u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Sort (max 1 u)</span></div></div><ul class="structure_fields" id="Inhabited.mk"><li id="Inhabited.default" class="structure_field"><div class="structure_field_doc"><p><code>default</code> is a function that produces a "default" element of any
<code><a href=".././Init/Prelude.html#Inhabited">Inhabited</a></code> type. This element does not have any particular specified
properties, but it is often an all-zeroes value.</p></div><div class="structure_field_info">default : <span class="fn">α</span></div></li></ul><p><code><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> α</code> is a typeclass that says that <code>α</code> has a designated element,
called <code>(default : α)</code>. This is sometimes referred to as a "pointed type".</p><p>This class is used by functions that need to return a value of the type
when called "out of domain". For example, <code><a href=".././Init/Prelude.html#Array.get!">Array.get!</a> arr i : α</code> returns
a value of type <code>α</code> when <code>arr : <a href=".././Init/Prelude.html#Array">Array</a> α</code>, but if <code>i</code> is not in range of
the array, it reports a panic message, but this does not halt the program,
so it must still return a value of type <code>α</code> (and in fact this is required
for logical consistency), so in this case it returns <code>default</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Inhabited" class="instances-list"></ul></details></div></div><div class="decl" id="Nonempty"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L666-L668">source</a></div><div class="decl_header"><span class="decl_kind">class inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nonempty">Nonempty</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Sort u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Prop</span></div></div><ul class="constructors"><li class="constructor" id="Nonempty.intro"><div class="inductive_ctor_doc"><p>If <code>val : α</code>, then <code>α</code> is nonempty.</p></div>intro: <span class="fn">∀ {<span class="fn">α</span> : <span class="fn">Sort u</span>}, <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span></span></span></li></ul><p><code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code> is a typeclass that says that <code>α</code> is not an empty type,
that is, there exists an element in the type. It differs from <code><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> α</code>
in that <code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code> is a <code>Prop</code>, which means that it does not actually carry
an element of <code>α</code>, only a proof that <em>there exists</em> such an element.
Given <code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code>, you can construct an element of <code>α</code> <em>nonconstructively</em>
using <code><a href=".././Init/Prelude.html#Classical.choice">Classical.choice</a></code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Nonempty" class="instances-list"></ul></details></div></div><div class="decl" id="Classical.choice"><div class="axiom"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L692-L692">source</a></div><div class="decl_header"><span class="decl_kind">axiom</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Classical.choice">Classical.choice</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span> → <span class="fn">α</span></span></div></div><p><strong>The axiom of choice</strong>. <code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code> is a proof that <code>α</code> has an element,
but the element itself is erased. The axiom <code><a href=".././Init/Prelude.html#Classical.choice">choice</a></code> supplies a particular
element of <code>α</code> given only this proof.</p><p>The textbook axiom of choice normally makes a family of choices all at once,
but that is implied from this formulation, because if <code>α : ι → Type</code> is a
family of types and <code>h : ∀ i, <a href=".././Init/Prelude.html#Nonempty">Nonempty</a> (α i)</code> is a proof that they are all
nonempty, then <code>fun i => <a href=".././Init/Prelude.html#Classical.choice">Classical.choice</a> (h i) : ∀ i, α i</code> is a family of
chosen elements. This is actually a bit stronger than the ZFC choice axiom;
this is sometimes called "<a href="https://en.wikipedia.org/wiki/Axiom_of_global_choice">global choice</a>".</p><p>In lean, we use the axiom of choice to derive the law of excluded middle
(see <code><a href=".././Init/Classical.html#Classical.em">Classical.em</a></code>), so it will often show up in axiom listings where you
may not expect. You can use <code>#print axioms my_thm</code> to find out if a given
theorem depends on this or other axioms.</p><p>This axiom can be used to construct "data", but obviously there is no algorithm
to compute it, so lean will require you to mark any definition that would
involve executing <code><a href=".././Init/Prelude.html#Classical.choice">Classical.choice</a></code> or other axioms as <code>noncomputable</code>, and
will not produce any executable code for such definitions.</p></div></div><div class="decl" id="Nonempty.elim"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L700-L702">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nonempty.elim">Nonempty.elim</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">Prop</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">α</span> → <span class="fn">p</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">p</span></div></div><p>The elimination principle for <code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code>. If <code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code>, and we can
prove <code>p</code> given any element <code>x : α</code>, then <code>p</code> holds. Note that it is essential
that <code>p</code> is a <code>Prop</code> here; the version with <code>p</code> being a <code>Sort u</code> is equivalent
to <code><a href=".././Init/Prelude.html#Classical.choice">Classical.choice</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Nonempty.elim">@<a href=".././Init/Prelude.html#Nonempty.elim">Nonempty.elim</a></a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Nonempty.elim.proof_1">@<a href=".././Init/Prelude.html#Nonempty.elim.proof_1">Nonempty.elim.proof_1</a></a></span></li></ul></details></div></div><div class="decl" id="instNonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L704-L705">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instNonempty">instNonempty</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instNonempty">@<a href=".././Init/Prelude.html#instNonempty">instNonempty</a></a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#instNonempty.proof_1">@<a href=".././Init/Prelude.html#instNonempty.proof_1">instNonempty.proof_1</a></a></span></li></ul></details></div></div><div class="decl" id="Classical.ofNonempty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L711-L712">source</a></div><div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Classical.ofNonempty">Classical.ofNonempty</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>A variation on <code><a href=".././Init/Prelude.html#Classical.choice">Classical.choice</a></code> that uses typeclass inference to
infer the proof of <code><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Classical.ofNonempty</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Classical.choice">Classical.choice</a> <span class="fn">(_ : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="instNonemptyForAll"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L714-L715">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instNonemptyForAll">instNonemptyForAll</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Sort u</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Sort v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instNonemptyForAll">instNonemptyForAll</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#instNonemptyForAll.proof_1">instNonemptyForAll.proof_1</a></span></li></ul></details></div></div><div class="decl" id="instNonemptyForAll_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L717-L718">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instNonemptyForAll_1">instNonemptyForAll_1</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Sort u</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <span class="fn">Sort v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">∀ (<span class="fn">a</span> : <span class="fn">α</span>), <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instNonemptyForAll_1">instNonemptyForAll_1</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#instNonemptyForAll_1.proof_1">instNonemptyForAll_1.proof_1</a></span></li></ul></details></div></div><div class="decl" id="instInhabitedSort"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L720-L721">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedSort">instInhabitedSort</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn">Sort u</span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instInhabitedSort">instInhabitedSort</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <a href=".././Init/Prelude.html#PUnit">PUnit</a> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedForAll"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L723-L724">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedForAll">instInhabitedForAll</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Sort u</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Sort v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instInhabitedForAll">instInhabitedForAll</a> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedForAll_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L726-L727">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedForAll_1">instInhabitedForAll_1</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Sort u</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn"><span class="fn">α</span> → <span class="fn">Sort v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><span class="fn">β</span> <span class="fn">a</span></span>)</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><span class="fn">β</span> <span class="fn">a</span></span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instInhabitedForAll_1">instInhabitedForAll_1</a> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedBool"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L729-L729">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedBool">instInhabitedBool</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instInhabitedBool">instInhabitedBool</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <a href=".././Init/Prelude.html#Bool.false">false</a> }</span></span></li></ul></details></div></div><div class="decl" id="PLift"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L732-L734">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#PLift">PLift</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Sort u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_ext"><li id="PLift.up" class="structure_ext_ctor">up :: (</li><ul class="structure_ext_fields"><li id="PLift.down" class="structure_field"><div class="structure_field_doc"><p>Extract a value from <code><a href=".././Init/Prelude.html#PLift">PLift</a> α</code></p></div><div class="structure_field_info">down : <span class="fn">α</span></div></li></ul><li class="structure_ext_ctor">)</li></ul><p>Universe lifting operation from <code>Sort u</code> to <code>Type u</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-PLift" class="instances-for-list"></ul></details></div></div><div class="decl" id="PLift.up_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L737-L737">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#PLift.up_down">PLift.up_down</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(b : <span class="fn"><a href=".././Init/Prelude.html#PLift">PLift</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">{ <span class="fn">down</span> := <span class="fn"><span class="fn">b</span>.down</span> }</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div><p>Bijection between <code>α</code> and <code><a href=".././Init/Prelude.html#PLift">PLift</a> α</code></p></div></div><div class="decl" id="PLift.down_up"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L740-L740">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#PLift.down_up">PLift.down_up</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">{ <span class="fn">down</span> := <span class="fn">a</span> }</span>.down</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div><p>Bijection between <code>α</code> and <code><a href=".././Init/Prelude.html#PLift">PLift</a> α</code></p></div></div><div class="decl" id="NonemptyType"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L748-L748">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#NonemptyType">NonemptyType</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (u + 1)</span></div></div><p><code>NonemptyType.{u}</code> is the type of nonempty types in universe <code>u</code>.
It is mainly used in constant declarations where we wish to introduce a type
and simultaneously assert that it is nonempty, but otherwise make the type
opaque.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#NonemptyType">NonemptyType</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">α</span> // <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="NonemptyType.type"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L751-L752">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#NonemptyType.type">NonemptyType.type</a></span><span class="decl_args">
<span class="fn">(type : <a href=".././Init/Prelude.html#NonemptyType">NonemptyType</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><p>The underlying type of a <code><a href=".././Init/Prelude.html#NonemptyType">NonemptyType</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#NonemptyType.type">NonemptyType.type</a> <span class="fn">type</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">type</span>.val</span></span></li></ul></details></div></div><div class="decl" id="instInhabitedNonemptyType"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L755-L756">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedNonemptyType">instInhabitedNonemptyType</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#NonemptyType">NonemptyType</a></span></div></div><p><code><a href=".././Init/Prelude.html#NonemptyType">NonemptyType</a></code> is inhabited, because <code><a href=".././Init/Prelude.html#PUnit">PUnit</a></code> is a nonempty type.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instInhabitedNonemptyType">instInhabitedNonemptyType</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">val</span> := <a href=".././Init/Prelude.html#PUnit">PUnit</a>, <span class="fn">property</span> := <span class="fn">(_ : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span>)</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="ULift"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L766-L768">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ULift">ULift</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type s</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max s r)</span></div></div><ul class="structure_ext"><li id="ULift.up" class="structure_ext_ctor">up :: (</li><ul class="structure_ext_fields"><li id="ULift.down" class="structure_field"><div class="structure_field_doc"><p>Extract a value from <code><a href=".././Init/Prelude.html#ULift">ULift</a> α</code></p></div><div class="structure_field_info">down : <span class="fn">α</span></div></li></ul><li class="structure_ext_ctor">)</li></ul><p>Universe lifting operation from a lower <code>Type</code> universe to a higher one.
To express this using level variables, the input is <code>Type s</code> and the output is
<code>Type (max s r)</code>, so if <code>s ≤ r</code> then the latter is (definitionally) <code>Type r</code>.</p><p>The universe variable <code>r</code> is written first so that <code>ULift.{r} α</code> can be used
when <code>s</code> can be inferred from the type of <code>α</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-ULift" class="instances-for-list"></ul></details></div></div><div class="decl" id="ULift.up_down"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L771-L771">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ULift.up_down">ULift.up_down</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(b : <span class="fn"><a href=".././Init/Prelude.html#ULift">ULift</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">{ <span class="fn">down</span> := <span class="fn"><span class="fn">b</span>.down</span> }</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span></div></div><p>Bijection between <code>α</code> and <code>ULift.{v} α</code></p></div></div><div class="decl" id="ULift.down_up"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L774-L774">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ULift.down_up">ULift.down_up</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">{ <span class="fn">down</span> := <span class="fn">a</span> }</span>.down</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></div></div><p>Bijection between <code>α</code> and <code>ULift.{v} α</code></p></div></div><div class="decl" id="Decidable"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L790-L794">source</a></div><div class="decl_header"><span class="decl_kind">class inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Decidable">Decidable</a></span><span class="decl_args">
<span class="fn">(p : <span class="fn">Prop</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="constructors"><li class="constructor" id="Decidable.isFalse"><div class="inductive_ctor_doc"><p>Prove that <code>p</code> is decidable by supplying a proof of <code>¬p</code></p></div>isFalse: <span class="fn">{<span class="fn">p</span> : <span class="fn">Prop</span>} → <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span></span></span></li><li class="constructor" id="Decidable.isTrue"><div class="inductive_ctor_doc"><p>Prove that <code>p</code> is decidable by supplying a proof of <code>p</code></p></div>isTrue: <span class="fn">{<span class="fn">p</span> : <span class="fn">Prop</span>} → <span class="fn"><span class="fn">p</span> → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span></span></span></li></ul><p><code><a href=".././Init/Prelude.html#Decidable">Decidable</a> p</code> is a data-carrying class that supplies a proof that <code>p</code> is
either <code>true</code> or <code>false</code>. It is equivalent to <code><a href=".././Init/Prelude.html#Bool">Bool</a></code> (and in fact it has the
same code generation as <code><a href=".././Init/Prelude.html#Bool">Bool</a></code>) together with a proof that the <code><a href=".././Init/Prelude.html#Bool">Bool</a></code> is
true iff <code>p</code> is.</p><p><code><a href=".././Init/Prelude.html#Decidable">Decidable</a></code> instances are used to infer "computation strategies" for
propositions, so that you can have the convenience of writing propositions
inside <code>if</code> statements and executing them (which actually executes the inferred
decidability instance instead of the proposition, which has no code).</p><p>If a proposition <code>p</code> is <code><a href=".././Init/Prelude.html#Decidable">Decidable</a></code>, then <code>(by <a href=".././Init/Prelude.html#Decidable.decide">decide</a> : p)</code> will prove it by
evaluating the decidability instance to <code>isTrue h</code> and returning <code>h</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Decidable" class="instances-list"></ul></details></div></div><div class="decl" id="Decidable.decide"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L802-L803">source</a></div><div class="attributes">@[inlineIfReduce]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Decidable.decide">Decidable.decide</a></span><span class="decl_args">
<span class="fn">(p : <span class="fn">Prop</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Convert a decidable proposition into a boolean value.</p><p>If <code>p : Prop</code> is decidable, then <code><a href=".././Init/Prelude.html#Decidable.decide">decide</a> p : <a href=".././Init/Prelude.html#Bool">Bool</a></code> is the boolean value
which is <code>true</code> if <code>p</code> is true and <code>false</code> if <code>p</code> is false.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">p</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.casesOn">Decidable.casesOn</a> <span class="fn">h</span> (<span class="fn">fun <span class="fn">x</span> =&gt <a href=".././Init/Prelude.html#Bool.false">false</a></span>) <span class="fn">fun <span class="fn">x</span> =&gt <a href=".././Init/Prelude.html#Bool.true">true</a></span></span></span></li></ul></details></div></div><div class="decl" id="DecidablePred"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L808-L809">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#DecidablePred">DecidablePred</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">Prop</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Sort (max 1 u)</span></div></div><p>A decidable predicate. See <code><a href=".././Init/Prelude.html#Decidable">Decidable</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#DecidablePred">DecidablePred</a> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn">(<span class="fn">a</span> : <span class="fn">α</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">r</span> <span class="fn">a</span></span>)</span></span>)</span></li></ul></details></div></div><div class="decl" id="DecidableRel"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L812-L813">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#DecidableRel">DecidableRel</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">Prop</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Sort (max 1 u)</span></div></div><p>A decidable relation. See <code><a href=".././Init/Prelude.html#Decidable">Decidable</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn">(<span class="fn">a </span>b : <span class="fn">α</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span>)</span></span>)</span></li></ul></details></div></div><div class="decl" id="DecidableEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L819-L820">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#DecidableEq">DecidableEq</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Sort u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Sort (max 1 u)</span></div></div><p>Asserts that <code>α</code> has decidable equality, that is, <code>a = b</code> is decidable
for all <code>a b : α</code>. See <code><a href=".././Init/Prelude.html#Decidable">Decidable</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn">(<span class="fn">a </span>b : <span class="fn">α</span>) → <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span>)</span></li></ul></details></div></div><div class="decl" id="decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L823-L824">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#decEq">decEq</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></div></div><p>Proves that <code>a = b</code> is decidable given <code><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> α</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#decEq">decEq</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">inst</span> <span class="fn">a</span> <span class="fn">b</span></span></span></li></ul></details></div></div><div class="decl" id="decide_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L827-L829">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#decide_eq_true">decide_eq_true</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">Prop</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">p</span> → <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">p</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="decide_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L831-L833">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#decide_eq_false">decide_eq_false</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">Prop</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">p</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></span></div></div></div></div><div class="decl" id="of_decide_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L835-L838">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#of_decide_eq_true">of_decide_eq_true</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">Prop</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">p</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span> → <span class="fn">p</span></span></div></div></div></div><div class="decl" id="of_decide_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L840-L843">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#of_decide_eq_false">of_decide_eq_false</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">Prop</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> <span class="fn">p</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span> → <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span></div></div></div></div><div class="decl" id="of_decide_eq_self_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L845-L848">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#of_decide_eq_self_eq_true">of_decide_eq_self_eq_true</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="instDecidableEqBool"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L850-L855">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqBool">instDecidableEqBool</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="BEq"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L865-L867">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#BEq">BEq</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="BEq.mk"><li id="BEq.beq" class="structure_field"><div class="structure_field_doc"><p>Boolean equality, notated as <code>a == b</code>.</p></div><div class="structure_field_info">beq : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></li></ul><p><code><a href=".././Init/Prelude.html#BEq">BEq</a> α</code> is a typeclass for supplying a boolean-valued equality relation on
<code>α</code>, notated as <code>a == b</code>. Unlike <code><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> α</code> (which uses <code>a = b</code>), this
is <code><a href=".././Init/Prelude.html#Bool">Bool</a></code> valued instead of <code>Prop</code> valued, and it also does not have any
axioms like being reflexive or agreeing with <code>=</code>. It is mainly intended for
programming applications. See <code><a href=".././Init/Core.html#LawfulBEq">LawfulBEq</a></code> for a version that requires that
<code>==</code> and <code>=</code> coincide.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-BEq" class="instances-list"></ul></details></div></div><div class="decl" id="instBEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L871-L872">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instBEq">instBEq</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instBEq</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">beq</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Decidable.decide">decide</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="dite"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L889-L890">source</a></div><div class="attributes">@[macroInline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#dite">dite</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn">Prop</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(t : <span class="fn"><span class="fn">c</span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">c</span></span> → <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>"Dependent" if-then-else, normally written via the notation <code>if h : c then t(h) else e(h)</code>,
is sugar for <code><a href=".././Init/Prelude.html#dite">dite</a> c (fun h => t(h)) (fun h => e(h))</code>, and it is the same as
<code>if c then t else e</code> except that <code>t</code> is allowed to depend on a proof <code>h : c</code>,
and <code>e</code> can depend on <code>h : ¬c</code>. (Both branches use the same name for the hypothesis,
even though it has different types in the two cases.)</p><p>We use this to be able to communicate the if-then-else condition to the branches.
For example, <code><a href=".././Init/Prelude.html#Array.get">Array.get</a> arr ⟨i, h⟩</code> expects a proof <code>h : i < arr.<a href=".././Init/Prelude.html#UInt8.size">size</a></code> in order to
avoid a bounds check, so you can write <code>if h : i < arr.<a href=".././Init/Prelude.html#UInt8.size">size</a> then arr.<a href=".././Init/Prelude.html#List.get">get</a> ⟨i, h⟩ else ...</code>
to avoid the bounds check inside the if branch. (Of course in this case we have only
lifted the check into an explicit <code>if</code>, but we could also use this proof multiple times
or derive <code>i < arr.<a href=".././Init/Prelude.html#UInt8.size">size</a></code> from some other proposition that we are checking in the <code>if</code>.)</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#dite">dite</a> <span class="fn">c</span> <span class="fn">t</span> <span class="fn">e</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.casesOn">Decidable.casesOn</a> <span class="fn">h</span> <span class="fn">e</span> <span class="fn">t</span></span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="if-then-else">if-then-else <a class="hover-link" href="#if-then-else">#</a></h1></div><div class="decl" id="ite"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L911-L912">source</a></div><div class="attributes">@[macroInline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ite">ite</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <span class="fn">Prop</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[h : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">c</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(t : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(e : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p><code>if c then t else e</code> is notation for <code><a href=".././Init/Prelude.html#ite">ite</a> c t e</code>, "if-then-else", which decides to
return <code>t</code> or <code>e</code> depending on whether <code>c</code> is true or false. The explicit argument
<code>c : Prop</code> does not have any actual computational content, but there is an additional
<code>[Decidable c]</code> argument synthesized by typeclass inference which actually
determines how to evaluate <code>c</code> to true or false.</p><p>Because lean uses a strict (call-by-value) evaluation strategy, the signature of this
function is problematic in that it would require <code>t</code> and <code>e</code> to be evaluated before
calling the <code><a href=".././Init/Prelude.html#ite">ite</a></code> function, which would cause both sides of the <code>if</code> to be evaluated.
Even if the result is discarded, this would be a big performance problem,
and is undesirable for users in any case. To resolve this, <code><a href=".././Init/Prelude.html#ite">ite</a></code> is marked as
<code>@[macroInline]</code>, which means that it is unfolded during code generation, and
the definition of the function uses <code>fun _ => t</code> and <code>fun _ => e</code> so this recovers
the expected "lazy" behavior of <code>if</code>: the <code>t</code> and <code>e</code> arguments delay evaluation
until <code>c</code> is known.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">(<span class="fn">if <span class="fn">c</span> then <span class="fn">t</span> else <span class="fn">e</span></span>) <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.casesOn">Decidable.casesOn</a> <span class="fn">h</span> (<span class="fn">fun <span class="fn">x</span> =&gt <span class="fn">e</span></span>) <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn">t</span></span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableAnd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L914-L921">source</a></div><div class="attributes">@[macroInline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableAnd">instDecidableAnd</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">Prop</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">Prop</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dp : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dq : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">p</span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn">q</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="instDecidableOr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L923-L932">source</a></div><div class="attributes">@[macroInline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableOr">instDecidableOr</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">Prop</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{q : <span class="fn">Prop</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dp : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dq : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">q</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">p</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableOr</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">dp</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isTrue</a> <span class="fn">hp</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><span class="fn">p</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></span>)</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">hp</span></span> =&gt
    <span class="fn">match <span class="fn">dq</span> with
    | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isTrue</a> <span class="fn">hq</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><span class="fn">p</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></span>)</span></span>
    | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">hq</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn">p</span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn">q</span></span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span></span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableNot"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L934-L937">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableNot">instDecidableNot</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn">Prop</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[dp : <span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn">p</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableNot</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">dp</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isTrue</a> <span class="fn">hp</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn">p</span></span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">hp</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isTrue</a> <span class="fn">hp</span></span></span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Boolean-operators">Boolean operators <a class="hover-link" href="#Boolean-operators">#</a></h1></div><div class="decl" id="cond"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L947-L950">source</a></div><div class="attributes">@[macroInline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#cond">cond</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p><code><a href=".././Init/Prelude.html#cond">cond</a> b x y</code> is the same as <code>if b then x else y</code>, but optimized for a
boolean condition. It can also be written as <code>bif b then x else y</code>.
This is <code>@[macroInline]</code> because <code>x</code> and <code>y</code> should not
be eagerly evaluated (see <code><a href=".././Init/Prelude.html#ite">ite</a></code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">(<span class="fn">bif <span class="fn">c</span> then <span class="fn">x</span> else <span class="fn">y</span></span>) <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">c</span> with
  | <a href=".././Init/Prelude.html#Bool.false">true</a> =&gt <span class="fn">x</span>
  | <a href=".././Init/Prelude.html#Bool.false">false</a> =&gt <a href=".././Init/Prelude.html#Bool.false">y</a></span></span></li></ul></details></div></div><div class="decl" id="or"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L958-L961">source</a></div><div class="attributes">@[macroInline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#or">or</a></span><span class="decl_args">
<span class="fn">(x : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(y : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p><code><a href=".././Init/Prelude.html#or">or</a> x y</code>, or <code>x || y</code>, is the boolean "or" operation (not to be confused
with <code><a href=".././Init/Prelude.html#Or">Or</a> : Prop → Prop → Prop</code>, which is the propositional connective).
It is <code>@[macroInline]</code> because it has C-like short-circuiting behavior:
if <code>x</code> is true then <code>y</code> is not evaluated.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">(<span class="fn"><span class="fn">x</span> <a href=".././Init/Prelude.html#or">||</a> <span class="fn">y</span></span>) <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x</span> with
  | <a href=".././Init/Prelude.html#Bool.false">true</a> =&gt <a href=".././Init/Prelude.html#Bool.true">true</a>
  | <a href=".././Init/Prelude.html#Bool.false">false</a> =&gt <a href=".././Init/Prelude.html#Bool.false">y</a></span></span></li></ul></details></div></div><div class="decl" id="and"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L969-L972">source</a></div><div class="attributes">@[macroInline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#and">and</a></span><span class="decl_args">
<span class="fn">(x : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args">
<span class="fn">(y : <a href=".././Init/Prelude.html#Bool">Bool</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p><code><a href=".././Init/Prelude.html#and">and</a> x y</code>, or <code>x && y</code>, is the boolean "and" operation (not to be confused
with <code><a href=".././Init/Prelude.html#And">And</a> : Prop → Prop → Prop</code>, which is the propositional connective).
It is <code>@[macroInline]</code> because it has C-like short-circuiting behavior:
if <code>x</code> is false then <code>y</code> is not evaluated.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">(<span class="fn"><span class="fn">x</span> <a href=".././Init/Prelude.html#and">&amp&amp</a> <span class="fn">y</span></span>) <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">x</span> with
  | <a href=".././Init/Prelude.html#Bool.true">false</a> =&gt <a href=".././Init/Prelude.html#Bool.false">false</a>
  | <a href=".././Init/Prelude.html#Bool.true">true</a> =&gt <a href=".././Init/Prelude.html#Bool.true">y</a></span></span></li></ul></details></div></div><div class="decl" id="not"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L978-L980">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#not">not</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Bool">Bool</a> → <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><p><code><a href=".././Init/Prelude.html#not">not</a> x</code>, or <code>!x</code>, is the boolean "not" operation (not to be confused
with <code><a href=".././Init/Prelude.html#Not">Not</a> : Prop → Prop</code>, which is the propositional connective).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#not">!</a><span class="fn">_fun_discr</span></span>) <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">_fun_discr</span> with
  | <a href=".././Init/Prelude.html#Bool.false">true</a> =&gt <a href=".././Init/Prelude.html#Bool.false">false</a>
  | <a href=".././Init/Prelude.html#Bool.false">false</a> =&gt <a href=".././Init/Prelude.html#Bool.false">true</a></span></span></li></ul></details></div></div><div class="decl" id="Nat"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1014-L1020">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat">Nat</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="constructors"><li class="constructor" id="Nat.zero"><div class="inductive_ctor_doc"><p><code><a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a></code>, normally written <code>0 : <a href=".././Init/Prelude.html#Nat">Nat</a></code>, is the smallest natural number.
This is one of the two constructors of <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>.</p></div>zero: <a href=".././Init/Prelude.html#Nat">Nat</a></li><li class="constructor" id="Nat.succ"><div class="inductive_ctor_doc"><p>The successor function on natural numbers, <code>succ n = n + 1</code>.
This is one of the two constructors of <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>.</p></div>succ: <span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></li></ul><p>The type of natural numbers, starting at zero. It is defined as an
inductive type freely generated by "zero is a natural number" and
"the successor of a natural number is a natural number".</p><p>You can prove a theorem <code>P n</code> about <code>n : <a href=".././Init/Prelude.html#Nat">Nat</a></code> by <code>induction n</code>, which will
expect a proof of the theorem for <code>P 0</code>, and a proof of <code>P (succ i)</code> assuming
a proof of <code>P i</code>. The same method also works to define functions by recursion
on natural numbers: induction and recursion are two expressions of the same
operation from lean's point of view.</p><pre><code>open <a href=".././Init/Prelude.html#Nat">Nat</a>
example (n : Nat) : n < succ n := by
  induction n with
  | zero =>
    show 0 < 1
    <a href=".././Init/Prelude.html#Decidable.decide">decide</a>
  | succ i ih => -- ih : i < succ i
    show succ i < succ (succ i)
    exact <a href=".././Init/Data/Nat/Basic.html#Nat.succ_lt_succ">Nat.succ_lt_succ</a> ih
</code></pre><p>This type is special-cased by both the kernel and the compiler:</p><ul>
<li>The type of expressions contains "<code><a href=".././Init/Prelude.html#Nat">Nat</a></code> literals" as a primitive constructor,
and the kernel knows how to reduce zero/succ expressions to nat literals.</li>
<li>If implemented naively, this type would represent a numeral <code>n</code> in unary as a
linked list with <code>n</code> links, which is horribly inefficient. Instead, the
runtime itself has a special representation for <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> which stores numbers up
to 2^63 directly and larger numbers use an arbitrary precision "bignum"
library (usually <a href="https://gmplib.org/">GMP</a>).</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Nat" class="instances-for-list"></ul></details></div></div><div class="decl" id="instInhabitedNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1022-L1023">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedNat">instInhabitedNat</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instInhabitedNat">instInhabitedNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a> }</span></span></li></ul></details></div></div><div class="decl" id="OfNat"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1037-L1042">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#OfNat">OfNat</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <span class="fn">Type u</span></span></div></div><ul class="structure_fields" id="OfNat.mk"><li id="OfNat.ofNat" class="structure_field"><div class="structure_field_doc"><p>The <code><a href=".././Init/Prelude.html#OfNat.ofNat">OfNat.ofNat</a></code> function is automatically inserted by the parser when
the user writes a numeric literal like <code>1 : α</code>. Implementations of this
typeclass can therefore customize the behavior of <code>n : α</code> based on <code>n</code> and
<code>α</code>.</p></div><div class="structure_field_info">ofNat : <span class="fn">α</span></div></li></ul><p>The class <code><a href=".././Init/Prelude.html#OfNat">OfNat</a> α n</code> powers the numeric literal parser. If you write
<code>37 : α</code>, lean will attempt to synthesize <code><a href=".././Init/Prelude.html#OfNat">OfNat</a> α 37</code>, and will generate
the term <code>(OfNat.<a href=".././Init/Prelude.html#Char.ofNat">ofNat</a> 37 : α)</code>.</p><p>There is a bit of infinite regress here since the desugaring apparently
still contains a literal <code>37</code> in it. The type of expressions contains a
primitive constructor for "raw natural number literals", which you can directly
access using the macro <code>nat_lit 37</code>. Raw number literals are always of type <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>.
So it would be more correct to say that lean looks for an instance of
<code><a href=".././Init/Prelude.html#OfNat">OfNat</a> α (nat_lit 37)</code>, and it generates the term <code>(OfNat.<a href=".././Init/Prelude.html#Char.ofNat">ofNat</a> (nat_lit 37) : α)</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-OfNat" class="instances-list"></ul></details></div></div><div class="decl" id="instOfNatNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1045-L1046">source</a></div><div class="attributes">@[defaultInstance 100]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instOfNatNat">instOfNatNat</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#OfNat">OfNat</a> <a href=".././Init/Prelude.html#Nat">Nat</a> <span class="fn">n</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instOfNatNat">instOfNatNat</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">ofNat</span> := <span class="fn">n</span> }</span></span></li></ul></details></div></div><div class="decl" id="LE"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1049-L1051">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#LE">LE</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="LE.mk"><li id="LE.le" class="structure_field"><div class="structure_field_doc"><p>The less-equal relation: <code>x ≤ y</code></p></div><div class="structure_field_info">le : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">Prop</span></span></div></li></ul><p><code><a href=".././Init/Prelude.html#LE">LE</a> α</code> is the typeclass which supports the notation <code>x ≤ y</code> where <code>x y : α</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-LE" class="instances-list"></ul></details></div></div><div class="decl" id="LT"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1054-L1056">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#LT">LT</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="LT.mk"><li id="LT.lt" class="structure_field"><div class="structure_field_doc"><p>The less-than relation: <code>x < y</code></p></div><div class="structure_field_info">lt : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">Prop</span></span></div></li></ul><p><code><a href=".././Init/Prelude.html#LT">LT</a> α</code> is the typeclass which supports the notation <code>x < y</code> where <code>x y : α</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-LT" class="instances-list"></ul></details></div></div><div class="decl" id="GE.ge"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1059-L1059">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#GE.ge">GE.ge</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Prop</span></div></div><p><code>a ≥ b</code> is an abbreviation for <code>b ≤ a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#GE.ge">≥</a> <span class="fn">b</span></span>) <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">a</span></span>)</span></li></ul></details></div></div><div class="decl" id="GT.gt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1061-L1061">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#GT.gt">GT.gt</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Prop</span></div></div><p><code>a > b</code> is an abbreviation for <code>b < a</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn">(<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#GT.gt">&gt</a> <span class="fn">b</span></span>) <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">a</span></span>)</span></li></ul></details></div></div><div class="decl" id="max"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1067-L1068">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#max">max</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">LT.lt</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p><code><a href=".././Init/Prelude.html#max">max</a> a b</code> is the maximum of <code>a</code> and <code>b</code>. It is defined simply as
<code>if b < a then a else b</code>, and works as long as <code><</code> is decidable.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#max">max</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">a</span></span> then <span class="fn">a</span> else <span class="fn">b</span></span></span></li></ul></details></div></div><div class="decl" id="min"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1074-L1075">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#min">min</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableRel">DecidableRel</a> <span class="fn">LE.le</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p><code><a href=".././Init/Prelude.html#min">min</a> a b</code> is the minimum of <code>a</code> and <code>b</code>. It is defined simply as
<code>if a ≤ b then a else b</code>, and works as long as <code>≤</code> is decidable.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#min">min</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></span> then <span class="fn">a</span> else <span class="fn">b</span></span></span></li></ul></details></div></div><div class="decl" id="Trans"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1086-L1088">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Trans">Trans</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Sort u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <span class="fn">Sort u_3</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">Sort u</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(s : <span class="fn"><span class="fn">β</span> → <span class="fn"><span class="fn">γ</span> → <span class="fn">Sort v</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">γ</span> → <span class="fn">Sort w</span></span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Sort (max (max (max (max (max (max 1 u) u_1) u_2) u_3) v) w)</span></div></div><ul class="structure_fields" id="Trans.mk"><li id="Trans.trans" class="structure_field"><div class="structure_field_doc"><p>Compose two proofs by transitivity, generalized over the relations involved.</p></div><div class="structure_field_info">trans : <span class="fn">{<span class="fn">a</span> : <span class="fn">α</span>} → <span class="fn">{<span class="fn">b</span> : <span class="fn">β</span>} → <span class="fn">{<span class="fn">c</span> : <span class="fn">γ</span>} → <span class="fn"><span class="fn"><span class="fn">r</span> <span class="fn">a</span> <span class="fn">b</span></span> → <span class="fn"><span class="fn"><span class="fn">s</span> <span class="fn">b</span> <span class="fn">c</span></span> → <span class="fn"><span class="fn">t</span> <span class="fn">a</span> <span class="fn">c</span></span></span></span></span></span></span></div></li></ul><p>Transitive chaining of proofs, used e.g. by <code><a href=".././Init/NotationExtra.html#calc">calc</a></code>.</p><p>It takes two relations <code>r</code> and <code>s</code> as "input", and produces an "output"
relation <code>t</code>, with the property that <code>r a b</code> and <code>s b c</code> implies <code>t a c</code>.
The <code><a href=".././Init/NotationExtra.html#calc">calc</a></code> tactic uses this so that when it sees a chain with <code>a ≤ b</code> and <code>b < c</code>
it knows that this should be a proof of <code>a < c</code> because there is an instance
<code><a href=".././Init/Prelude.html#Trans">Trans</a> (·≤·) (·<·) (·<·)</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Trans" class="instances-list"></ul></details></div></div><div class="decl" id="instTransEq"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1092-L1093">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instTransEq">instTransEq</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{γ : <span class="fn">Sort u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">γ</span> → <span class="fn">Sort u</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Trans">Trans</a> <span class="fn">Eq</span> <span class="fn">r</span> <span class="fn">r</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instTransEq">instTransEq</a> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">trans</span> := <span class="fn">fun {<span class="fn">a </span>b} {<span class="fn">c</span>} <span class="fn">heq</span> <span class="fn">h'</span> =&gt <span class="fn"><span class="fn">(_ : <span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span>)</span> ▸ <span class="fn">h'</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instTransEq_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1095-L1096">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instTransEq_1">instTransEq_1</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Sort u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(r : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">Sort u</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Trans">Trans</a> <span class="fn">r</span> <span class="fn">Eq</span> <span class="fn">r</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instTransEq_1">instTransEq_1</a> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">trans</span> := <span class="fn">fun {<span class="fn">a</span>} {<span class="fn">b </span>c} <span class="fn">h'</span> <span class="fn">heq</span> =&gt <span class="fn"><span class="fn">heq</span> ▸ <span class="fn">h'</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="HAdd"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1102-L1105">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HAdd">HAdd</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type v</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type w</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u v) w)</span></div></div><ul class="structure_fields" id="HAdd.mk"><li id="HAdd.hAdd" class="structure_field"><div class="structure_field_doc"><p><code>a + b</code> computes the sum of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p></div><div class="structure_field_info">hAdd : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div></li></ul><p>The notation typeclass for heterogeneous addition.
This enables the notation <code>a + b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-HAdd" class="instances-list"></ul></details></div></div><div class="decl" id="HSub"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1111-L1115">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HSub">HSub</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type v</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type w</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u v) w)</span></div></div><ul class="structure_fields" id="HSub.mk"><li id="HSub.hSub" class="structure_field"><div class="structure_field_doc"><p><code>a - b</code> computes the difference of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p><ul>
<li>For natural numbers, this operator saturates at 0: <code>a - b = 0</code> when <code>a ≤ b</code>.</li>
</ul></div><div class="structure_field_info">hSub : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div></li></ul><p>The notation typeclass for heterogeneous subtraction.
This enables the notation <code>a - b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-HSub" class="instances-list"></ul></details></div></div><div class="decl" id="HMul"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1121-L1124">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HMul">HMul</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type v</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type w</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u v) w)</span></div></div><ul class="structure_fields" id="HMul.mk"><li id="HMul.hMul" class="structure_field"><div class="structure_field_doc"><p><code>a * b</code> computes the product of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p></div><div class="structure_field_info">hMul : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div></li></ul><p>The notation typeclass for heterogeneous multiplication.
This enables the notation <code>a * b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-HMul" class="instances-list"></ul></details></div></div><div class="decl" id="HDiv"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1130-L1137">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HDiv">HDiv</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type v</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type w</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u v) w)</span></div></div><ul class="structure_fields" id="HDiv.mk"><li id="HDiv.hDiv" class="structure_field"><div class="structure_field_doc"><p><code>a / b</code> computes the result of dividing <code>a</code> by <code>b</code>.
The meaning of this notation is type-dependent.</p><ul>
<li>For most types like <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>, <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code>, <code>Rat</code>, <code>Real</code>, <code>a / 0</code> is defined to be <code>0</code>.</li>
<li>For <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> and <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code>, <code>a / b</code> rounds toward 0.</li>
<li>For <code><a href=".././Init/Data/Float.html#Float">Float</a></code>, <code>a / 0</code> follows the IEEE 754 semantics for division,
usually resulting in <code>inf</code> or <code>nan</code>.</li>
</ul></div><div class="structure_field_info">hDiv : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div></li></ul><p>The notation typeclass for heterogeneous division.
This enables the notation <code>a / b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-HDiv" class="instances-list"></ul></details></div></div><div class="decl" id="HMod"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1143-L1147">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HMod">HMod</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type v</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type w</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u v) w)</span></div></div><ul class="structure_fields" id="HMod.mk"><li id="HMod.hMod" class="structure_field"><div class="structure_field_doc"><p><code>a % b</code> computes the remainder upon dividing <code>a</code> by <code>b</code>.
The meaning of this notation is type-dependent.</p><ul>
<li>For <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> and <code><a href=".././Init/Data/Int/Basic.html#Int">Int</a></code>, <code>a % 0</code> is defined to be <code>a</code>.</li>
</ul></div><div class="structure_field_info">hMod : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div></li></ul><p>The notation typeclass for heterogeneous modulo / remainder.
This enables the notation <code>a % b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-HMod" class="instances-list"></ul></details></div></div><div class="decl" id="HPow"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1153-L1156">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HPow">HPow</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type v</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type w</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u v) w)</span></div></div><ul class="structure_fields" id="HPow.mk"><li id="HPow.hPow" class="structure_field"><div class="structure_field_doc"><p><code>a ^ b</code> computes <code>a</code> to the power of <code>b</code>.
The meaning of this notation is type-dependent.</p></div><div class="structure_field_info">hPow : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div></li></ul><p>The notation typeclass for heterogeneous exponentiation.
This enables the notation <code>a ^ b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-HPow" class="instances-list"></ul></details></div></div><div class="decl" id="HAppend"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1162-L1165">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HAppend">HAppend</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type v</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type w</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u v) w)</span></div></div><ul class="structure_fields" id="HAppend.mk"><li id="HAppend.hAppend" class="structure_field"><div class="structure_field_doc"><p><code>a ++ b</code> is the result of concatenation of <code>a</code> and <code>b</code>, usually read "append".
The meaning of this notation is type-dependent.</p></div><div class="structure_field_info">hAppend : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div></li></ul><p>The notation typeclass for heterogeneous append.
This enables the notation <code>a ++ b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-HAppend" class="instances-list"></ul></details></div></div><div class="decl" id="HOrElse"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1172-L1177">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HOrElse">HOrElse</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type v</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type w</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u v) w)</span></div></div><ul class="structure_fields" id="HOrElse.mk"><li id="HOrElse.hOrElse" class="structure_field"><div class="structure_field_doc"><p><code>a <|> b</code> executes <code>a</code> and returns the result, unless it fails in which
case it executes and returns <code>b</code>. Because <code>b</code> is not always executed, it
is passed as a thunk so it can be forced only when needed.
The meaning of this notation is type-dependent.</p></div><div class="structure_field_info">hOrElse : <span class="fn"><span class="fn">α</span> → <span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">β</span></span>) → <span class="fn">γ</span></span></span></div></li></ul><p>The typeclass behind the notation <code>a <|> b : γ</code> where <code>a : α</code>, <code>b : β</code>.
Because <code>b</code> is "lazy" in this notation, it is passed as <code><a href=".././Init/Prelude.html#Unit">Unit</a> → β</code> to the
implementation so it can decide when to evaluate it.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-HOrElse" class="instances-list"></ul></details></div></div><div class="decl" id="HAndThen"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1184-L1189">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HAndThen">HAndThen</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type v</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type w</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u v) w)</span></div></div><ul class="structure_fields" id="HAndThen.mk"><li id="HAndThen.hAndThen" class="structure_field"><div class="structure_field_doc"><p><code>a >> b</code> executes <code>a</code>, ignores the result, and then executes <code>b</code>.
If <code>a</code> fails then <code>b</code> is not executed. Because <code>b</code> is not always executed, it
is passed as a thunk so it can be forced only when needed.
The meaning of this notation is type-dependent.</p></div><div class="structure_field_info">hAndThen : <span class="fn"><span class="fn">α</span> → <span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">β</span></span>) → <span class="fn">γ</span></span></span></div></li></ul><p>The typeclass behind the notation <code>a >> b : γ</code> where <code>a : α</code>, <code>b : β</code>.
Because <code>b</code> is "lazy" in this notation, it is passed as <code><a href=".././Init/Prelude.html#Unit">Unit</a> → β</code> to the
implementation so it can decide when to evaluate it.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-HAndThen" class="instances-list"></ul></details></div></div><div class="decl" id="HAnd"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1192-L1195">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HAnd">HAnd</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type v</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type w</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u v) w)</span></div></div><ul class="structure_fields" id="HAnd.mk"><li id="HAnd.hAnd" class="structure_field"><div class="structure_field_doc"><p><code>a &&& b</code> computes the bitwise AND of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p></div><div class="structure_field_info">hAnd : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div></li></ul><p>The typeclass behind the notation <code>a &&& b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-HAnd" class="instances-list"></ul></details></div></div><div class="decl" id="HXor"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1198-L1201">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HXor">HXor</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type v</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type w</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u v) w)</span></div></div><ul class="structure_fields" id="HXor.mk"><li id="HXor.hXor" class="structure_field"><div class="structure_field_doc"><p><code>a ^^^ b</code> computes the bitwise XOR of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p></div><div class="structure_field_info">hXor : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div></li></ul><p>The typeclass behind the notation <code>a ^^^ b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-HXor" class="instances-list"></ul></details></div></div><div class="decl" id="HOr"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1204-L1207">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HOr">HOr</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type v</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type w</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u v) w)</span></div></div><ul class="structure_fields" id="HOr.mk"><li id="HOr.hOr" class="structure_field"><div class="structure_field_doc"><p><code>a ||| b</code> computes the bitwise OR of <code>a</code> and <code>b</code>.
The meaning of this notation is type-dependent.</p></div><div class="structure_field_info">hOr : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div></li></ul><p>The typeclass behind the notation <code>a ||| b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-HOr" class="instances-list"></ul></details></div></div><div class="decl" id="HShiftLeft"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1210-L1216">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HShiftLeft">HShiftLeft</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type v</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type w</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u v) w)</span></div></div><ul class="structure_fields" id="HShiftLeft.mk"><li id="HShiftLeft.hShiftLeft" class="structure_field"><div class="structure_field_doc"><p><code>a <<< b</code> computes <code>a</code> shifted to the left by <code>b</code> places.
The meaning of this notation is type-dependent.</p><ul>
<li>On <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>, this is equivalent to <code>a * 2 ^ b</code>.</li>
<li>On <code><a href=".././Init/Prelude.html#UInt8">UInt8</a></code> and other fixed width unsigned types, this is the same but
truncated to the bit width.</li>
</ul></div><div class="structure_field_info">hShiftLeft : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div></li></ul><p>The typeclass behind the notation <code>a <<< b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-HShiftLeft" class="instances-list"></ul></details></div></div><div class="decl" id="HShiftRight"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1219-L1224">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#HShiftRight">HShiftRight</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type v</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type w</span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u v) w)</span></div></div><ul class="structure_fields" id="HShiftRight.mk"><li id="HShiftRight.hShiftRight" class="structure_field"><div class="structure_field_doc"><p><code>a >>> b</code> computes <code>a</code> shifted to the right by <code>b</code> places.
The meaning of this notation is type-dependent.</p><ul>
<li>On <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> and fixed width unsigned types like <code><a href=".././Init/Prelude.html#UInt8">UInt8</a></code>,
this is equivalent to <code>a / 2 ^ b</code>.</li>
</ul></div><div class="structure_field_info">hShiftRight : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">γ</span></span></span></div></li></ul><p>The typeclass behind the notation <code>a >>> b : γ</code> where <code>a : α</code>, <code>b : β</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-HShiftRight" class="instances-list"></ul></details></div></div><div class="decl" id="Add"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1227-L1229">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Add">Add</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="Add.mk"><li id="Add.add" class="structure_field"><div class="structure_field_doc"><p><code>a + b</code> computes the sum of <code>a</code> and <code>b</code>. See <code><a href=".././Init/Prelude.html#HAdd">HAdd</a></code>.</p></div><div class="structure_field_info">add : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div></li></ul><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HAdd">HAdd</a></code>: <code>a + b : α</code> where <code>a b : α</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Add" class="instances-list"></ul></details></div></div><div class="decl" id="Sub"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1232-L1234">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Sub">Sub</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="Sub.mk"><li id="Sub.sub" class="structure_field"><div class="structure_field_doc"><p><code>a - b</code> computes the difference of <code>a</code> and <code>b</code>. See <code><a href=".././Init/Prelude.html#HSub">HSub</a></code>.</p></div><div class="structure_field_info">sub : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div></li></ul><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HSub">HSub</a></code>: <code>a - b : α</code> where <code>a b : α</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Sub" class="instances-list"></ul></details></div></div><div class="decl" id="Mul"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1237-L1239">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Mul">Mul</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="Mul.mk"><li id="Mul.mul" class="structure_field"><div class="structure_field_doc"><p><code>a * b</code> computes the product of <code>a</code> and <code>b</code>. See <code><a href=".././Init/Prelude.html#HMul">HMul</a></code>.</p></div><div class="structure_field_info">mul : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div></li></ul><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HMul">HMul</a></code>: <code>a * b : α</code> where <code>a b : α</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Mul" class="instances-list"></ul></details></div></div><div class="decl" id="Neg"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1245-L1248">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Neg">Neg</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="Neg.mk"><li id="Neg.neg" class="structure_field"><div class="structure_field_doc"><p><code>-a</code> computes the negative or opposite of <code>a</code>.
The meaning of this notation is type-dependent.</p></div><div class="structure_field_info">neg : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></div></li></ul><p>The notation typeclass for negation.
This enables the notation <code>-a : α</code> where <code>a : α</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Neg" class="instances-list"></ul></details></div></div><div class="decl" id="Div"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1251-L1253">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Div">Div</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="Div.mk"><li id="Div.div" class="structure_field"><div class="structure_field_doc"><p><code>a / b</code> computes the result of dividing <code>a</code> by <code>b</code>. See <code><a href=".././Init/Prelude.html#HDiv">HDiv</a></code>.</p></div><div class="structure_field_info">div : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div></li></ul><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HDiv">HDiv</a></code>: <code>a / b : α</code> where <code>a b : α</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Div" class="instances-list"></ul></details></div></div><div class="decl" id="Mod"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1256-L1258">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Mod">Mod</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="Mod.mk"><li id="Mod.mod" class="structure_field"><div class="structure_field_doc"><p><code>a % b</code> computes the remainder upon dividing <code>a</code> by <code>b</code>. See <code><a href=".././Init/Prelude.html#HMod">HMod</a></code>.</p></div><div class="structure_field_info">mod : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div></li></ul><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HMod">HMod</a></code>: <code>a % b : α</code> where <code>a b : α</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Mod" class="instances-list"></ul></details></div></div><div class="decl" id="Pow"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1265-L1267">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Pow">Pow</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(β : <span class="fn">Type v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max u v)</span></div></div><ul class="structure_fields" id="Pow.mk"><li id="Pow.pow" class="structure_field"><div class="structure_field_doc"><p><code>a ^ b</code> computes <code>a</code> to the power of <code>b</code>. See <code><a href=".././Init/Prelude.html#HPow">HPow</a></code>.</p></div><div class="structure_field_info">pow : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span></span></div></li></ul><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HPow">HPow</a></code>: <code>a ^ b : α</code> where <code>a : α</code>, <code>b : β</code>.
(The right argument is not the same as the left since we often want this even
in the homogeneous case.)</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Pow" class="instances-list"></ul></details></div></div><div class="decl" id="Append"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1270-L1272">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Append">Append</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="Append.mk"><li id="Append.append" class="structure_field"><div class="structure_field_doc"><p><code>a ++ b</code> is the result of concatenation of <code>a</code> and <code>b</code>. See <code><a href=".././Init/Prelude.html#HAppend">HAppend</a></code>.</p></div><div class="structure_field_info">append : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div></li></ul><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HAppend">HAppend</a></code>: <code>a ++ b : α</code> where <code>a b : α</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Append" class="instances-list"></ul></details></div></div><div class="decl" id="OrElse"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1279-L1281">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#OrElse">OrElse</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="OrElse.mk"><li id="OrElse.orElse" class="structure_field"><div class="structure_field_doc"><p>The implementation of <code>a <|> b : α</code>. See <code><a href=".././Init/Prelude.html#HOrElse">HOrElse</a></code>.</p></div><div class="structure_field_info">orElse : <span class="fn"><span class="fn">α</span> → <span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">α</span></span>) → <span class="fn">α</span></span></span></div></li></ul><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HOrElse">HOrElse</a></code>: <code>a <|> b : α</code> where <code>a b : α</code>.
Because <code>b</code> is "lazy" in this notation, it is passed as <code><a href=".././Init/Prelude.html#Unit">Unit</a> → α</code> to the
implementation so it can decide when to evaluate it.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-OrElse" class="instances-list"></ul></details></div></div><div class="decl" id="AndThen"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1288-L1290">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#AndThen">AndThen</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="AndThen.mk"><li id="AndThen.andThen" class="structure_field"><div class="structure_field_doc"><p>The implementation of <code>a >> b : α</code>. See <code><a href=".././Init/Prelude.html#HAndThen">HAndThen</a></code>.</p></div><div class="structure_field_info">andThen : <span class="fn"><span class="fn">α</span> → <span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">α</span></span>) → <span class="fn">α</span></span></span></div></li></ul><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HAndThen">HAndThen</a></code>: <code>a >> b : α</code> where <code>a b : α</code>.
Because <code>b</code> is "lazy" in this notation, it is passed as <code><a href=".././Init/Prelude.html#Unit">Unit</a> → α</code> to the
implementation so it can decide when to evaluate it.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-AndThen" class="instances-list"></ul></details></div></div><div class="decl" id="AndOp"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1296-L1298">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#AndOp">AndOp</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="AndOp.mk"><li id="AndOp.and" class="structure_field"><div class="structure_field_doc"><p>The implementation of <code>a &&& b : α</code>. See <code><a href=".././Init/Prelude.html#HAnd">HAnd</a></code>.</p></div><div class="structure_field_info">and : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div></li></ul><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HAnd">HAnd</a></code>: <code>a &&& b : α</code> where <code>a b : α</code>.
(It is called <code><a href=".././Init/Prelude.html#AndOp">AndOp</a></code> because <code><a href=".././Init/Prelude.html#And">And</a></code> is taken for the propositional connective.)</p><details class="instances"><summary>Instances</summary><ul id="instances-list-AndOp" class="instances-list"></ul></details></div></div><div class="decl" id="Xor"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1301-L1303">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Xor">Xor</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="Xor.mk"><li id="Xor.xor" class="structure_field"><div class="structure_field_doc"><p>The implementation of <code>a ^^^ b : α</code>. See <code><a href=".././Init/Prelude.html#HXor">HXor</a></code>.</p></div><div class="structure_field_info">xor : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div></li></ul><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HXor">HXor</a></code>: <code>a ^^^ b : α</code> where <code>a b : α</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Xor" class="instances-list"></ul></details></div></div><div class="decl" id="OrOp"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1309-L1311">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#OrOp">OrOp</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="OrOp.mk"><li id="OrOp.or" class="structure_field"><div class="structure_field_doc"><p>The implementation of <code>a ||| b : α</code>. See <code><a href=".././Init/Prelude.html#HOr">HOr</a></code>.</p></div><div class="structure_field_info">or : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div></li></ul><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HOr">HOr</a></code>: <code>a ||| b : α</code> where <code>a b : α</code>.
(It is called <code><a href=".././Init/Prelude.html#OrOp">OrOp</a></code> because <code><a href=".././Init/Prelude.html#Or">Or</a></code> is taken for the propositional connective.)</p><details class="instances"><summary>Instances</summary><ul id="instances-list-OrOp" class="instances-list"></ul></details></div></div><div class="decl" id="Complement"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1314-L1316">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Complement">Complement</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="Complement.mk"><li id="Complement.complement" class="structure_field"><div class="structure_field_doc"><p>The implementation of <code>~~~a : α</code>.</p></div><div class="structure_field_info">complement : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></div></li></ul><p>The typeclass behind the notation <code>~~~a : α</code> where <code>a : α</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Complement" class="instances-list"></ul></details></div></div><div class="decl" id="ShiftLeft"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1319-L1321">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ShiftLeft">ShiftLeft</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="ShiftLeft.mk"><li id="ShiftLeft.shiftLeft" class="structure_field"><div class="structure_field_doc"><p>The implementation of <code>a <<< b : α</code>. See <code><a href=".././Init/Prelude.html#HShiftLeft">HShiftLeft</a></code>.</p></div><div class="structure_field_info">shiftLeft : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div></li></ul><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HShiftLeft">HShiftLeft</a></code>: <code>a <<< b : α</code> where <code>a b : α</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-ShiftLeft" class="instances-list"></ul></details></div></div><div class="decl" id="ShiftRight"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1324-L1326">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ShiftRight">ShiftRight</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="ShiftRight.mk"><li id="ShiftRight.shiftRight" class="structure_field"><div class="structure_field_doc"><p>The implementation of <code>a >>> b : α</code>. See <code><a href=".././Init/Prelude.html#HShiftRight">HShiftRight</a></code>.</p></div><div class="structure_field_info">shiftRight : <span class="fn"><span class="fn">α</span> → <span class="fn">α</span> → <span class="fn">α</span></span></div></li></ul><p>The homogeneous version of <code><a href=".././Init/Prelude.html#HShiftRight">HShiftRight</a></code>: <code>a >>> b : α</code> where <code>a b : α</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-ShiftRight" class="instances-list"></ul></details></div></div><div class="decl" id="instHAdd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1329-L1330">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHAdd">instHAdd</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Add">Add</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HAdd">HAdd</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHAdd</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hAdd</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Add.add">Add.add</a> <span class="fn">a</span> <span class="fn">b</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instHSub"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1333-L1334">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHSub">instHSub</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Sub">Sub</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HSub">HSub</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHSub</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hSub</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Sub.sub">Sub.sub</a> <span class="fn">a</span> <span class="fn">b</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instHMul"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1337-L1338">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHMul">instHMul</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Mul">Mul</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HMul">HMul</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHMul</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hMul</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Mul.mul">Mul.mul</a> <span class="fn">a</span> <span class="fn">b</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instHDiv"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1341-L1342">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHDiv">instHDiv</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Div">Div</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HDiv">HDiv</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHDiv</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hDiv</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Div.div">Div.div</a> <span class="fn">a</span> <span class="fn">b</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instHMod"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1345-L1346">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHMod">instHMod</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Mod">Mod</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HMod">HMod</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHMod</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hMod</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Mod.mod">Mod.mod</a> <span class="fn">a</span> <span class="fn">b</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instHPow"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1349-L1350">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHPow">instHPow</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Type u_2</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Pow">Pow</a> <span class="fn">α</span> <span class="fn">β</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HPow">HPow</a> <span class="fn">α</span> <span class="fn">β</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHPow</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hPow</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Pow.pow">Pow.pow</a> <span class="fn">a</span> <span class="fn">b</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instHAppend"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1353-L1354">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHAppend">instHAppend</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Append">Append</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HAppend">HAppend</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHAppend</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hAppend</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Append.append">Append.append</a> <span class="fn">a</span> <span class="fn">b</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instHOrElse"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1357-L1358">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHOrElse">instHOrElse</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#OrElse">OrElse</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HOrElse">HOrElse</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHOrElse</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hOrElse</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#OrElse.orElse">OrElse.orElse</a> <span class="fn">a</span> <span class="fn">b</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instHAndThen"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1361-L1362">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHAndThen">instHAndThen</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#AndThen">AndThen</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HAndThen">HAndThen</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHAndThen</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hAndThen</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#AndThen.andThen">AndThen.andThen</a> <span class="fn">a</span> <span class="fn">b</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instHAnd"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1365-L1366">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHAnd">instHAnd</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#AndOp">AndOp</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HAnd">HAnd</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHAnd</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hAnd</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#AndOp.and">AndOp.and</a> <span class="fn">a</span> <span class="fn">b</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instHXor"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1369-L1370">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHXor">instHXor</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Xor">Xor</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HXor">HXor</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHXor</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hXor</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Xor.xor">Xor.xor</a> <span class="fn">a</span> <span class="fn">b</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instHOr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1373-L1374">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHOr">instHOr</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#OrOp">OrOp</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HOr">HOr</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHOr</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hOr</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#OrOp.or">OrOp.or</a> <span class="fn">a</span> <span class="fn">b</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instHShiftLeft"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1377-L1378">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHShiftLeft">instHShiftLeft</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#ShiftLeft">ShiftLeft</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HShiftLeft">HShiftLeft</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHShiftLeft</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hShiftLeft</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#ShiftLeft.shiftLeft">ShiftLeft.shiftLeft</a> <span class="fn">a</span> <span class="fn">b</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instHShiftRight"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1381-L1382">source</a></div><div class="attributes">@[defaultInstance 1000]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHShiftRight">instHShiftRight</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#ShiftRight">ShiftRight</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HShiftRight">HShiftRight</a> <span class="fn">α</span> <span class="fn">α</span> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHShiftRight</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hShiftRight</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#ShiftRight.shiftRight">ShiftRight.shiftRight</a> <span class="fn">a</span> <span class="fn">b</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Membership"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1394-L1396">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Membership">Membership</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type u</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(γ : <span class="fn">Type v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max u v)</span></div></div><ul class="structure_fields" id="Membership.mk"><li id="Membership.mem" class="structure_field"><div class="structure_field_doc"><p>The membership relation <code>a ∈ s : Prop</code> where <code>a : α</code>, <code>s : γ</code>.</p></div><div class="structure_field_info">mem : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">γ</span> → <span class="fn">Prop</span></span></span></div></li></ul><p>The typeclass behind the notation <code>a ∈ s : Prop</code> where <code>a : α</code>, <code>s : γ</code>.
Because <code>α</code> is an <code><a href=".././Init/Prelude.html#outParam">outParam</a></code>, the "container type" <code>γ</code> determines the type
of the elements of the container.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Membership" class="instances-list"></ul></details></div></div><div class="decl" id="Nat.add"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1407-L1409">source</a></div><div class="attributes">@[matchPattern, extern  lean_nat_add]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.add">Nat.add</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>Addition of natural numbers.</p><p>This definition is overridden in both the kernel and the compiler to efficiently
evaluate using the "bignum" representation (see <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>). The definition provided
here is the logical model (and it is soundness-critical that they coincide).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.add">Nat.add</a> <span class="fn">_fun_discr</span> <a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">_fun_discr</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.add">Nat.add</a> <span class="fn">_fun_discr</span> (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">b</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> (<span class="fn"><a href=".././Init/Prelude.html#Nat.add">Nat.add</a> <span class="fn">_fun_discr</span> <span class="fn">b</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="instAddNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1411-L1412">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instAddNat">instAddNat</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Add">Add</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instAddNat">instAddNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">add</span> := <a href=".././Init/Prelude.html#Nat.add">Nat.add</a> }</span></span></li></ul></details></div></div><div class="decl" id="Nat.mul"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1427-L1429">source</a></div><div class="attributes">@[extern  lean_nat_mul]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.mul">Nat.mul</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>Multiplication of natural numbers.</p><p>This definition is overridden in both the kernel and the compiler to efficiently
evaluate using the "bignum" representation (see <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>). The definition provided
here is the logical model (and it is soundness-critical that they coincide).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.mul">Nat.mul</a> <span class="fn">_fun_discr</span> <span class="fn">0</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.mul">Nat.mul</a> <span class="fn">_fun_discr</span> (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">b</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.add">Nat.add</a> (<span class="fn"><a href=".././Init/Prelude.html#Nat.mul">Nat.mul</a> <span class="fn">_fun_discr</span> <span class="fn">b</span></span>) <span class="fn">_fun_discr</span></span></span></li></ul></details></div></div><div class="decl" id="instMulNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1431-L1432">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMulNat">instMulNat</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Mul">Mul</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instMulNat">instMulNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">mul</span> := <a href=".././Init/Prelude.html#Nat.mul">Nat.mul</a> }</span></span></li></ul></details></div></div><div class="decl" id="Nat.pow"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1443-L1445">source</a></div><div class="attributes">@[extern  lean_nat_pow]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.pow">Nat.pow</a></span><span class="decl_args">
<span class="fn">(m : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>The power operation on natural numbers.</p><p>This definition is overridden in the compiler to efficiently
evaluate using the "bignum" representation (see <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>). The definition provided
here is the logical model.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.pow">Nat.pow</a> <span class="fn">m</span> <span class="fn">0</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">1</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.pow">Nat.pow</a> <span class="fn">m</span> (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.mul">Nat.mul</a> (<span class="fn"><a href=".././Init/Prelude.html#Nat.pow">Nat.pow</a> <span class="fn">m</span> <span class="fn">n</span></span>) <span class="fn">m</span></span></span></li></ul></details></div></div><div class="decl" id="instPowNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1447-L1448">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instPowNat">instPowNat</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Pow">Pow</a> <a href=".././Init/Prelude.html#Nat">Nat</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instPowNat">instPowNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">pow</span> := <a href=".././Init/Prelude.html#Nat.pow">Nat.pow</a> }</span></span></li></ul></details></div></div><div class="decl" id="Nat.beq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1459-L1463">source</a></div><div class="attributes">@[extern  lean_nat_dec_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.beq">Nat.beq</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><p>(Boolean) equality of natural numbers.</p><p>This definition is overridden in both the kernel and the compiler to efficiently
evaluate using the "bignum" representation (see <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>). The definition provided
here is the logical model (and it is soundness-critical that they coincide).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.beq">Nat.beq</a> <a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a> <a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.beq">Nat.beq</a> <a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a> (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.beq">Nat.beq</a> (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span>) <a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.beq">Nat.beq</a> (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span>) (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">m</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.beq">Nat.beq</a> <span class="fn">n</span> <span class="fn">m</span></span></span></li></ul></details></div></div><div class="decl" id="instBEqNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1465-L1466">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instBEqNat">instBEqNat</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instBEqNat">instBEqNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">beq</span> := <a href=".././Init/Prelude.html#Nat.beq">Nat.beq</a> }</span></span></li></ul></details></div></div><div class="decl" id="Nat.eq_of_beq_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1468-L1475">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.eq_of_beq_eq_true">Nat.eq_of_beq_eq_true</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.beq">Nat.beq</a> <span class="fn">n</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span> → <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span></span></div></div></div></div><div class="decl" id="Nat.ne_of_beq_eq_false"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1477-L1483">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.ne_of_beq_eq_false">Nat.ne_of_beq_eq_false</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.beq">Nat.beq</a> <span class="fn">n</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span> → <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span></span></span></div></div></div></div><div class="decl" id="Nat.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1493-L1496">source</a></div><div class="attributes">@[extern  lean_nat_dec_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.decEq">Nat.decEq</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(m : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span>)</span></div></div><p>A decision procedure for equality of natural numbers.</p><p>This definition is overridden in the compiler to efficiently
evaluate using the "bignum" representation (see <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>). The definition provided
here is the logical model.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.decEq">Nat.decEq</a> <span class="fn">n</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match h : <span class="fn"><a href=".././Init/Prelude.html#Nat.beq">Nat.beq</a> <span class="fn">n</span> <span class="fn">m</span></span> with
  | <a href=".././Init/Prelude.html#Bool.false">true</a> =&gt <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span>)</span></span>
  | <a href=".././Init/Prelude.html#Bool.false">false</a> =&gt <a href=".././Init/Prelude.html#Bool.false"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span></span>)</span></a></span></span></li></ul></details></div></div><div class="decl" id="instDecidableEqNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1498-L1498">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqNat">instDecidableEqNat</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instDecidableEqNat">instDecidableEqNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Nat.decEq">Nat.decEq</a></span></li></ul></details></div></div><div class="decl" id="Nat.ble"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1509-L1513">source</a></div><div class="attributes">@[extern  lean_nat_dec_le]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.ble">Nat.ble</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><p>The (Boolean) less-equal relation on natural numbers.</p><p>This definition is overridden in both the kernel and the compiler to efficiently
evaluate using the "bignum" representation (see <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>). The definition provided
here is the logical model (and it is soundness-critical that they coincide).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.ble">Nat.ble</a> <a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a> <a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.ble">Nat.ble</a> <a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a> (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.ble">Nat.ble</a> (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span>) <a href=".././Init/Prelude.html#Nat.zero">Nat.zero</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.ble">Nat.ble</a> (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span>) (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">m</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.ble">Nat.ble</a> <span class="fn">n</span> <span class="fn">m</span></span></span></li></ul></details></div></div><div class="decl" id="Nat.le"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1519-L1523">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le">Nat.le</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <span class="fn">Prop</span></span></div></div><ul class="constructors"><li class="constructor" id="Nat.le.refl"><div class="inductive_ctor_doc"><p>Less-equal is reflexive: <code>n ≤ n</code></p></div>refl: <span class="fn">∀ {<span class="fn">n</span> : <a href=".././Init/Prelude.html#Nat">Nat</a>}, <span class="fn"><a href=".././Init/Prelude.html#Nat.le">Nat.le</a> <span class="fn">n</span> <span class="fn">n</span></span></span></li><li class="constructor" id="Nat.le.step"><div class="inductive_ctor_doc"><p>If <code>n ≤ m</code>, then <code>n ≤ m + 1</code>.</p></div>step: <span class="fn">∀ {<span class="fn">n </span>m : <a href=".././Init/Prelude.html#Nat">Nat</a>}, <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.le">Nat.le</a> <span class="fn">n</span> <span class="fn">m</span></span> → <span class="fn"><a href=".././Init/Prelude.html#Nat.le">Nat.le</a> <span class="fn">n</span> (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">m</span></span>)</span></span></span></li></ul><p>An inductive definition of the less-equal relation on natural numbers,
characterized as the least relation <code>≤</code> such that <code>n ≤ n</code> and <code>n ≤ m → n ≤ m + 1</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Nat.le" class="instances-for-list"></ul></details></div></div><div class="decl" id="instLENat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1525-L1526">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLENat">instLENat</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instLENat">instLENat</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">le</span> := <a href=".././Init/Prelude.html#Nat.le">Nat.le</a> }</span></span></li></ul></details></div></div><div class="decl" id="Nat.lt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1529-L1530">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt">Nat.lt</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(m : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Prop</span></div></div><p>The strict less than relation on natural numbers is defined as <code>n < m := n + 1 ≤ m</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.lt">Nat.lt</a> <span class="fn">n</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.le">Nat.le</a> (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span>) <span class="fn">m</span></span></span></li></ul></details></div></div><div class="decl" id="instLTNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1532-L1533">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLTNat">instLTNat</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instLTNat">instLTNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">lt</span> := <a href=".././Init/Prelude.html#Nat.lt">Nat.lt</a> }</span></span></li></ul></details></div></div><div class="decl" id="Nat.not_succ_le_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1535-L1537">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.not_succ_le_zero">Nat.not_succ_le_zero</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">0</span></span> → <a href=".././Init/Prelude.html#False">False</a></span></div></div></div></div><div class="decl" id="Nat.not_lt_zero"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1539-L1540">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.not_lt_zero">Nat.not_lt_zero</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">0</span></span></span></div></div></div></div><div class="decl" id="Nat.zero_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1542-L1544">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.zero_le">Nat.zero_le</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">0</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span></span></div></div></div></div><div class="decl" id="Nat.succ_le_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1546-L1548">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.succ_le_succ">Nat.succ_le_succ</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">m</span></span></span></span></div></div></div></div><div class="decl" id="Nat.zero_lt_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1550-L1551">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.zero_lt_succ">Nat.zero_lt_succ</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span></span></div></div></div></div><div class="decl" id="Nat.le_step"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1553-L1554">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_step">Nat.le_step</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">m</span></span></span></div></div></div></div><div class="decl" id="Nat.le_trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1556-L1558">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_trans">Nat.le_trans</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span> → <span class="fn"><span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">k</span></span> → <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">k</span></span></span></span></div></div></div></div><div class="decl" id="Nat.lt_trans"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1560-L1561">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt_trans">Nat.lt_trans</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">m</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">k</span></span> → <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">k</span></span></span></div></div></div></div><div class="decl" id="Nat.le_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1563-L1564">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_succ">Nat.le_succ</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span></span></div></div></div></div><div class="decl" id="Nat.le_succ_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1566-L1567">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_succ_of_le">Nat.le_succ_of_le</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">m</span></span></span></div></div></div></div><div class="decl" id="Nat.le_refl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1569-L1570">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_refl">Nat.le_refl</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span></span></div></div></div></div><div class="decl" id="Nat.succ_pos"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1572-L1573">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.succ_pos">Nat.succ_pos</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">0</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span></span></div></div></div></div><div class="decl" id="Nat.pred"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1583-L1585">source</a></div><div class="attributes">@[extern  c inline "lean_nat_sub(#1, lean_box(1))"]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.pred">Nat.pred</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>The predecessor function on natural numbers.</p><p>This definition is overridden in the compiler to use <code>n - 1</code> instead.
The definition provided here is the logical model.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.pred">Nat.pred</a> <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">_fun_discr</span> with
  | <span class="fn">0</span> =&gt <span class="fn">0</span>
  | <span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">a</span></span> =&gt <span class="fn">a</span></span></span></li></ul></details></div></div><div class="decl" id="Nat.pred_le_pred"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1587-L1590">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.pred_le_pred">Nat.pred_le_pred</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.pred">Nat.pred</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.pred">Nat.pred</a> <span class="fn">m</span></span></span></span></div></div></div></div><div class="decl" id="Nat.le_of_succ_le_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1592-L1593">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_of_succ_le_succ">Nat.le_of_succ_le_succ</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">m</span></span></span> → <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span></span></div></div></div></div><div class="decl" id="Nat.le_of_lt_succ"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1595-L1596">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_of_lt_succ">Nat.le_of_lt_succ</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span></span> → <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span></span></span></div></div></div></div><div class="decl" id="Nat.eq_or_lt_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1598-L1606">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.eq_or_lt_of_le">Nat.eq_or_lt_of_le</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span> → <span class="fn"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">m</span></span></span></span></div></div></div></div><div class="decl" id="Nat.lt_or_ge"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1608-L1617">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt_or_ge">Nat.lt_or_ge</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(m : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#GE.ge">≥</a> <span class="fn">m</span></span></span></div></div></div></div><div class="decl" id="Nat.not_succ_le_self"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1619-L1621">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.not_succ_le_self">Nat.not_succ_le_self</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span></span></span></div></div></div></div><div class="decl" id="Nat.lt_irrefl"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1623-L1624">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt_irrefl">Nat.lt_irrefl</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">n</span></span></span></div></div></div></div><div class="decl" id="Nat.lt_of_le_of_lt"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1626-L1627">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt_of_le_of_lt">Nat.lt_of_le_of_lt</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{k : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">k</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">k</span></span></div></div></div></div><div class="decl" id="Nat.le_antisymm"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1629-L1632">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_antisymm">Nat.le_antisymm</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">n</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span></div></div></div></div><div class="decl" id="Nat.lt_of_le_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1634-L1637">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.lt_of_le_of_ne">Nat.lt_of_le_of_ne</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h₁ : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(h₂ : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">m</span></span></div></div></div></div><div class="decl" id="Nat.le_of_ble_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1639-L1642">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.le_of_ble_eq_true">Nat.le_of_ble_eq_true</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.ble">Nat.ble</a> <span class="fn">n</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span></div></div></div></div><div class="decl" id="Nat.ble_self_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1644-L1646">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.ble_self_eq_true">Nat.ble_self_eq_true</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.ble">Nat.ble</a> <span class="fn">n</span> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Nat.ble_succ_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1648-L1650">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.ble_succ_eq_true">Nat.ble_succ_eq_true</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.ble">Nat.ble</a> <span class="fn">n</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span> → <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.ble">Nat.ble</a> <span class="fn">n</span> (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">m</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></span></div></div></div></div><div class="decl" id="Nat.ble_eq_true_of_le"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1652-L1655">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.ble_eq_true_of_le">Nat.ble_eq_true_of_le</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.ble">Nat.ble</a> <span class="fn">n</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></div></div></div></div><div class="decl" id="Nat.not_le_of_not_ble_eq_true"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1657-L1658">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.not_le_of_not_ble_eq_true">Nat.not_le_of_not_ble_eq_true</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.ble">Nat.ble</a> <span class="fn">n</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span></span></div></div></div></div><div class="decl" id="Nat.decLe"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1661-L1662">source</a></div><div class="attributes">@[extern  lean_nat_dec_le]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.decLe">Nat.decLe</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(m : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.decLe">Nat.decLe</a> <span class="fn">n</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.ble">Nat.ble</a> <span class="fn">n</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span>)</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span></span>)</span></span></span></span></li></ul></details></div></div><div class="decl" id="Nat.decLt"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1665-L1666">source</a></div><div class="attributes">@[extern  lean_nat_dec_lt]</div>
<div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.decLt">Nat.decLt</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(m : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">m</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.decLt">Nat.decLt</a> <span class="fn">n</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.decLe">Nat.decLe</a> (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span>) <span class="fn">m</span></span></span></li></ul></details></div></div><div class="decl" id="Nat.sub"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1678-L1680">source</a></div><div class="attributes">@[extern  lean_nat_sub]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.sub">Nat.sub</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>(Truncated) subtraction of natural numbers. Because natural numbers are not
closed under subtraction, we define <code>m - n</code> to be <code>0</code> when <code>n < m</code>.</p><p>This definition is overridden in both the kernel and the compiler to efficiently
evaluate using the "bignum" representation (see <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>). The definition provided
here is the logical model (and it is soundness-critical that they coincide).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.sub">Nat.sub</a> <span class="fn">_fun_discr</span> <span class="fn">0</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">_fun_discr</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.sub">Nat.sub</a> <span class="fn">_fun_discr</span> (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">b</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.pred">Nat.pred</a> (<span class="fn"><a href=".././Init/Prelude.html#Nat.sub">Nat.sub</a> <span class="fn">_fun_discr</span> <span class="fn">b</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="instSubNat"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1682-L1683">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instSubNat">instSubNat</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Sub">Sub</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instSubNat">instSubNat</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">sub</span> := <a href=".././Init/Prelude.html#Nat.sub">Nat.sub</a> }</span></span></li></ul></details></div></div><div class="decl" id="System.Platform.getNumBits"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1693-L1694">source</a></div><div class="attributes">@[extern  lean_system_platform_nbits]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#System.Platform.getNumBits">System.Platform.getNumBits</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn">{ <span class="fn">n</span> // <span class="fn"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">32</span></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">64</span></span></span> }</span></span></div></div><p>Gets the word size of the platform. That is, whether the platform is 64 or 32 bits.</p><p>This function is opaque because we cannot guarantee at compile time that the target
will have the same size as the host, and also because we would like to avoid
typechecking being architecture-dependent. Nevertheless, lean only works on
64 and 32 bit systems so we can encode this as a fact available for proof purposes.</p></div></div><div class="decl" id="System.Platform.numBits"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1697-L1698">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#System.Platform.numBits">System.Platform.numBits</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>Gets the word size of the platform. That is, whether the platform is 64 or 32 bits.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#System.Platform.numBits">System.Platform.numBits</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#System.Platform.getNumBits">System.Platform.getNumBits</a> <a href=".././Init/Prelude.html#Unit.unit">()</a></span>).val</span></span></li></ul></details></div></div><div class="decl" id="System.Platform.numBits_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1700-L1701">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#System.Platform.numBits_eq">System.Platform.numBits_eq</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#System.Platform.numBits">System.Platform.numBits</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">32</span></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><a href=".././Init/Prelude.html#System.Platform.numBits">System.Platform.numBits</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">64</span></span></span></div></div></div></div><div class="decl" id="Fin"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1707-L1712">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Fin">Fin</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="Fin.mk"><li id="Fin.val" class="structure_field"><div class="structure_field_doc"><p>If <code>i : <a href=".././Init/Prelude.html#Fin">Fin</a> n</code>, then <code>i.val : ℕ</code> is the described number. It can also be
written as <code>i.1</code> or just <code>i</code> when the target type is known.</p></div><div class="structure_field_info">val : <a href=".././Init/Prelude.html#Nat">Nat</a></div></li><li id="Fin.isLt" class="structure_field"><div class="structure_field_doc"><p>If <code>i : <a href=".././Init/Prelude.html#Fin">Fin</a> n</code>, then <code>i.2</code> is a proof that <code>i.1 < n</code>.</p></div><div class="structure_field_info">isLt : <span class="fn"><span class="fn">val</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">n</span></span></div></li></ul><p><code><a href=".././Init/Prelude.html#Fin">Fin</a> n</code> is a natural number <code>i</code> with the constraint that <code>0 ≤ i < n</code>.
It is the "canonical type with <code>n</code> elements".</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Fin" class="instances-for-list"></ul></details></div></div><div class="decl" id="Fin.eq_of_val_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1714-L1715">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Fin.eq_of_val_eq">Fin.eq_of_val_eq</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">i</span>.val</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">j</span>.val</span></span> → <span class="fn"><span class="fn">i</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span></span></div></div></div></div><div class="decl" id="Fin.val_eq_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1717-L1718">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Fin.val_eq_of_eq">Fin.val_eq_of_eq</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">i</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">i</span>.val</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">j</span>.val</span></span></div></div></div></div><div class="decl" id="Fin.ne_of_val_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1720-L1721">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Fin.ne_of_val_ne">Fin.ne_of_val_ne</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{i : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{j : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn"><span class="fn">i</span>.val</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">j</span>.val</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">i</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span></span></div></div></div></div><div class="decl" id="instDecidableEqFin"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1723-L1727">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqFin">instDecidableEqFin</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instDecidableEqFin">instDecidableEqFin</a> <span class="fn">n</span> <span class="fn">i</span> <span class="fn">j</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href=".././Init/Prelude.html#decEq">decEq</a> <span class="fn"><span class="fn">i</span>.val</span> <span class="fn"><span class="fn">j</span>.val</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isTrue</a> <span class="fn">h</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><span class="fn">i</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span>)</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">h</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">i</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">j</span></span></span>)</span></span></span></span></li></ul></details></div></div><div class="decl" id="instLTFin"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1729-L1730">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLTFin">instLTFin</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> (<span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instLTFin</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">lt</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><span class="fn"><span class="fn">a</span>.val</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn">b</span>.val</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instLEFin"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1732-L1733">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLEFin">instLEFin</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> (<span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instLEFin</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">le</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><span class="fn"><span class="fn">a</span>.val</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">b</span>.val</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Fin.decLt"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1735-L1735">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Fin.decLt">Fin.decLt</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">b</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Fin.decLt">Fin.decLt</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.decLt">Nat.decLt</a> <span class="fn"><span class="fn">a</span>.val</span> <span class="fn"><span class="fn">b</span>.val</span></span></span></li></ul></details></div></div><div class="decl" id="Fin.decLe"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1736-L1736">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Fin.decLe">Fin.decLe</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <a href=".././Init/Prelude.html#Nat">Nat</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <span class="fn">n</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Fin.decLe">Fin.decLe</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.decLe">Nat.decLe</a> <span class="fn"><span class="fn">a</span>.val</span> <span class="fn"><span class="fn">b</span>.val</span></span></span></li></ul></details></div></div><div class="decl" id="UInt8.size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1739-L1739">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt8.size">UInt8.size</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>The size of type <code><a href=".././Init/Prelude.html#UInt8">UInt8</a></code>, that is, <code>2^8 = 256</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#UInt8.size">UInt8.size</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">256</span></span></li></ul></details></div></div><div class="decl" id="UInt8"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1745-L1748">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt8">UInt8</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="UInt8.mk"><li id="UInt8.val" class="structure_field"><div class="structure_field_doc"><p>Unpack a <code><a href=".././Init/Prelude.html#UInt8">UInt8</a></code> as a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> less than <code>2^8</code>.
This function is overridden with a native implementation.</p></div><div class="structure_field_info">val : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <a href=".././Init/Prelude.html#UInt8.size">UInt8.size</a></span></div></li></ul><p>The type of unsigned 8-bit integers. This type has special support in the
compiler to make it actually 8 bits rather than wrapping a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-UInt8" class="instances-for-list"></ul></details></div></div><div class="decl" id="UInt8.ofNatCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1758-L1759">source</a></div><div class="attributes">@[extern  lean_uint8_of_nat]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt8.ofNatCore">UInt8.ofNatCore</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <a href=".././Init/Prelude.html#UInt8.size">UInt8.size</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#UInt8">UInt8</a></div></div><p>Pack a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> less than <code>2^8</code> into a <code><a href=".././Init/Prelude.html#UInt8">UInt8</a></code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#UInt8.ofNatCore">UInt8.ofNatCore</a> <span class="fn">n</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span>, <span class="fn">isLt</span> := <span class="fn">h</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="UInt8.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1767-L1770">source</a></div><div class="attributes">@[extern  lean_uint8_dec_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt8.decEq">UInt8.decEq</a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#UInt8">UInt8</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#UInt8">UInt8</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></div></div><p>Decides equality on <code><a href=".././Init/Prelude.html#UInt8">UInt8</a></code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#UInt8.decEq">UInt8.decEq</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">a</span>, <span class="fn">b</span> with
  | <span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span>, <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span> =&gt
    <span class="fn">if h : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span></span>)</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span></span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span></span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableEqUInt8"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1772-L1772">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqUInt8">instDecidableEqUInt8</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#UInt8">UInt8</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instDecidableEqUInt8">instDecidableEqUInt8</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#UInt8.decEq">UInt8.decEq</a></span></li></ul></details></div></div><div class="decl" id="instInhabitedUInt8"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1774-L1775">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedUInt8">instInhabitedUInt8</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#UInt8">UInt8</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instInhabitedUInt8">instInhabitedUInt8</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#UInt8.ofNatCore">UInt8.ofNatCore</a> <span class="fn">0</span> <a href=".././Init/Prelude.html#instInhabitedUInt8.proof_1">instInhabitedUInt8.proof_1</a></span> }</span></span></li></ul></details></div></div><div class="decl" id="UInt16.size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1778-L1778">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt16.size">UInt16.size</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>The size of type <code><a href=".././Init/Prelude.html#UInt16">UInt16</a></code>, that is, <code>2^16 = 65536</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#UInt16.size">UInt16.size</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">65536</span></span></li></ul></details></div></div><div class="decl" id="UInt16"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1784-L1787">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt16">UInt16</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="UInt16.mk"><li id="UInt16.val" class="structure_field"><div class="structure_field_doc"><p>Unpack a <code><a href=".././Init/Prelude.html#UInt16">UInt16</a></code> as a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> less than <code>2^16</code>.
This function is overridden with a native implementation.</p></div><div class="structure_field_info">val : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <a href=".././Init/Prelude.html#UInt16.size">UInt16.size</a></span></div></li></ul><p>The type of unsigned 16-bit integers. This type has special support in the
compiler to make it actually 16 bits rather than wrapping a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-UInt16" class="instances-for-list"></ul></details></div></div><div class="decl" id="UInt16.ofNatCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1797-L1798">source</a></div><div class="attributes">@[extern  lean_uint16_of_nat]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt16.ofNatCore">UInt16.ofNatCore</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <a href=".././Init/Prelude.html#UInt16.size">UInt16.size</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#UInt16">UInt16</a></div></div><p>Pack a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> less than <code>2^16</code> into a <code><a href=".././Init/Prelude.html#UInt16">UInt16</a></code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#UInt16.ofNatCore">UInt16.ofNatCore</a> <span class="fn">n</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span>, <span class="fn">isLt</span> := <span class="fn">h</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="UInt16.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1806-L1809">source</a></div><div class="attributes">@[extern  lean_uint16_dec_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt16.decEq">UInt16.decEq</a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#UInt16">UInt16</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#UInt16">UInt16</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></div></div><p>Decides equality on <code><a href=".././Init/Prelude.html#UInt16">UInt16</a></code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#UInt16.decEq">UInt16.decEq</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">a</span>, <span class="fn">b</span> with
  | <span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span>, <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span> =&gt
    <span class="fn">if h : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span></span>)</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span></span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span></span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableEqUInt16"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1811-L1811">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqUInt16">instDecidableEqUInt16</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#UInt16">UInt16</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instDecidableEqUInt16">instDecidableEqUInt16</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#UInt16.decEq">UInt16.decEq</a></span></li></ul></details></div></div><div class="decl" id="instInhabitedUInt16"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1813-L1814">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedUInt16">instInhabitedUInt16</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#UInt16">UInt16</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instInhabitedUInt16">instInhabitedUInt16</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#UInt16.ofNatCore">UInt16.ofNatCore</a> <span class="fn">0</span> <a href=".././Init/Prelude.html#instInhabitedUInt16.proof_1">instInhabitedUInt16.proof_1</a></span> }</span></span></li></ul></details></div></div><div class="decl" id="UInt32.size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1817-L1817">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt32.size">UInt32.size</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>The size of type <code><a href=".././Init/Prelude.html#UInt32">UInt32</a></code>, that is, <code>2^32 = 4294967296</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#UInt32.size">UInt32.size</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">4294967296</span></span></li></ul></details></div></div><div class="decl" id="UInt32"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1823-L1826">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt32">UInt32</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="UInt32.mk"><li id="UInt32.val" class="structure_field"><div class="structure_field_doc"><p>Unpack a <code><a href=".././Init/Prelude.html#UInt32">UInt32</a></code> as a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> less than <code>2^32</code>.
This function is overridden with a native implementation.</p></div><div class="structure_field_info">val : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <a href=".././Init/Prelude.html#UInt32.size">UInt32.size</a></span></div></li></ul><p>The type of unsigned 32-bit integers. This type has special support in the
compiler to make it actually 32 bits rather than wrapping a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-UInt32" class="instances-for-list"></ul></details></div></div><div class="decl" id="UInt32.ofNatCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1836-L1837">source</a></div><div class="attributes">@[extern  lean_uint32_of_nat]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt32.ofNatCore">UInt32.ofNatCore</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <a href=".././Init/Prelude.html#UInt32.size">UInt32.size</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#UInt32">UInt32</a></div></div><p>Pack a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> less than <code>2^32</code> into a <code><a href=".././Init/Prelude.html#UInt32">UInt32</a></code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#UInt32.ofNatCore">UInt32.ofNatCore</a> <span class="fn">n</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span>, <span class="fn">isLt</span> := <span class="fn">h</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="UInt32.toNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1844-L1844">source</a></div><div class="attributes">@[extern  lean_uint32_to_nat]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt32.toNat">UInt32.toNat</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>Unpack a <code><a href=".././Init/Prelude.html#UInt32">UInt32</a></code> as a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#UInt32.toNat">UInt32.toNat</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><span class="fn">n</span>.val</span>.val</span></span></li></ul></details></div></div><div class="decl" id="UInt32.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1852-L1855">source</a></div><div class="attributes">@[extern  lean_uint32_dec_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt32.decEq">UInt32.decEq</a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></div></div><p>Decides equality on <code><a href=".././Init/Prelude.html#UInt32">UInt32</a></code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#UInt32.decEq">UInt32.decEq</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">a</span>, <span class="fn">b</span> with
  | <span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span>, <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span> =&gt
    <span class="fn">if h : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span></span>)</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span></span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span></span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableEqUInt32"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1857-L1857">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqUInt32">instDecidableEqUInt32</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#UInt32">UInt32</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instDecidableEqUInt32">instDecidableEqUInt32</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#UInt32.decEq">UInt32.decEq</a></span></li></ul></details></div></div><div class="decl" id="instInhabitedUInt32"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1859-L1860">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedUInt32">instInhabitedUInt32</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#UInt32">UInt32</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instInhabitedUInt32">instInhabitedUInt32</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#UInt32.ofNatCore">UInt32.ofNatCore</a> <span class="fn">0</span> <a href=".././Init/Prelude.html#instInhabitedUInt32.proof_1">instInhabitedUInt32.proof_1</a></span> }</span></span></li></ul></details></div></div><div class="decl" id="instLTUInt32"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1862-L1863">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLTUInt32">instLTUInt32</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <a href=".././Init/Prelude.html#UInt32">UInt32</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instLTUInt32">instLTUInt32</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">lt</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><span class="fn"><span class="fn">a</span>.val</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn">b</span>.val</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instLEUInt32"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1865-L1866">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLEUInt32">instLEUInt32</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <a href=".././Init/Prelude.html#UInt32">UInt32</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instLEUInt32">instLEUInt32</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">le</span> := <span class="fn">fun <span class="fn">a</span> <span class="fn">b</span> =&gt <span class="fn"><span class="fn"><span class="fn">a</span>.val</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">b</span>.val</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="UInt32.decLt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1874-L1876">source</a></div><div class="attributes">@[extern  lean_uint32_dec_lt]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt32.decLt">UInt32.decLt</a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">b</span></span>)</span></div></div><p>Decides less-equal on <code><a href=".././Init/Prelude.html#UInt32">UInt32</a></code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#UInt32.decLt">UInt32.decLt</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">a</span>, <span class="fn">b</span> with
  | <span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span>, <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> (<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">m</span></span>)</span>)</span></span></span></li></ul></details></div></div><div class="decl" id="UInt32.decLe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1884-L1886">source</a></div><div class="attributes">@[extern  lean_uint32_dec_le]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt32.decLe">UInt32.decLe</a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></span>)</span></div></div><p>Decides less-than on <code><a href=".././Init/Prelude.html#UInt32">UInt32</a></code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#UInt32.decLe">UInt32.decLe</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">a</span>, <span class="fn">b</span> with
  | <span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span>, <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> (<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">m</span></span>)</span>)</span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableLtUInt32InstLTUInt32"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1888-L1888">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableLtUInt32InstLTUInt32">instDecidableLtUInt32InstLTUInt32</a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">b</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instDecidableLtUInt32InstLTUInt32">instDecidableLtUInt32InstLTUInt32</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#UInt32.decLt">UInt32.decLt</a> <span class="fn">a</span> <span class="fn">b</span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableLeUInt32InstLEUInt32"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1889-L1889">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableLeUInt32InstLEUInt32">instDecidableLeUInt32InstLEUInt32</a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">b</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instDecidableLeUInt32InstLEUInt32">instDecidableLeUInt32InstLEUInt32</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#UInt32.decLe">UInt32.decLe</a> <span class="fn">a</span> <span class="fn">b</span></span></span></li></ul></details></div></div><div class="decl" id="UInt64.size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1892-L1892">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt64.size">UInt64.size</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>The size of type <code><a href=".././Init/Prelude.html#UInt64">UInt64</a></code>, that is, <code>2^64 = 18446744073709551616</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#UInt64.size">UInt64.size</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">18446744073709551616</span></span></li></ul></details></div></div><div class="decl" id="UInt64"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1897-L1900">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt64">UInt64</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="UInt64.mk"><li id="UInt64.val" class="structure_field"><div class="structure_field_doc"><p>Unpack a <code><a href=".././Init/Prelude.html#UInt64">UInt64</a></code> as a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> less than <code>2^64</code>.
This function is overridden with a native implementation.</p></div><div class="structure_field_info">val : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <a href=".././Init/Prelude.html#UInt64.size">UInt64.size</a></span></div></li></ul><p>The type of unsigned 64-bit integers. This type has special support in the
compiler to make it actually 64 bits rather than wrapping a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-UInt64" class="instances-for-list"></ul></details></div></div><div class="decl" id="UInt64.ofNatCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1910-L1911">source</a></div><div class="attributes">@[extern  lean_uint64_of_nat]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt64.ofNatCore">UInt64.ofNatCore</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <a href=".././Init/Prelude.html#UInt64.size">UInt64.size</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#UInt64">UInt64</a></div></div><p>Pack a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> less than <code>2^64</code> into a <code><a href=".././Init/Prelude.html#UInt64">UInt64</a></code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#UInt64.ofNatCore">UInt64.ofNatCore</a> <span class="fn">n</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span>, <span class="fn">isLt</span> := <span class="fn">h</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="UInt64.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1919-L1922">source</a></div><div class="attributes">@[extern  lean_uint64_dec_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt64.decEq">UInt64.decEq</a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#UInt64">UInt64</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#UInt64">UInt64</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></div></div><p>Decides equality on <code><a href=".././Init/Prelude.html#UInt64">UInt64</a></code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#UInt64.decEq">UInt64.decEq</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">a</span>, <span class="fn">b</span> with
  | <span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span>, <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span> =&gt
    <span class="fn">if h : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span></span>)</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span></span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span></span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableEqUInt64"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1924-L1924">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqUInt64">instDecidableEqUInt64</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#UInt64">UInt64</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instDecidableEqUInt64">instDecidableEqUInt64</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#UInt64.decEq">UInt64.decEq</a></span></li></ul></details></div></div><div class="decl" id="instInhabitedUInt64"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1926-L1927">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedUInt64">instInhabitedUInt64</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#UInt64">UInt64</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instInhabitedUInt64">instInhabitedUInt64</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#UInt64.ofNatCore">UInt64.ofNatCore</a> <span class="fn">0</span> <a href=".././Init/Prelude.html#instInhabitedUInt64.proof_1">instInhabitedUInt64.proof_1</a></span> }</span></span></li></ul></details></div></div><div class="decl" id="USize.size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1933-L1933">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#USize.size">USize.size</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>The size of type <code><a href=".././Init/Prelude.html#UInt16">UInt16</a></code>, that is, <code>2^System.Platform.<a href=".././Init/Prelude.html#System.Platform.numBits">numBits</a></code>, which may
be either <code>2^32</code> or <code>2^64</code> depending on the platform's architecture.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#USize.size">USize.size</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">2</span> <a href=".././Init/Prelude.html#HPow.hPow">^</a> <a href=".././Init/Prelude.html#System.Platform.numBits">System.Platform.numBits</a></span></span></li></ul></details></div></div><div class="decl" id="usize_size_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1935-L1939">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#usize_size_eq">usize_size_eq</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#USize.size">USize.size</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">4294967296</span></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><a href=".././Init/Prelude.html#USize.size">USize.size</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">18446744073709551616</span></span></span></div></div></div></div><div class="decl" id="USize"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1948-L1951">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#USize">USize</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="USize.mk"><li id="USize.val" class="structure_field"><div class="structure_field_doc"><p>Unpack a <code><a href=".././Init/Prelude.html#USize">USize</a></code> as a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> less than <code><a href=".././Init/Prelude.html#USize.size">USize.size</a></code>.
This function is overridden with a native implementation.</p></div><div class="structure_field_info">val : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> <a href=".././Init/Prelude.html#USize.size">USize.size</a></span></div></li></ul><p>A <code><a href=".././Init/Prelude.html#USize">USize</a></code> is an unsigned integer with the size of a word
for the platform's architecture.</p><p>For example, if running on a 32-bit machine, USize is equivalent to UInt32.
Or on a 64-bit machine, UInt64.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-USize" class="instances-for-list"></ul></details></div></div><div class="decl" id="USize.ofNatCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1961-L1963">source</a></div><div class="attributes">@[extern  lean_usize_of_nat]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#USize.ofNatCore">USize.ofNatCore</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <a href=".././Init/Prelude.html#USize.size">USize.size</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#USize">USize</a></div></div><p>Pack a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> less than <code><a href=".././Init/Prelude.html#USize.size">USize.size</a></code> into a <code><a href=".././Init/Prelude.html#USize">USize</a></code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#USize.ofNatCore">USize.ofNatCore</a> <span class="fn">n</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span>, <span class="fn">isLt</span> := <span class="fn">h</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="USize.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1971-L1974">source</a></div><div class="attributes">@[extern  lean_usize_dec_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#USize.decEq">USize.decEq</a></span><span class="decl_args">
<span class="fn">(a : <a href=".././Init/Prelude.html#USize">USize</a>)</span></span>
<span class="decl_args">
<span class="fn">(b : <a href=".././Init/Prelude.html#USize">USize</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></div></div><p>Decides equality on <code><a href=".././Init/Prelude.html#USize">USize</a></code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#USize.decEq">USize.decEq</a> <span class="fn">a</span> <span class="fn">b</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">a</span>, <span class="fn">b</span> with
  | <span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span>, <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span> =&gt
    <span class="fn">if h : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">m</span></span> then <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span></span>)</span></span> else <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span> }</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">m</span> }</span></span> → <a href=".././Init/Prelude.html#False">False</a></span>)</span></span></span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableEqUSize"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1976-L1976">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqUSize">instDecidableEqUSize</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#USize">USize</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instDecidableEqUSize">instDecidableEqUSize</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#USize.decEq">USize.decEq</a></span></li></ul></details></div></div><div class="decl" id="instInhabitedUSize"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1978-L1981">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedUSize">instInhabitedUSize</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#USize">USize</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instInhabitedUSize">instInhabitedUSize</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#USize.ofNatCore">USize.ofNatCore</a> <span class="fn">0</span> <a href=".././Init/Prelude.html#instInhabitedUSize.proof_1">instInhabitedUSize.proof_1</a></span> }</span></span></li></ul></details></div></div><div class="decl" id="USize.ofNat32"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L1989-L1995">source</a></div><div class="attributes">@[extern  lean_usize_of_nat]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#USize.ofNat32">USize.ofNat32</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">4294967296</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#USize">USize</a></div></div><p>Upcast a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> less than <code>2^32</code> to a <code><a href=".././Init/Prelude.html#USize">USize</a></code>.
This is lossless because <code><a href=".././Init/Prelude.html#USize.size">USize.size</a></code> is either <code>2^32</code> or <code>2^64</code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#USize.ofNat32">USize.ofNat32</a> <span class="fn">n</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span>, <span class="fn">isLt</span> := <span class="fn">(_ : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <a href=".././Init/Prelude.html#USize.size">USize.size</a></span>)</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="Nat.isValidChar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2001-L2002">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Nat.isValidChar">Nat.isValidChar</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Prop</span></div></div><p>A <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> denotes a valid unicode codepoint if it is less than <code>0x110000</code>, and
it is also not a "surrogate" character (the range <code>0xd800</code> to <code>0xdfff</code> inclusive).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.isValidChar">Nat.isValidChar</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">55296</span></span> <a href=".././Init/Prelude.html#Or">∨</a> <span class="fn"><span class="fn"><span class="fn">57343</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#And">∧</a> <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">1114112</span></span></span></span>)</span></li></ul></details></div></div><div class="decl" id="UInt32.isValidChar"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2008-L2009">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt32.isValidChar">UInt32.isValidChar</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#UInt32">UInt32</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Prop</span></div></div><p>A <code><a href=".././Init/Prelude.html#UInt32">UInt32</a></code> denotes a valid unicode codepoint if it is less than <code>0x110000</code>, and
it is also not a "surrogate" character (the range <code>0xd800</code> to <code>0xdfff</code> inclusive).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#UInt32.isValidChar">UInt32.isValidChar</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.isValidChar">Nat.isValidChar</a> (<span class="fn"><a href=".././Init/Prelude.html#UInt32.toNat">UInt32.toNat</a> <span class="fn">n</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="Char"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2013-L2017">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Char">Char</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="Char.mk"><li id="Char.val" class="structure_field"><div class="structure_field_doc"><p>The underlying unicode scalar value as a <code><a href=".././Init/Prelude.html#UInt32">UInt32</a></code>.</p></div><div class="structure_field_info">val : <a href=".././Init/Prelude.html#UInt32">UInt32</a></div></li><li id="Char.valid" class="structure_field"><div class="structure_field_doc"><p>The value must be a legal codepoint.</p></div><div class="structure_field_info">valid : <span class="fn"><a href=".././Init/Prelude.html#UInt32.isValidChar">UInt32.isValidChar</a> <span class="fn">val</span></span></div></li></ul><p>The <code><a href=".././Init/Prelude.html#Char">Char</a></code> Type represents an unicode scalar value.
See http://www.unicode.org/glossary/#unicode_scalar_value).</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Char" class="instances-for-list"></ul></details></div></div><div class="decl" id="Char.ofNatAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2029-L2030">source</a></div><div class="attributes">@[extern  lean_uint32_of_nat]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Char.ofNatAux">Char.ofNatAux</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#Nat.isValidChar">Nat.isValidChar</a> <span class="fn">n</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Char">Char</a></div></div><p>Pack a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> encoding a valid codepoint into a <code><a href=".././Init/Prelude.html#Char">Char</a></code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Char.ofNatAux">Char.ofNatAux</a> <span class="fn">n</span> <span class="fn">h</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">{ <span class="fn">val</span> := <span class="fn">{ <span class="fn">val</span> := <span class="fn">n</span>, <span class="fn">isLt</span> := <span class="fn">(_ : <span class="fn"><span class="fn">n</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <a href=".././Init/Prelude.html#UInt32.size">UInt32.size</a></span>)</span> }</span> }</span>, <span class="fn">valid</span> := <span class="fn">h</span> }</span></span></li></ul></details></div></div><div class="decl" id="Char.ofNat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2037-L2040">source</a></div><div class="attributes">@[matchPattern, noinline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Char.ofNat">Char.ofNat</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Char">Char</a></div></div><p>Convert a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> into a <code><a href=".././Init/Prelude.html#Char">Char</a></code>. If the <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> does not encode a valid unicode scalar value,
<code>'\0'</code> is returned instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Char.ofNat">Char.ofNat</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">if h : <span class="fn"><a href=".././Init/Prelude.html#Nat.isValidChar">Nat.isValidChar</a> <span class="fn">n</span></span> then <span class="fn"><a href=".././Init/Prelude.html#Char.ofNatAux">Char.ofNatAux</a> <span class="fn">n</span> <span class="fn">h</span></span>
  else <span class="fn">{ <span class="fn">val</span> := <span class="fn">{ <span class="fn">val</span> := <span class="fn">{ <span class="fn">val</span> := <span class="fn">0</span>, <span class="fn">isLt</span> := <a href=".././Init/Prelude.html#Char.ofNat.proof_1">Char.ofNat.proof_1</a> }</span> }</span>, <span class="fn">valid</span> := <a href=".././Init/Prelude.html#Char.ofNat.proof_2">Char.ofNat.proof_2</a> }</span></span></span></li></ul></details></div></div><div class="decl" id="Char.eq_of_val_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2042-L2043">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Char.eq_of_val_eq">Char.eq_of_val_eq</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././Init/Prelude.html#Char">Char</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href=".././Init/Prelude.html#Char">Char</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn"><span class="fn">c</span>.val</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">d</span>.val</span></span> → <span class="fn"><span class="fn">c</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></div></div></div></div><div class="decl" id="Char.val_eq_of_eq"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2045-L2046">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Char.val_eq_of_eq">Char.val_eq_of_eq</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././Init/Prelude.html#Char">Char</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href=".././Init/Prelude.html#Char">Char</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">c</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span> → <span class="fn"><span class="fn"><span class="fn">c</span>.val</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">d</span>.val</span></span></span></div></div></div></div><div class="decl" id="Char.ne_of_val_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2048-L2049">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Char.ne_of_val_ne">Char.ne_of_val_ne</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././Init/Prelude.html#Char">Char</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href=".././Init/Prelude.html#Char">Char</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn"><span class="fn">c</span>.val</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">d</span>.val</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">c</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span></div></div></div></div><div class="decl" id="Char.val_ne_of_ne"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2051-L2052">source</a></div><div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Char.val_ne_of_ne">Char.val_ne_of_ne</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{c : <a href=".././Init/Prelude.html#Char">Char</a>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{d : <a href=".././Init/Prelude.html#Char">Char</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(h : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">c</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn"><span class="fn">c</span>.val</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">d</span>.val</span></span></span></div></div></div></div><div class="decl" id="instDecidableEqChar"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2054-L2058">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqChar">instDecidableEqChar</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#Char">Char</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instDecidableEqChar">instDecidableEqChar</a> <span class="fn">c</span> <span class="fn">d</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href=".././Init/Prelude.html#decEq">decEq</a> <span class="fn"><span class="fn">c</span>.val</span> <span class="fn"><span class="fn">d</span>.val</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isTrue</a> <span class="fn">h</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><span class="fn">c</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span>)</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">h</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><a href=".././Init/Prelude.html#Not">¬</a><span class="fn"><span class="fn">c</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">d</span></span></span>)</span></span></span></span></li></ul></details></div></div><div class="decl" id="Char.utf8Size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2061-L2069">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Char.utf8Size">Char.utf8Size</a></span><span class="decl_args">
<span class="fn">(c : <a href=".././Init/Prelude.html#Char">Char</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#UInt32">UInt32</a></div></div><p>Returns the number of bytes required to encode this <code><a href=".././Init/Prelude.html#Char">Char</a></code> in UTF-8.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Option"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2099-L2103">source</a></div><div class="attributes">@[unbox]</div>
<div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Option">Option</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="constructors"><li class="constructor" id="Option.none"><div class="inductive_ctor_doc"><p>No value.</p></div>none: <span class="fn">{<span class="fn">α</span> : <span class="fn">Type u</span>} → <span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></li><li class="constructor" id="Option.some"><div class="inductive_ctor_doc"><p>Some value of type <code>α</code>.</p></div>some: <span class="fn">{<span class="fn">α</span> : <span class="fn">Type u</span>} → <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></span></span></li></ul><p><code><a href=".././Init/Prelude.html#Option">Option</a> α</code> is the type of values which are either <code>some a</code> for some <code>a : α</code>,
or <code>none</code>. In functional programming languages, this type is used to represent
the possibility of failure, or sometimes nullability.</p><p>For example, the function <code>HashMap.find? : HashMap α β → α → <a href=".././Init/Prelude.html#Option">Option</a> β</code> looks up
a specified key <code>a : α</code> inside the map. Because we do not know in advance
whether the key is actually in the map, the return type is <code><a href=".././Init/Prelude.html#Option">Option</a> β</code>, where
<code>none</code> means the value was not in the map, and <code>some b</code> means that the value
was found and <code>b</code> is the value retrieved.</p><p>To extract a value from an <code><a href=".././Init/Prelude.html#Option">Option</a> α</code>, we use pattern matching:</p><pre><code>def <a href=".././Init/Prelude.html#Option.map">map</a> (f : α → β) (x : <a href=".././Init/Prelude.html#Option">Option</a> α) : <a href=".././Init/Prelude.html#Option">Option</a> β :=
  match x with
  | some a => some (f a)
  | none => none
</code></pre><p>We can also use <code>if let</code> to pattern match on <code><a href=".././Init/Prelude.html#Option">Option</a></code> and get the value
in the branch:</p><pre><code>def <a href=".././Init/Prelude.html#Option.map">map</a> (f : α → β) (x : <a href=".././Init/Prelude.html#Option">Option</a> α) : <a href=".././Init/Prelude.html#Option">Option</a> β :=
  if let some a := x then
    some (f a)
  else
    none
</code></pre><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Option" class="instances-for-list"></ul></details></div></div><div class="decl" id="instInhabitedOption"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2109-L2110">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedOption">instInhabitedOption</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedOption</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">none</span> }</span></span></li></ul></details></div></div><div class="decl" id="Option.getD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2119-L2121">source</a></div><div class="attributes">@[macroInline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Option.getD">Option.getD</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn">α</span></span></span></div></div><p>Get with default. If <code>opt : <a href=".././Init/Prelude.html#Option">Option</a> α</code> and <code>dflt : α</code>, then <code>opt.<a href=".././Init/Prelude.html#Option.getD">getD</a> dflt</code>
returns <code>a</code> if <code>opt = some a</code> and <code>dflt</code> otherwise.</p><p>This function is <code>@[macroInline]</code>, so <code>dflt</code> will not be evaluated unless
<code>opt</code> turns out to be <code>none</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Option.getD">Option.getD</a> <span class="fn">_fun_discr</span> <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">_fun_discr</span>, <span class="fn">_fun_discr</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span>, <span class="fn">x_1</span> =&gt <span class="fn">x</span>
  | <span class="fn">none</span>, <span class="fn">e</span> =&gt <span class="fn">e</span></span></span></li></ul></details></div></div><div class="decl" id="Option.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2127-L2129">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Option.map">Option.map</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Type u_2</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span> → <span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <span class="fn">β</span></span></span></div></div><p>Map a function over an <code><a href=".././Init/Prelude.html#Option">Option</a></code> by applying the function to the contained
value if present.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Option.map">Option.map</a> <span class="fn">f</span> <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">_fun_discr</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">x</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> (<span class="fn"><span class="fn">f</span> <span class="fn">x</span></span>)</span>
  | <span class="fn">none</span> =&gt <span class="fn">none</span></span></span></li></ul></details></div></div><div class="decl" id="List"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2142-L2147">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List">List</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="constructors"><li class="constructor" id="List.nil"><div class="inductive_ctor_doc"><p><code>[]</code> is the empty list.</p></div>nil: <span class="fn">{<span class="fn">α</span> : <span class="fn">Type u</span>} → <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></span></li><li class="constructor" id="List.cons"><div class="inductive_ctor_doc"><p>If <code>a : α</code> and <code>l : <a href=".././Init/Prelude.html#List">List</a> α</code>, then <code>cons a l</code>, or <code>a :: l</code>, is the
list whose first element is <code>a</code> and with <code>l</code> as the rest of the list.</p></div>cons: <span class="fn">{<span class="fn">α</span> : <span class="fn">Type u</span>} → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></span></span></span></li></ul><p><code><a href=".././Init/Prelude.html#List">List</a> α</code> is the type of ordered lists with elements of type <code>α</code>.
It is implemented as a linked list.</p><p><code><a href=".././Init/Prelude.html#List">List</a> α</code> is isomorphic to <code><a href=".././Init/Prelude.html#Array">Array</a> α</code>, but they are useful for different things:</p><ul>
<li><code><a href=".././Init/Prelude.html#List">List</a> α</code> is easier for reasoning, and
<code><a href=".././Init/Prelude.html#Array">Array</a> α</code> is modeled as a wrapper around <code><a href=".././Init/Prelude.html#List">List</a> α</code></li>
<li><code><a href=".././Init/Prelude.html#List">List</a> α</code> works well as a persistent data structure, when many copies of the
tail are shared. When the value is not shared, <code><a href=".././Init/Prelude.html#Array">Array</a> α</code> will have better
performance because it can do destructive updates.</li>
</ul><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-List" class="instances-for-list"></ul></details></div></div><div class="decl" id="instInhabitedList"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2149-L2150">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedList">instInhabitedList</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedList</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">[]</span> }</span></span></li></ul></details></div></div><div class="decl" id="List.hasDecEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2153-L2163">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.hasDecEq">List.hasDecEq</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(b : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">b</span></span>)</span></div></div><p>Implements decidable equality for <code><a href=".././Init/Prelude.html#List">List</a> α</code>, assuming <code>α</code> has decidable equality.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.hasDecEq">List.hasDecEq</a> <span class="fn">[]</span> <span class="fn">[]</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isTrue">isTrue</a> <span class="fn">(_ : <span class="fn"><span class="fn">[]</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">[]</span></span>)</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.hasDecEq">List.hasDecEq</a> (<span class="fn"><span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">tail</span></span>) <span class="fn">[]</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn"><span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">tail</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">[]</span></span> → <span class="fn"><a href=".././Init/Prelude.html#List.noConfusionType">List.noConfusionType</a> <a href=".././Init/Prelude.html#False">False</a> (<span class="fn"><span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">tail</span></span>) <span class="fn">[]</span></span></span>)</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.hasDecEq">List.hasDecEq</a> <span class="fn">[]</span> (<span class="fn"><span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">tail</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Decidable.isFalse">isFalse</a> <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn">[]</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">tail</span></span></span> → <span class="fn"><a href=".././Init/Prelude.html#List.noConfusionType">List.noConfusionType</a> <a href=".././Init/Prelude.html#False">False</a> <span class="fn">[]</span> (<span class="fn"><span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">tail</span></span>)</span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="instDecidableEqList"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2165-L2165">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqList">instDecidableEqList</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> (<span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instDecidableEqList</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">List.hasDecEq</span></span></li></ul></details></div></div><div class="decl" id="List.foldl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2172-L2174">source</a></div><div class="attributes">@[specialize #[]]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.foldl">List.foldl</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Type v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">β</span> → <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(init : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">β</span></span> → <span class="fn">α</span></span></div></div><p>Folds a function over a list from the left:
<code><a href=".././Init/Prelude.html#List.foldl">foldl</a> f z [a, b, c] = f (f (f z a) b) c</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">f</span> <span class="fn">_fun_discr</span> <span class="fn">[]</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">_fun_discr</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">f</span> <span class="fn">_fun_discr</span> (<span class="fn"><span class="fn">b</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">l</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#List.foldl">List.foldl</a> <span class="fn">f</span> (<span class="fn"><span class="fn">f</span> <span class="fn">_fun_discr</span> <span class="fn">b</span></span>) <span class="fn">l</span></span></span></li></ul></details></div></div><div class="decl" id="List.set"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2180-L2183">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.set">List.set</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></span></span></span></div></div><p><code>l.<a href=".././Init/Prelude.html#List.set">set</a> n a</code> sets the value of list <code>l</code> at (zero-based) index <code>n</code> to <code>a</code>:
<code>[a, b, c, d].<a href=".././Init/Prelude.html#List.set">set</a> 1 b' = [a, b', c, d]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.set">List.set</a> (<span class="fn"><span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span></span>) <span class="fn">0</span> <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">_fun_discr</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.set">List.set</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span></span>) (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">n</span></span>) <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href=".././Init/Prelude.html#List.set">List.set</a> <span class="fn">as</span> <span class="fn">n</span> <span class="fn">_fun_discr</span></span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.set">List.set</a> <span class="fn">[]</span> <span class="fn">_fun_discr</span> <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">[]</span></span></li></ul></details></div></div><div class="decl" id="List.length"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2192-L2194">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.length">List.length</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>The length of a list: <code>[].<a href=".././Init/Prelude.html#List.length">length</a> = 0</code> and <code>(a :: l).<a href=".././Init/Prelude.html#List.length">length</a> = l.<a href=".././Init/Prelude.html#List.length">length</a> + 1</code>.</p><p>This function is overridden in the compiler to <code><a href=".././Init/Prelude.html#List.lengthTR">lengthTR</a></code>, which uses constant
stack space, while leaving this function to use the "naive" recursion which is
easier for reasoning.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.length">List.length</a> <span class="fn">[]</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.length">List.length</a> (<span class="fn"><span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.length">List.length</a> <span class="fn">as</span></span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span></span></li></ul></details></div></div><div class="decl" id="List.lengthTRAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2197-L2199">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.lengthTRAux">List.lengthTRAux</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></span></div></div><p>Auxiliary function for <code><a href=".././Init/Prelude.html#List.lengthTR">List.lengthTR</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.lengthTRAux">List.lengthTRAux</a> <span class="fn">[]</span> <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">_fun_discr</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.lengthTRAux">List.lengthTRAux</a> (<span class="fn"><span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span></span>) <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#List.lengthTRAux">List.lengthTRAux</a> <span class="fn">as</span> (<span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">_fun_discr</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="List.lengthTR"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2205-L2206">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.lengthTR">List.lengthTR</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(as : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>A tail-recursive version of <code><a href=".././Init/Prelude.html#List.length">List.length</a></code>, used to implement <code><a href=".././Init/Prelude.html#List.length">List.length</a></code>
without running out of stack space.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.lengthTR">List.lengthTR</a> <span class="fn">as</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#List.lengthTRAux">List.lengthTRAux</a> <span class="fn">as</span> <span class="fn">0</span></span></span></li></ul></details></div></div><div class="decl" id="List.length_cons"><div class="theorem"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2208-L2209">source</a></div><div class="attributes">@[simp]</div>
<div class="decl_header"><span class="decl_kind">theorem</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.length_cons">List.length_cons</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(as : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.length">List.length</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> (<span class="fn"><a href=".././Init/Prelude.html#List.length">List.length</a> <span class="fn">as</span></span>)</span></span></div></div></div></div><div class="decl" id="List.concat"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2212-L2214">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.concat">List.concat</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></span></span></div></div><p><code>l.<a href=".././Init/Prelude.html#List.concat">concat</a> a</code> appends <code>a</code> at the <em>end</em> of <code>l</code>, that is, <code>l ++ [a]</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.concat">List.concat</a> <span class="fn">[]</span> <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">[<span class="fn">_fun_discr</span>]</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.concat">List.concat</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span></span>) <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn"><a href=".././Init/Prelude.html#List.concat">List.concat</a> <span class="fn">as</span> <span class="fn">_fun_discr</span></span></span></span></li></ul></details></div></div><div class="decl" id="List.get"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2221-L2223">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.get">List.get</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(as : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> (<span class="fn"><a href=".././Init/Prelude.html#List.length">List.length</a> <span class="fn">as</span></span>)</span> → <span class="fn">α</span></span></div></div><p><code>as.<a href=".././Init/Prelude.html#List.get">get</a> i</code> returns the <code>i</code>'th element of the list <code>as</code>.
This version of the function uses <code>i : <a href=".././Init/Prelude.html#Fin">Fin</a> as.<a href=".././Init/Prelude.html#List.length">length</a></code> to ensure that it will
not index out of bounds.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.get">List.get</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">tail</span></span>) <span class="fn">{ <span class="fn">val</span> := <span class="fn">0</span>, <span class="fn">isLt</span> := <span class="fn">isLt</span> }</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">a</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.get">List.get</a> (<span class="fn"><span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span></span>) <span class="fn">{ <span class="fn">val</span> := <span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">i</span></span>, <span class="fn">isLt</span> := <span class="fn">h</span> }</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#List.get">List.get</a> <span class="fn">as</span> <span class="fn">{ <span class="fn">val</span> := <span class="fn">i</span>, <span class="fn">isLt</span> := <span class="fn">(_ : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> <span class="fn">i</span></span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><a href=".././Init/Prelude.html#List.length">List.length</a> <span class="fn">as</span></span></span>)</span> }</span></span></span></li></ul></details></div></div><div class="decl" id="String"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2231-L2237">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String">String</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="String.mk"><li id="String.data" class="structure_field"><div class="structure_field_doc"><p>Unpack <code><a href=".././Init/Prelude.html#String">String</a></code> into a <code><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Char">Char</a></code>. This function is overridden by the
compiler and is O(n) in the length of the list.</p></div><div class="structure_field_info">data : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Char">Char</a></span></div></li></ul><p><code><a href=".././Init/Prelude.html#String">String</a></code> is the type of (UTF-8 encoded) strings.</p><p>The compiler overrides the data representation of this type to a byte sequence,
and both <code><a href=".././Init/Prelude.html#String.utf8ByteSize">String.utf8ByteSize</a></code> and <code><a href=".././Init/Data/String/Basic.html#String.length">String.length</a></code> are cached and O(1).</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-String" class="instances-for-list"></ul></details></div></div><div class="decl" id="String.decEq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2247-L2250">source</a></div><div class="attributes">@[extern  lean_string_dec_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.decEq">String.decEq</a></span><span class="decl_args">
<span class="fn">(s₁ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₂ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">s₁</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">s₂</span></span>)</span></div></div><p>Decides equality on <code><a href=".././Init/Prelude.html#String">String</a></code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="instDecidableEqString"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2252-L2252">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqString">instDecidableEqString</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#String">String</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instDecidableEqString">instDecidableEqString</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#String.decEq">String.decEq</a></span></li></ul></details></div></div><div class="decl" id="String.Pos"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2261-L2263">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.Pos">String.Pos</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="String.Pos.mk"><li id="String.Pos.byteIdx" class="structure_field"><div class="structure_field_doc"><p>Get the underlying byte index of a <code><a href=".././Init/Prelude.html#String.Pos">String.Pos</a></code></p></div><div class="structure_field_info">byteIdx : <a href=".././Init/Prelude.html#Nat">Nat</a></div></li></ul><p>A byte position in a <code><a href=".././Init/Prelude.html#String">String</a></code>. Internally, <code><a href=".././Init/Prelude.html#String">String</a></code>s are UTF-8 encoded.
Codepoint positions (counting the Unicode codepoints rather than bytes)
are represented by plain <code><a href=".././Init/Prelude.html#Nat">Nat</a></code>s instead.
Indexing a <code><a href=".././Init/Prelude.html#String">String</a></code> by a byte position is constant-time, while codepoint
positions need to be translated internally to byte positions in linear-time.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-String.Pos" class="instances-for-list"></ul></details></div></div><div class="decl" id="instInhabitedPos"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2265-L2266">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedPos">instInhabitedPos</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instInhabitedPos">instInhabitedPos</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">byteIdx</span> := <span class="fn">0</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="instDecidableEqPos"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2268-L2271">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableEqPos">instDecidableEqPos</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#DecidableEq">DecidableEq</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Substring"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2279-L2285">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Substring">Substring</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="Substring.mk"><li id="Substring.str" class="structure_field"><div class="structure_field_doc"><p>The underlying string to slice.</p></div><div class="structure_field_info">str : <a href=".././Init/Prelude.html#String">String</a></div></li><li id="Substring.startPos" class="structure_field"><div class="structure_field_doc"><p>The byte position of the start of the string slice.</p></div><div class="structure_field_info">startPos : <a href=".././Init/Prelude.html#String.Pos">String.Pos</a></div></li><li id="Substring.stopPos" class="structure_field"><div class="structure_field_doc"><p>The byte position of the end of the string slice.</p></div><div class="structure_field_info">stopPos : <a href=".././Init/Prelude.html#String.Pos">String.Pos</a></div></li></ul><p>A <code><a href=".././Init/Prelude.html#Substring">Substring</a></code> is a view into some subslice of a <code><a href=".././Init/Prelude.html#String">String</a></code>.
The actual string slicing is deferred because this would require copying the
string; here we only store a reference to the original string for
garbage collection purposes.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Substring" class="instances-for-list"></ul></details></div></div><div class="decl" id="instInhabitedSubstring"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2287-L2288">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedSubstring">instInhabitedSubstring</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Substring">Substring</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instInhabitedSubstring">instInhabitedSubstring</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">str</span> := <span class="fn">&quot&quot</span>, <span class="fn">startPos</span> := <span class="fn">{ <span class="fn">byteIdx</span> := <span class="fn">0</span> }</span>, <span class="fn">stopPos</span> := <span class="fn">{ <span class="fn">byteIdx</span> := <span class="fn">0</span> }</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="Substring.bsize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2291-L2292">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Substring.bsize">Substring.bsize</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Substring">Substring</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>The byte length of the substring.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Substring.bsize">Substring.bsize</a> <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">_fun_discr</span> with
  | <span class="fn">{ <span class="fn">str</span> := <span class="fn">str</span>, <span class="fn">startPos</span> := <span class="fn">b</span>, <span class="fn">stopPos</span> := <span class="fn">e</span> }</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Nat.sub">Nat.sub</a> <span class="fn"><span class="fn">e</span>.byteIdx</span> <span class="fn"><span class="fn">b</span>.byteIdx</span></span></span></span></li></ul></details></div></div><div class="decl" id="String.csize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2295-L2296">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.csize">String.csize</a></span><span class="decl_args">
<span class="fn">(c : <a href=".././Init/Prelude.html#Char">Char</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>Returns the number of bytes required to encode this <code><a href=".././Init/Prelude.html#Char">Char</a></code> in UTF-8.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#String.csize">String.csize</a> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#UInt32.toNat">UInt32.toNat</a> (<span class="fn"><a href=".././Init/Prelude.html#Char.utf8Size">Char.utf8Size</a> <span class="fn">c</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="String.utf8ByteSize"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2303-L2308">source</a></div><div class="attributes">@[extern  lean_string_utf8_byte_size]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.utf8ByteSize">String.utf8ByteSize</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#String">String</a> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>The UTF-8 byte length of this string.
This is overridden by the compiler to be cached and O(1).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#String.utf8ByteSize">String.utf8ByteSize</a> <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">_fun_discr</span> with
  | <span class="fn">{ <span class="fn">data</span> := <span class="fn">s</span> }</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#String.mk">String.utf8ByteSize.go</a> <span class="fn">s</span></span></span></span></li></ul></details></div></div><div class="decl" id="String.utf8ByteSize.go"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2306-L2308">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.utf8ByteSize.go">String.utf8ByteSize.go</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Char">Char</a></span> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#String.utf8ByteSize.go">String.utf8ByteSize.go</a> <span class="fn">[]</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#String.utf8ByteSize.go">String.utf8ByteSize.go</a> (<span class="fn"><span class="fn">c</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">cs</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#String.utf8ByteSize.go">String.utf8ByteSize.go</a> <span class="fn">cs</span></span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href=".././Init/Prelude.html#String.csize">String.csize</a> <span class="fn">c</span></span></span></span></li></ul></details></div></div><div class="decl" id="instHAddPos"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2310-L2311">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHAddPos">instHAddPos</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HAdd">HAdd</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instHAddPos">instHAddPos</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hAdd</span> := <span class="fn">fun <span class="fn">p₁</span> <span class="fn">p₂</span> =&gt <span class="fn">{ <span class="fn">byteIdx</span> := <span class="fn"><span class="fn"><span class="fn">p₁</span>.byteIdx</span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><span class="fn">p₂</span>.byteIdx</span></span> }</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instHSubPos"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2313-L2314">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHSubPos">instHSubPos</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HSub">HSub</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instHSubPos">instHSubPos</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hSub</span> := <span class="fn">fun <span class="fn">p₁</span> <span class="fn">p₂</span> =&gt <span class="fn">{ <span class="fn">byteIdx</span> := <span class="fn"><span class="fn"><span class="fn">p₁</span>.byteIdx</span> <a href=".././Init/Prelude.html#HSub.hSub">-</a> <span class="fn"><span class="fn">p₂</span>.byteIdx</span></span> }</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instHAddPosChar"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2316-L2317">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHAddPosChar">instHAddPosChar</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HAdd">HAdd</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a> <a href=".././Init/Prelude.html#Char">Char</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instHAddPosChar">instHAddPosChar</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hAdd</span> := <span class="fn">fun <span class="fn">p</span> <span class="fn">c</span> =&gt <span class="fn">{ <span class="fn">byteIdx</span> := <span class="fn"><span class="fn"><span class="fn">p</span>.byteIdx</span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href=".././Init/Prelude.html#String.csize">String.csize</a> <span class="fn">c</span></span></span> }</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instHAddPosString"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2319-L2320">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHAddPosString">instHAddPosString</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#HAdd">HAdd</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a> <a href=".././Init/Prelude.html#String">String</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instHAddPosString">instHAddPosString</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hAdd</span> := <span class="fn">fun <span class="fn">p</span> <span class="fn">s</span> =&gt <span class="fn">{ <span class="fn">byteIdx</span> := <span class="fn"><span class="fn"><span class="fn">p</span>.byteIdx</span> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn"><a href=".././Init/Prelude.html#String.utf8ByteSize">String.utf8ByteSize</a> <span class="fn">s</span></span></span> }</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instLEPos"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2322-L2323">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLEPos">instLEPos</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LE">LE</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instLEPos">instLEPos</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">le</span> := <span class="fn">fun <span class="fn">p₁</span> <span class="fn">p₂</span> =&gt <span class="fn"><span class="fn"><span class="fn">p₁</span>.byteIdx</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">p₂</span>.byteIdx</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instLTPos"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2325-L2326">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instLTPos">instLTPos</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#LT">LT</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instLTPos">instLTPos</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">lt</span> := <span class="fn">fun <span class="fn">p₁</span> <span class="fn">p₂</span> =&gt <span class="fn"><span class="fn"><span class="fn">p₁</span>.byteIdx</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn">p₂</span>.byteIdx</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instDecidableLePosInstLEPos"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2328-L2329">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableLePosInstLEPos">instDecidableLePosInstLEPos</a></span><span class="decl_args">
<span class="fn">(p₁ : <a href=".././Init/Prelude.html#String.Pos">String.Pos</a>)</span></span>
<span class="decl_args">
<span class="fn">(p₂ : <a href=".././Init/Prelude.html#String.Pos">String.Pos</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">p₁</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn">p₂</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instDecidableLePosInstLEPos">instDecidableLePosInstLEPos</a> <span class="fn">p₁</span> <span class="fn">p₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> (<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn"><span class="fn">p₁</span>.byteIdx</span> <a href=".././Init/Prelude.html#LE.le">≤</a> <span class="fn"><span class="fn">p₂</span>.byteIdx</span></span>)</span>)</span></span></li></ul></details></div></div><div class="decl" id="instDecidableLtPosInstLTPos"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2331-L2332">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instDecidableLtPosInstLTPos">instDecidableLtPosInstLTPos</a></span><span class="decl_args">
<span class="fn">(p₁ : <a href=".././Init/Prelude.html#String.Pos">String.Pos</a>)</span></span>
<span class="decl_args">
<span class="fn">(p₂ : <a href=".././Init/Prelude.html#String.Pos">String.Pos</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn">p₁</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn">p₂</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instDecidableLtPosInstLTPos">instDecidableLtPosInstLTPos</a> <span class="fn">p₁</span> <span class="fn">p₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#inferInstanceAs">inferInstanceAs</a> (<span class="fn"><a href=".././Init/Prelude.html#Decidable">Decidable</a> (<span class="fn"><span class="fn"><span class="fn">p₁</span>.byteIdx</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><span class="fn">p₂</span>.byteIdx</span></span>)</span>)</span></span></li></ul></details></div></div><div class="decl" id="String.endPos"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2335-L2336">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.endPos">String.endPos</a></span><span class="decl_args">
<span class="fn">(s : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#String.Pos">String.Pos</a></div></div><p>A <code><a href=".././Init/Prelude.html#String.Pos">String.Pos</a></code> pointing at the end of this string.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#String.endPos">String.endPos</a> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">byteIdx</span> := <span class="fn"><a href=".././Init/Prelude.html#String.utf8ByteSize">String.utf8ByteSize</a> <span class="fn">s</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="String.toSubstring"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2339-L2342">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.toSubstring">String.toSubstring</a></span><span class="decl_args">
<span class="fn">(s : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Substring">Substring</a></div></div><p>Convert a <code><a href=".././Init/Prelude.html#String">String</a></code> into a <code><a href=".././Init/Prelude.html#Substring">Substring</a></code> denoting the entire string.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#String.toSubstring">String.toSubstring</a> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">str</span> := <span class="fn">s</span>, <span class="fn">startPos</span> := <span class="fn">{ <span class="fn">byteIdx</span> := <span class="fn">0</span> }</span>, <span class="fn">stopPos</span> := <span class="fn"><a href=".././Init/Prelude.html#String.endPos">String.endPos</a> <span class="fn">s</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="String.toSubstring'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2345-L2346">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.toSubstring'">String.toSubstring'</a></span><span class="decl_args">
<span class="fn">(s : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Substring">Substring</a></div></div><p><code><a href=".././Init/Prelude.html#String.toSubstring">String.toSubstring</a></code> without <code>[inline]</code> annotation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#String.toSubstring'">String.toSubstring'</a> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#String.toSubstring">String.toSubstring</a> <span class="fn">s</span></span></span></li></ul></details></div></div><div class="decl" id="unsafeCast"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2372-L2373">source</a></div><div class="decl_header"><span class="decl_kind">unsafe def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#unsafeCast">unsafeCast</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Sort v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">β</span></div></div><p>This function will cast a value of type <code>α</code> to type <code>β</code>, and is a no-op in the
compiler. This function is <strong>extremely dangerous</strong> because there is no guarantee
that types <code>α</code> and <code>β</code> have the same data representation, and this can lead to
memory unsafety. It is also logically unsound, since you could just cast
<code><a href=".././Init/Prelude.html#True">True</a></code> to <code><a href=".././Init/Prelude.html#False">False</a></code>. For all those reasons this function is marked as <code>unsafe</code>.</p><p>It is implemented by lifting both <code>α</code> and <code>β</code> into a common universe, and then
using <code><a href=".././Init/Prelude.html#cast">cast</a> (lcProof : <a href=".././Init/Prelude.html#ULift">ULift</a> (PLift α) = <a href=".././Init/Prelude.html#ULift">ULift</a> (PLift β))</code> to actually perform
the cast. All these operations are no-ops in the compiler.</p><p>Using this function correctly requires some knowledge of the data representation
of the source and target types. Some general classes of casts which are safe in
the current runtime:</p><ul>
<li><code><a href=".././Init/Prelude.html#Array">Array</a> α</code> to <code><a href=".././Init/Prelude.html#Array">Array</a> β</code> where <code>α</code> and <code>β</code> have compatible representations,
or more generally for other inductive types.</li>
<li><code><a href=".././Init/Prelude.html#Quot">Quot</a> α r</code> and <code>α</code>.</li>
<li><code>@Subtype α p</code> and <code>α</code>, or generally any structure containing only one
non-<code>Prop</code> field of type <code>α</code>.</li>
<li>Casting <code>α</code> to/from <code><a href=".././Init/Core.html#NonScalar">NonScalar</a></code> when <code>α</code> is a boxed generic type
(i.e. a function that accepts an arbitrary type <code>α</code> and is not specialized to
a scalar type like <code><a href=".././Init/Prelude.html#UInt8">UInt8</a></code>).</li>
</ul><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#unsafeCast">unsafeCast</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#cast">cast</a> <span class="fn">(_ : <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#ULift">ULift</a> (<span class="fn"><a href=".././Init/Prelude.html#PLift">PLift</a> <span class="fn">α</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#ULift">ULift</a> (<span class="fn"><a href=".././Init/Prelude.html#PLift">PLift</a> <span class="fn">β</span></span>)</span></span>)</span> <span class="fn">{ <span class="fn">down</span> := <span class="fn">{ <span class="fn">down</span> := <span class="fn">a</span> }</span> }</span></span>).down</span>.down</span></span></li></ul></details></div></div><div class="decl" id="panicCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2388-L2388">source</a></div><div class="attributes">@[neverExtract, extern  lean_panic_fn]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#panicCore">panicCore</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(msg : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Auxiliary definition for <code><a href=".././Init/Prelude.html#panic">panic</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#panicCore">panicCore</a> <span class="fn">msg</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">default</span></span></li></ul></details></div></div><div class="decl" id="panic"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2402-L2403">source</a></div><div class="attributes">@[neverExtract, noinline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#panic">panic</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(msg : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p><code>(panic "msg" : α)</code> has a built-in implementation which prints <code>msg</code> to
the error buffer. It <em>does not</em> terminate execution, and because it is a safe
function, it still has to return an element of <code>α</code>, so it takes <code>[Inhabited α]</code>
and returns <code>default</code>. It is primarily intended for debugging in pure contexts,
and assertion failures.</p><p>Because this is a pure function with side effects, it is marked as
<code>@[neverExtract]</code> so that the compiler will not perform common sub-expression
elimination and other optimizations that assume that the expression is pure.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#panic">panic</a> <span class="fn">msg</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#panicCore">panicCore</a> <span class="fn">msg</span></span></span></li></ul></details></div></div><div class="decl" id="GetElem"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2420-L2441">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#GetElem">GetElem</a></span><span class="decl_args">
<span class="fn">(cont : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(idx : <span class="fn">Type v</span>)</span></span>
<span class="decl_args">
<span class="fn">(elem : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type w</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(dom : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn"><span class="fn">cont</span> → <span class="fn"><span class="fn">idx</span> → <span class="fn">Prop</span></span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u v) w)</span></div></div><ul class="structure_fields" id="GetElem.mk"><li id="GetElem.getElem" class="structure_field"><div class="structure_field_doc"><p>The syntax <code>arr[i]</code> gets the <code>i</code>'th element of the collection <code>arr</code>.
If there are proof side conditions to the application, they will be automatically
inferred by the <code>get_elem_tactic</code> tactic.</p><p>The actual behavior of this class is type-dependent,
but here are some important implementations:</p><ul>
<li><code>arr[i] : α</code> where <code>arr : <a href=".././Init/Prelude.html#Array">Array</a> α</code> and <code>i : <a href=".././Init/Prelude.html#Nat">Nat</a></code> or <code>i : <a href=".././Init/Prelude.html#USize">USize</a></code>:
does array indexing with no bounds check and a proof side goal <code>i < arr.<a href=".././Init/Prelude.html#UInt8.size">size</a></code>.</li>
<li><code>l[i] : α</code> where <code>l : <a href=".././Init/Prelude.html#List">List</a> α</code> and <code>i : <a href=".././Init/Prelude.html#Nat">Nat</a></code>: index into a list,
with proof side goal <code>i < l.<a href=".././Init/Prelude.html#List.length">length</a></code>.</li>
<li><code>stx[i] : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> where <code>stx : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> and <code>i : <a href=".././Init/Prelude.html#Nat">Nat</a></code>: get a syntax argument,
no side goal (returns <code>.missing</code> out of range)</li>
</ul><p>There are other variations on this syntax:</p><ul>
<li><code>arr[i]</code>: proves the proof side goal by <code>get_elem_tactic</code></li>
<li><code>arr[i]!</code>: panics if the side goal is false</li>
<li><code>arr[i]?</code>: returns <code>none</code> if the side goal is false</li>
<li><code>arr[i]'h</code>: uses <code>h</code> to prove the side goal</li>
</ul></div><div class="structure_field_info">getElem : <span class="fn">(<span class="fn">xs</span> : <span class="fn">cont</span>) → <span class="fn">(<span class="fn">i</span> : <span class="fn">idx</span>) → <span class="fn"><span class="fn"><span class="fn">dom</span> <span class="fn">xs</span> <span class="fn">i</span></span> → <span class="fn">elem</span></span></span></span></div></li></ul><p>The class <code><a href=".././Init/Prelude.html#GetElem">GetElem</a> cont idx elem dom</code> implements the <code>xs[i]</code> notation.
When you write this, given <code>xs : cont</code> and <code>i : idx</code>, lean looks for an instance
of <code><a href=".././Init/Prelude.html#GetElem">GetElem</a> cont idx elem dom</code>. Here <code>elem</code> is the type of <code>xs[i]</code>, while
<code>dom</code> is whatever proof side conditions are required to make this applicable.
For example, the instance for arrays looks like
<code><a href=".././Init/Prelude.html#GetElem">GetElem</a> (Array α) <a href=".././Init/Prelude.html#Nat">Nat</a> α (fun xs i => i < xs.size)</code>.</p><p>The proof side-condition <code>dom xs i</code> is automatically dispatched by the
<code>get_elem_tactic</code> tactic, which can be extended by adding more clauses to
<code>get_elem_tactic_trivial</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-GetElem" class="instances-list"></ul></details></div></div><div class="decl" id="Array"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2455-L2461">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array">Array</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="Array.mk"><li id="Array.data" class="structure_field"><div class="structure_field_doc"><p>Convert an <code><a href=".././Init/Prelude.html#Array">Array</a> α</code> into a <code><a href=".././Init/Prelude.html#List">List</a> α</code>. This function is overridden
to <code><a href=".././Init/Data/Array/Basic.html#Array.toList">Array.toList</a></code> and is O(n) in the length of the list.</p></div><div class="structure_field_info">data : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span></div></li></ul><p><code><a href=".././Init/Prelude.html#Array">Array</a> α</code> is the type of <a href="https://en.wikipedia.org/wiki/Dynamic_array">dynamic arrays</a>
with elements from <code>α</code>. This type has special support in the runtime.</p><p>An array has a size and a capacity; the size is <code><a href=".././Init/Prelude.html#Array.size">Array.size</a></code> but the capacity
is not observable from lean code. Arrays perform best when unshared; as long
as they are used "linearly" all updates will be performed destructively on the
array, so it has comparable performance to mutable arrays in imperative
programming languages.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Array" class="instances-for-list"></ul></details></div></div><div class="decl" id="Array.mkEmpty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2468-L2469">source</a></div><div class="attributes">@[extern  lean_mk_empty_array_with_capacity]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkEmpty">Array.mkEmpty</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(c : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Construct a new empty array with initial capacity <code>c</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.mkEmpty">Array.mkEmpty</a> <span class="fn">c</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">data</span> := <span class="fn">[]</span> }</span></span></li></ul></details></div></div><div class="decl" id="Array.empty"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2472-L2472">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.empty">Array.empty</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Construct a new empty array.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Array.empty</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Array.mkEmpty">Array.mkEmpty</a> <span class="fn">0</span></span></span></li></ul></details></div></div><div class="decl" id="Array.size"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2476-L2477">source</a></div><div class="attributes">@[extern  lean_array_get_size]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.size">Array.size</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>Get the size of an array. This is a cached value, so it is O(1) to access.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.size">Array.size</a> <span class="fn">a</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#List.length">List.length</a> <span class="fn"><span class="fn">a</span>.data</span></span></span></li></ul></details></div></div><div class="decl" id="Array.get"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2481-L2482">source</a></div><div class="attributes">@[extern  lean_array_fget]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.get">Array.get</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.size">Array.size</a> <span class="fn">a</span></span>)</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Access an element from an array without bounds checks, using a <code><a href=".././Init/Prelude.html#Fin">Fin</a></code> index.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.get">Array.get</a> <span class="fn">a</span> <span class="fn">i</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#List.get">List.get</a> <span class="fn"><span class="fn">a</span>.data</span> <span class="fn">i</span></span></span></li></ul></details></div></div><div class="decl" id="Array.getD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2485-L2486">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.getD">Array.getD</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(v₀ : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Access an element from an array, or return <code>v₀</code> if the index is out of bounds.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.getD">Array.getD</a> <span class="fn">a</span> <span class="fn">i</span> <span class="fn">v₀</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">i</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href=".././Init/Prelude.html#Array.size">Array.size</a> <span class="fn">a</span></span></span> then <span class="fn"><a href=".././Init/Prelude.html#Array.get">Array.get</a> <span class="fn">a</span> <span class="fn">{ <span class="fn">val</span> := <span class="fn">i</span>, <span class="fn">isLt</span> := <span class="fn">h</span> }</span></span> else <span class="fn">v₀</span></span></span></li></ul></details></div></div><div class="decl" id="Array.get!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2490-L2491">source</a></div><div class="attributes">@[extern  lean_array_get]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.get!">Array.get!</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">α</span></div></div><p>Access an element from an array, or panic if the index is out of bounds.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.get!">Array.get!</a> <span class="fn">a</span> <span class="fn">i</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Array.getD">Array.getD</a> <span class="fn">a</span> <span class="fn">i</span> <span class="fn">default</span></span></span></li></ul></details></div></div><div class="decl" id="instGetElemArrayNatLtInstLTNatSize"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2493-L2494">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instGetElemArrayNatLtInstLTNatSize">instGetElemArrayNatLtInstLTNatSize</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#GetElem">GetElem</a> (<span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>) <a href=".././Init/Prelude.html#Nat">Nat</a> <span class="fn">α</span> <span class="fn">fun <span class="fn">xs</span> <span class="fn">i</span> =&gt <span class="fn"><span class="fn">i</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href=".././Init/Prelude.html#Array.size">Array.size</a> <span class="fn">xs</span></span></span></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instGetElemArrayNatLtInstLTNatSize</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">getElem</span> := <span class="fn">fun <span class="fn">xs</span> <span class="fn">i</span> <span class="fn">h</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Array.get">Array.get</a> <span class="fn">xs</span> <span class="fn">{ <span class="fn">val</span> := <span class="fn">i</span>, <span class="fn">isLt</span> := <span class="fn">h</span> }</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Array.push"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2501-L2502">source</a></div><div class="attributes">@[extern  lean_array_push]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.push">Array.push</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(v : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Push an element onto the end of an array. This is amortized O(1) because
<code><a href=".././Init/Prelude.html#Array">Array</a> α</code> is internally a dynamic array.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> <span class="fn">a</span> <span class="fn">v</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">data</span> := <span class="fn"><a href=".././Init/Prelude.html#List.concat">List.concat</a> <span class="fn"><span class="fn">a</span>.data</span> <span class="fn">v</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Array.mkArray0"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2505-L2506">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray0">Array.mkArray0</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Array.mkArray0</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Array.mkEmpty">Array.mkEmpty</a> <span class="fn">0</span></span></span></li></ul></details></div></div><div class="decl" id="Array.mkArray1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2509-L2510">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray1">Array.mkArray1</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a₁ : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[a₁]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.mkArray1">Array.mkArray1</a> <span class="fn">a₁</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.mkEmpty">Array.mkEmpty</a> <span class="fn">1</span></span>) <span class="fn">a₁</span></span></span></li></ul></details></div></div><div class="decl" id="Array.mkArray2"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2513-L2514">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray2">Array.mkArray2</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a₁ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₂ : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[a₁, a₂]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.mkArray2">Array.mkArray2</a> <span class="fn">a₁</span> <span class="fn">a₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.mkEmpty">Array.mkEmpty</a> <span class="fn">1</span></span>) <span class="fn">a₁</span></span>) <span class="fn">a₂</span></span></span></li></ul></details></div></div><div class="decl" id="Array.mkArray3"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2517-L2518">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray3">Array.mkArray3</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a₁ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₂ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₃ : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[a₁, a₂, a₃]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.mkArray3">Array.mkArray3</a> <span class="fn">a₁</span> <span class="fn">a₂</span> <span class="fn">a₃</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.mkEmpty">Array.mkEmpty</a> <span class="fn">1</span></span>) <span class="fn">a₁</span></span>) <span class="fn">a₂</span></span>) <span class="fn">a₃</span></span></span></li></ul></details></div></div><div class="decl" id="Array.mkArray4"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2521-L2522">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray4">Array.mkArray4</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a₁ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₂ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₃ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₄ : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[a₁, a₂, a₃, a₄]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.mkArray4">Array.mkArray4</a> <span class="fn">a₁</span> <span class="fn">a₂</span> <span class="fn">a₃</span> <span class="fn">a₄</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.mkEmpty">Array.mkEmpty</a> <span class="fn">1</span></span>) <span class="fn">a₁</span></span>) <span class="fn">a₂</span></span>) <span class="fn">a₃</span></span>) <span class="fn">a₄</span></span></span></li></ul></details></div></div><div class="decl" id="Array.mkArray5"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2525-L2526">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray5">Array.mkArray5</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a₁ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₂ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₃ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₄ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₅ : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[a₁, a₂, a₃, a₄, a₅]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.mkArray5">Array.mkArray5</a> <span class="fn">a₁</span> <span class="fn">a₂</span> <span class="fn">a₃</span> <span class="fn">a₄</span> <span class="fn">a₅</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.mkEmpty">Array.mkEmpty</a> <span class="fn">1</span></span>) <span class="fn">a₁</span></span>) <span class="fn">a₂</span></span>) <span class="fn">a₃</span></span>) <span class="fn">a₄</span></span>) <span class="fn">a₅</span></span></span></li></ul></details></div></div><div class="decl" id="Array.mkArray6"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2529-L2530">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray6">Array.mkArray6</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a₁ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₂ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₃ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₄ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₅ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₆ : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[a₁, a₂, a₃, a₄, a₅, a₆]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.mkArray6">Array.mkArray6</a> <span class="fn">a₁</span> <span class="fn">a₂</span> <span class="fn">a₃</span> <span class="fn">a₄</span> <span class="fn">a₅</span> <span class="fn">a₆</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.mkEmpty">Array.mkEmpty</a> <span class="fn">1</span></span>) <span class="fn">a₁</span></span>) <span class="fn">a₂</span></span>) <span class="fn">a₃</span></span>) <span class="fn">a₄</span></span>) <span class="fn">a₅</span></span>) <span class="fn">a₆</span></span></span></li></ul></details></div></div><div class="decl" id="Array.mkArray7"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2533-L2534">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray7">Array.mkArray7</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a₁ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₂ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₃ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₄ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₅ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₆ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₇ : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[a₁, a₂, a₃, a₄, a₅, a₆, a₇]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.mkArray7">Array.mkArray7</a> <span class="fn">a₁</span> <span class="fn">a₂</span> <span class="fn">a₃</span> <span class="fn">a₄</span> <span class="fn">a₅</span> <span class="fn">a₆</span> <span class="fn">a₇</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a>
    (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.mkEmpty">Array.mkEmpty</a> <span class="fn">1</span></span>) <span class="fn">a₁</span></span>) <span class="fn">a₂</span></span>) <span class="fn">a₃</span></span>) <span class="fn">a₄</span></span>) <span class="fn">a₅</span></span>) <span class="fn">a₆</span></span>) <span class="fn">a₇</span></span></span></li></ul></details></div></div><div class="decl" id="Array.mkArray8"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2537-L2538">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.mkArray8">Array.mkArray8</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a₁ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₂ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₃ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₄ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₅ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₆ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₇ : <span class="fn">α</span>)</span></span>
<span class="decl_args">
<span class="fn">(a₈ : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Create array <code>#[a₁, a₂, a₃, a₄, a₅, a₆, a₇, a₈]</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Array.set"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2547-L2548">source</a></div><div class="attributes">@[extern  lean_array_fset]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.set">Array.set</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <span class="fn"><a href=".././Init/Prelude.html#Fin">Fin</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.size">Array.size</a> <span class="fn">a</span></span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(v : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Set an element in an array without bounds checks, using a <code><a href=".././Init/Prelude.html#Fin">Fin</a></code> index.</p><p>This will perform the update destructively provided that <code>a</code> has a reference
count of 1 when called.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.set">Array.set</a> <span class="fn">a</span> <span class="fn">i</span> <span class="fn">v</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">data</span> := <span class="fn"><a href=".././Init/Prelude.html#List.set">List.set</a> <span class="fn"><span class="fn">a</span>.data</span> <span class="fn"><span class="fn">i</span>.val</span> <span class="fn">v</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Array.setD"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2556-L2557">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.setD">Array.setD</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(v : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Set an element in an array, or do nothing if the index is out of bounds.</p><p>This will perform the update destructively provided that <code>a</code> has a reference
count of 1 when called.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.setD">Array.setD</a> <span class="fn">a</span> <span class="fn">i</span> <span class="fn">v</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">if h : <span class="fn"><span class="fn">i</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <span class="fn"><a href=".././Init/Prelude.html#Array.size">Array.size</a> <span class="fn">a</span></span></span> then <span class="fn"><a href=".././Init/Prelude.html#Array.set">Array.set</a> <span class="fn">a</span> <span class="fn">{ <span class="fn">val</span> := <span class="fn">i</span>, <span class="fn">isLt</span> := <span class="fn">h</span> }</span> <span class="fn">v</span></span> else <span class="fn">a</span></span></span></li></ul></details></div></div><div class="decl" id="Array.set!"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2566-L2567">source</a></div><div class="attributes">@[extern  lean_array_set]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.set!">Array.set!</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(v : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Set an element in an array, or panic if the index is out of bounds.</p><p>This will perform the update destructively provided that <code>a</code> has a reference
count of 1 when called.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.set!">Array.set!</a> <span class="fn">a</span> <span class="fn">i</span> <span class="fn">v</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Array.setD">Array.setD</a> <span class="fn">a</span> <span class="fn">i</span> <span class="fn">v</span></span></span></li></ul></details></div></div><div class="decl" id="Array.appendCore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2570-L2578">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.appendCore">Array.appendCore</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(as : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(bs : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Slower <code><a href=".././Init/Data/Array/Basic.html#Array.append">Array.append</a></code> used in quotations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.appendCore">Array.appendCore</a> <span class="fn">as</span> <span class="fn">bs</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Array.appendCore.loop">Array.appendCore.loop</a> <span class="fn">bs</span> (<span class="fn"><a href=".././Init/Prelude.html#Array.size">Array.size</a> <span class="fn">bs</span></span>) <span class="fn">0</span> <span class="fn">as</span></span></span></li></ul></details></div></div><div class="decl" id="Array.appendCore.loop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2571-L2577">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.appendCore.loop">Array.appendCore.loop</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(bs : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(j : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(as : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="List.toArrayAux"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2582-L2584">source</a></div><div class="attributes">@[inlineIfReduce]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.toArrayAux">List.toArrayAux</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span> → <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></span></span></div></div><p>Auxiliary definition for <code><a href=".././Init/Prelude.html#List.toArray">List.toArray</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.toArrayAux">List.toArrayAux</a> <span class="fn">[]</span> <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">_fun_discr</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.toArrayAux">List.toArrayAux</a> (<span class="fn"><span class="fn">a</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span></span>) <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#List.toArrayAux">List.toArrayAux</a> <span class="fn">as</span> (<span class="fn"><a href=".././Init/Prelude.html#Array.push">Array.push</a> <span class="fn">_fun_discr</span> <span class="fn">a</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="List.redLength"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2588-L2590">source</a></div><div class="attributes">@[inlineIfReduce]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.redLength">List.redLength</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span> → <a href=".././Init/Prelude.html#Nat">Nat</a></span></div></div><p>A non-tail-recursive version of <code><a href=".././Init/Prelude.html#List.length">List.length</a></code>, used for <code><a href=".././Init/Prelude.html#List.toArray">List.toArray</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.redLength">List.redLength</a> <span class="fn">[]</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.redLength">List.redLength</a> (<span class="fn"><span class="fn">head</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn">as</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Nat.succ">Nat.succ</a> (<span class="fn"><a href=".././Init/Prelude.html#List.redLength">List.redLength</a> <span class="fn">as</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="List.toArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2599-L2600">source</a></div><div class="attributes">@[matchPattern, inline, export lean_list_to_array]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#List.toArray">List.toArray</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(as : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span></div></div><p>Convert a <code><a href=".././Init/Prelude.html#List">List</a> α</code> into an <code><a href=".././Init/Prelude.html#Array">Array</a> α</code>. This is O(n) in the length of the list.</p><p>This function is exported to C, where it is called by <code><a href=".././Init/Prelude.html#Array.mk">Array.mk</a></code>
(the constructor) to implement this functionality.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List.toArray">List.toArray</a> <span class="fn">as</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#List.toArrayAux">List.toArrayAux</a> <span class="fn">as</span> (<span class="fn"><a href=".././Init/Prelude.html#Array.mkEmpty">Array.mkEmpty</a> (<span class="fn"><a href=".././Init/Prelude.html#List.redLength">List.redLength</a> <span class="fn">as</span></span>)</span>)</span></span></li></ul></details></div></div><div class="decl" id="Bind"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2603-L2606">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Bind">Bind</a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (u + 1) v)</span></div></div><ul class="structure_fields" id="Bind.mk"><li id="Bind.bind" class="structure_field"><div class="structure_field_doc"><p>If <code>x : m α</code> and <code>f : α → m β</code>, then <code>x >>= f : m β</code> represents the
result of executing <code>x</code> to get a value of type <code>α</code> and then passing it to <code>f</code>.</p></div><div class="structure_field_info">bind : <span class="fn">{<span class="fn">α </span>β : <span class="fn">Type u</span>} → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn">(<span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span>) → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span></span></span></div></li></ul><p>The typeclass which supplies the <code>>>=</code> "bind" function. See <code><a href=".././Init/Prelude.html#Monad">Monad</a></code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Bind" class="instances-list"></ul></details></div></div><div class="decl" id="Pure"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2611-L2614">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Pure">Pure</a></span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (u + 1) v)</span></div></div><ul class="structure_fields" id="Pure.mk"><li id="Pure.pure" class="structure_field"><div class="structure_field_doc"><p>If <code>a : α</code>, then <code><a href=".././Init/Prelude.html#ReaderT.pure">pure</a> a : f α</code> represents a monadic action that does
nothing and returns <code>a</code>.</p></div><div class="structure_field_info">pure : <span class="fn">{<span class="fn">α</span> : <span class="fn">Type u</span>} → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span></span></span></div></li></ul><p>The typeclass which supplies the <code><a href=".././Init/Prelude.html#ReaderT.pure">pure</a></code> function. See <code><a href=".././Init/Prelude.html#Monad">Monad</a></code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Pure" class="instances-list"></ul></details></div></div><div class="decl" id="Functor"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2627-L2632">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Functor">Functor</a></span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (u + 1) v)</span></div></div><ul class="structure_fields" id="Functor.mk"><li id="Functor.map" class="structure_field"><div class="structure_field_doc"><p>If <code>f : α → β</code> and <code>x : F α</code> then <code>f <$> x : F β</code>.</p></div><div class="structure_field_info">map : <span class="fn">{<span class="fn">α </span>β : <span class="fn">Type u</span>} → <span class="fn">(<span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>) → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span></span></span></span></div></li><li id="Functor.mapConst" class="structure_field"><div class="structure_field_doc"><p>The special case <code><a href=".././Init/Prelude.html#Function.const">const</a> a <$> x</code>, which can sometimes be implemented more
efficiently.</p></div><div class="structure_field_info">mapConst : <span class="fn">{<span class="fn">α </span>β : <span class="fn">Type u</span>} → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">β</span></span> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span></span></span></span></div></li></ul><p>In functional programming, a "functor" is a function on types <code>F : Type u → Type v</code>
equipped with an operator called <code><a href=".././Init/Prelude.html#Option.map">map</a></code> or <code><$></code> such that if <code>f : α → β</code> then
<code><a href=".././Init/Prelude.html#Option.map">map</a> f : F α → F β</code>, so <code>f <$> x : F β</code> if <code>x : F α</code>. This corresponds to the
category-theory notion of <a href="https://en.wikipedia.org/wiki/Functor">functor</a> in
the special case where the category is the category of types and functions
between them, except that this class supplies only the operations and not the
laws (see <code><a href=".././Init/Control/Lawful.html#LawfulFunctor">LawfulFunctor</a></code>).</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Functor" class="instances-list"></ul></details></div></div><div class="decl" id="Seq"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2635-L2642">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Seq">Seq</a></span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (u + 1) v)</span></div></div><ul class="structure_fields" id="Seq.mk"><li id="Seq.seq" class="structure_field"><div class="structure_field_doc"><p>If <code>mf : F (α → β)</code> and <code>mx : F α</code>, then <code>mf <*> mx : F β</code>.
In a monad this is the same as <code>do let f ← mf; x ← mx; <a href=".././Init/Prelude.html#ReaderT.pure">pure</a> (f x)</code>:
it evaluates first the function, then the argument, and applies one to the other.</p><p>To avoid surprising evaluation semantics, <code>mx</code> is taken "lazily", using a
<code><a href=".././Init/Prelude.html#Unit">Unit</a> → f α</code> function.</p></div><div class="structure_field_info">seq : <span class="fn">{<span class="fn">α </span>β : <span class="fn">Type u</span>} → <span class="fn"><span class="fn"><span class="fn">f</span> (<span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span> → <span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span></span>) → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span></span></span></span></div></li></ul><p>The typeclass which supplies the <code><*></code> "seq" function. See <code><a href=".././Init/Prelude.html#Applicative">Applicative</a></code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Seq" class="instances-list"></ul></details></div></div><div class="decl" id="SeqLeft"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2645-L2651">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#SeqLeft">SeqLeft</a></span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (u + 1) v)</span></div></div><ul class="structure_fields" id="SeqLeft.mk"><li id="SeqLeft.seqLeft" class="structure_field"><div class="structure_field_doc"><p>If <code>x : F α</code> and <code>y : F β</code>, then <code>x <* y</code> evaluates <code>x</code>, then <code>y</code>,
and returns the result of <code>x</code>.</p><p>To avoid surprising evaluation semantics, <code>y</code> is taken "lazily", using a
<code><a href=".././Init/Prelude.html#Unit">Unit</a> → f β</code> function.</p></div><div class="structure_field_info">seqLeft : <span class="fn">{<span class="fn">α </span>β : <span class="fn">Type u</span>} → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">α</span></span> → <span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span></span>) → <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span></span></span></span></div></li></ul><p>The typeclass which supplies the <code><*</code> "seqLeft" function. See <code><a href=".././Init/Prelude.html#Applicative">Applicative</a></code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-SeqLeft" class="instances-list"></ul></details></div></div><div class="decl" id="SeqRight"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2654-L2660">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#SeqRight">SeqRight</a></span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (u + 1) v)</span></div></div><ul class="structure_fields" id="SeqRight.mk"><li id="SeqRight.seqRight" class="structure_field"><div class="structure_field_doc"><p>If <code>x : F α</code> and <code>y : F β</code>, then <code>x *> y</code> evaluates <code>x</code>, then <code>y</code>,
and returns the result of <code>y</code>.</p><p>To avoid surprising evaluation semantics, <code>y</code> is taken "lazily", using a
<code><a href=".././Init/Prelude.html#Unit">Unit</a> → f β</code> function.</p></div><div class="structure_field_info">seqRight : <span class="fn">{<span class="fn">α </span>β : <span class="fn">Type u</span>} → <span class="fn"><span class="fn"><span class="fn">f</span> <span class="fn">α</span></span> → <span class="fn">(<span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span></span>) → <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span></span></span></span></div></li></ul><p>The typeclass which supplies the <code>*></code> "seqRight" function. See <code><a href=".././Init/Prelude.html#Applicative">Applicative</a></code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-SeqRight" class="instances-list"></ul></details></div></div><div class="decl" id="Applicative"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2674-L2677">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Applicative">Applicative</a></span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href=".././Init/Prelude.html#Functor">Functor</a></span></span>
, <span class="decl_parent">
<span class="fn"><a class="break_within" href=".././Init/Prelude.html#Pure">Pure</a></span></span>
, <span class="decl_parent">
<span class="fn"><a class="break_within" href=".././Init/Prelude.html#Seq">Seq</a></span></span>
, <span class="decl_parent">
<span class="fn"><a class="break_within" href=".././Init/Prelude.html#SeqLeft">SeqLeft</a></span></span>
, <span class="decl_parent">
<span class="fn"><a class="break_within" href=".././Init/Prelude.html#SeqRight">SeqRight</a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (u + 1) v)</span></div></div><ul class="structure_fields" id="Applicative.mk"></ul><p>An <a href="https://en.wikipedia.org/wiki/Applicative_functor">applicative functor</a> is
an intermediate structure between <code><a href=".././Init/Prelude.html#Functor">Functor</a></code> and <code><a href=".././Init/Prelude.html#Monad">Monad</a></code>. It mainly consists of
two operations:</p><ul>
<li><code><a href=".././Init/Prelude.html#ReaderT.pure">pure</a> : α → F α</code></li>
<li><code>seq : F (α → β) → F α → F β</code> (written as <code><*></code>)</li>
</ul><p>The <code>seq</code> operator gives a notion of evaluation order to the effects, where
the first argument is executed before the second, but unlike a monad the results
of earlier computations cannot be used to define later actions.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Applicative" class="instances-list"></ul></details></div></div><div class="decl" id="Monad"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2694-L2698">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Monad">Monad</a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href=".././Init/Prelude.html#Applicative">Applicative</a></span></span>
, <span class="decl_parent">
<span class="fn"><a class="break_within" href=".././Init/Prelude.html#Bind">Bind</a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (u + 1) v)</span></div></div><ul class="structure_fields" id="Monad.mk"></ul><p>A <a href="https://en.wikipedia.org/wiki/Monad_(functional_programming)">monad</a> is a
structure which abstracts the concept of sequential control flow.
It mainly consists of two operations:</p><ul>
<li><code><a href=".././Init/Prelude.html#ReaderT.pure">pure</a> : α → F α</code></li>
<li><code><a href=".././Init/Prelude.html#ReaderT.bind">bind</a> : F α → (α → F β) → F β</code> (written as <code>>>=</code>)</li>
</ul><p>Like many functional programming languages, Lean makes extensive use of monads
for structuring programs. In particular, the <code>do</code> notation is a very powerful
syntax over monad operations, and it depends on a <code><a href=".././Init/Prelude.html#Monad">Monad</a></code> instance.</p><p>See <a href="https://leanprover.github.io/lean4/doc/do.html">the <code>do</code> notation</a>
chapter of the manual for details.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Monad" class="instances-list"></ul></details></div></div><div class="decl" id="instInhabitedForAll_2"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2700-L2701">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedForAll_2">instInhabitedForAll_2</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedForAll_2</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">pure</span> }</span></span></li></ul></details></div></div><div class="decl" id="instInhabited"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2703-L2704">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabited">instInhabited</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabited</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instForAllNonemptyNonempty"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2706-L2707">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instForAllNonemptyNonempty">instForAllNonemptyNonempty</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u_1</span> → <span class="fn">Type u_2</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <span class="fn">α</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> (<span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instForAllNonemptyNonempty">@<a href=".././Init/Prelude.html#instForAllNonemptyNonempty">instForAllNonemptyNonempty</a></a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#instForAllNonemptyNonempty.proof_1">@<a href=".././Init/Prelude.html#instForAllNonemptyNonempty.proof_1">instForAllNonemptyNonempty.proof_1</a></a></span></li></ul></details></div></div><div class="decl" id="Array.sequenceMap"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2710-L2718">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.sequenceMap">Array.sequenceMap</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Type v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type v</span> → <span class="fn">Type w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(as : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> (<span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">β</span></span>)</span></div></div><p>A fusion of Haskell's <code>sequence</code> and <code><a href=".././Init/Prelude.html#Option.map">map</a></code>. Used in syntax quotations.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array.sequenceMap">Array.sequenceMap</a> <span class="fn">as</span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Array.sequenceMap.loop">Array.sequenceMap.loop</a> <span class="fn">as</span> <span class="fn">f</span> (<span class="fn"><a href=".././Init/Prelude.html#Array.size">Array.size</a> <span class="fn">as</span></span>) <span class="fn">0</span> (<span class="fn"><a href=".././Init/Prelude.html#Array.mkEmpty">Array.mkEmpty</a> (<span class="fn"><a href=".././Init/Prelude.html#Array.size">Array.size</a> <span class="fn">as</span></span>)</span>)</span></span></li></ul></details></div></div><div class="decl" id="Array.sequenceMap.loop"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2711-L2717">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Array.sequenceMap.loop">Array.sequenceMap.loop</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Type v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type v</span> → <span class="fn">Type w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(as : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(j : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(bs : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">β</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> (<span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <span class="fn">β</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="MonadLift"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2728-L2730">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadLift">MonadLift</a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max (u + 1) v) w)</span></div></div><ul class="structure_fields" id="MonadLift.mk"><li id="MonadLift.monadLift" class="structure_field"><div class="structure_field_doc"><p>Lifts a value from monad <code>m</code> into monad <code>n</code>.</p></div><div class="structure_field_info">monadLift : <span class="fn">{<span class="fn">α</span> : <span class="fn">Type u</span>} → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></span></div></li></ul><p>A function for lifting a computation from an inner <code><a href=".././Init/Prelude.html#Monad">Monad</a></code> to an outer <code><a href=".././Init/Prelude.html#Monad">Monad</a></code>.
Like Haskell's <a href="https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html"><code>MonadTrans</code></a>, but <code>n</code> does not have to be a monad transformer.
Alternatively, an implementation of <a href="https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLayer"><code>MonadLayer</code></a> without <code>layerInvmap</code> (so far).</p><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadLift" class="instances-list"></ul></details></div></div><div class="decl" id="MonadLiftT"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2739-L2741">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadLiftT">MonadLiftT</a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max (u + 1) v) w)</span></div></div><ul class="structure_fields" id="MonadLiftT.mk"><li id="MonadLiftT.monadLift" class="structure_field"><div class="structure_field_doc"><p>Lifts a value from monad <code>m</code> into monad <code>n</code>.</p></div><div class="structure_field_info">monadLift : <span class="fn">{<span class="fn">α</span> : <span class="fn">Type u</span>} → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></span></div></li></ul><p>The reflexive-transitive closure of <code><a href=".././Init/Prelude.html#MonadLift">MonadLift</a></code>. <code>monadLift</code> is used to
transitively lift monadic computations such as <code><a href=".././Init/Control/State.html#StateT.get">StateT.get</a></code> or <code>StateT.put s</code>.
Corresponds to Haskell's <a href="https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLift"><code>MonadLift</code></a>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadLiftT" class="instances-list"></ul></details></div></div><div class="decl" id="liftM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2746-L2746">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#liftM">liftM</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u_1</span> → <span class="fn">Type u_2</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <span class="fn"><span class="fn">Type u_1</span> → <span class="fn">Type u_3</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[self : <span class="fn"><a href=".././Init/Prelude.html#MonadLiftT">MonadLiftT</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></div></div><p>Lifts a value from monad <code>m</code> into monad <code>n</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#liftM">@<a href=".././Init/Prelude.html#liftM">liftM</a></a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#MonadLiftT.monadLift">@<a href=".././Init/Prelude.html#MonadLiftT.monadLift">monadLift</a></a></span></li></ul></details></div></div><div class="decl" id="instMonadLiftT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2748-L2749">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadLiftT">instMonadLiftT</a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u_1</span> → <span class="fn">Type u_2</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <span class="fn"><span class="fn">Type u_1</span> → <span class="fn">Type u_3</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(o : <span class="fn"><span class="fn">Type u_1</span> → <span class="fn">Type u_4</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadLift">MonadLift</a> <span class="fn">n</span> <span class="fn">o</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadLiftT">MonadLiftT</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadLiftT">MonadLiftT</a> <span class="fn">m</span> <span class="fn">o</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instMonadLiftT">instMonadLiftT</a> <span class="fn">m</span> <span class="fn">n</span> <span class="fn">o</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">monadLift</span> := <span class="fn">fun {<span class="fn">α</span>} <span class="fn">x</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#MonadLift.monadLift">MonadLift.monadLift</a> (<span class="fn"><a href=".././Init/Prelude.html#MonadLiftT.monadLift">monadLift</a> <span class="fn">x</span></span>)</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instMonadLiftT_1"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2751-L2752">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadLiftT_1">instMonadLiftT_1</a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u_1</span> → <span class="fn">Type u_2</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadLiftT">MonadLiftT</a> <span class="fn">m</span> <span class="fn">m</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instMonadLiftT_1">instMonadLiftT_1</a> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">monadLift</span> := <span class="fn">fun {<span class="fn">α</span>} <span class="fn">x</span> =&gt <span class="fn">x</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="MonadFunctor"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2762-L2765">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max (u + 1) v) w)</span></div></div><ul class="structure_fields" id="MonadFunctor.mk"><li id="MonadFunctor.monadMap" class="structure_field"><div class="structure_field_doc"><p>Lifts a monad morphism <code>f : {β : Type u} → m β → m β</code> to
<code>monadMap f : {α : Type u} → n α → n α</code>.</p></div><div class="structure_field_info">monadMap : <span class="fn">{<span class="fn">α</span> : <span class="fn">Type u</span>} → <span class="fn">(<span class="fn">{<span class="fn">β</span> : <span class="fn">Type u</span>} → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">β</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span></span>) → <span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></span></span></div></li></ul><p>A functor in the category of monads. Can be used to lift monad-transforming functions.
Based on <a href="https://hackage.haskell.org/package/pipes-2.4.0/docs/Control-MFunctor.html"><code>MFunctor</code></a> from the <code>pipes</code> Haskell package, but not restricted to
monad transformers. Alternatively, an implementation of <a href="http://duairc.netsoc.ie/layers-docs/Control-Monad-Layer.html#t:MonadTransFunctor"><code>MonadTransFunctor</code></a>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadFunctor" class="instances-list"></ul></details></div></div><div class="decl" id="MonadFunctorT"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2769-L2772">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadFunctorT">MonadFunctorT</a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max (u + 1) v) w)</span></div></div><ul class="structure_fields" id="MonadFunctorT.mk"><li id="MonadFunctorT.monadMap" class="structure_field"><div class="structure_field_doc"><p>Lifts a monad morphism <code>f : {β : Type u} → m β → m β</code> to
<code>monadMap f : {α : Type u} → n α → n α</code>.</p></div><div class="structure_field_info">monadMap : <span class="fn">{<span class="fn">α</span> : <span class="fn">Type u</span>} → <span class="fn">(<span class="fn">{<span class="fn">β</span> : <span class="fn">Type u</span>} → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">β</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">β</span></span></span></span>) → <span class="fn"><span class="fn"><span class="fn">n</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">n</span> <span class="fn">α</span></span></span></span></span></div></li></ul><p>The reflexive-transitive closure of <code><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a></code>.
<code>monadMap</code> is used to transitively lift <code><a href=".././Init/Prelude.html#Monad">Monad</a></code> morphisms.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadFunctorT" class="instances-list"></ul></details></div></div><div class="decl" id="instMonadFunctorT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2776-L2777">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadFunctorT">instMonadFunctorT</a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u_1</span> → <span class="fn">Type u_2</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <span class="fn"><span class="fn">Type u_1</span> → <span class="fn">Type u_3</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(o : <span class="fn"><span class="fn">Type u_1</span> → <span class="fn">Type u_4</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a> <span class="fn">n</span> <span class="fn">o</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadFunctorT">MonadFunctorT</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadFunctorT">MonadFunctorT</a> <span class="fn">m</span> <span class="fn">o</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instMonadFunctorT">instMonadFunctorT</a> <span class="fn">m</span> <span class="fn">n</span> <span class="fn">o</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">monadMap</span> := <span class="fn">fun {<span class="fn">α</span>} <span class="fn">f</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#MonadFunctor.monadMap">MonadFunctor.monadMap</a> <span class="fn">fun {<span class="fn">β</span>} =&gt <span class="fn"><a href=".././Init/Prelude.html#MonadFunctorT.monadMap">monadMap</a> <span class="fn">fun {<span class="fn">β</span>} =&gt <span class="fn"><span class="fn">f</span> <span class="fn">β</span></span></span></span></span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="monadFunctorRefl"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2779-L2780">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#monadFunctorRefl">monadFunctorRefl</a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u_1</span> → <span class="fn">Type u_2</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadFunctorT">MonadFunctorT</a> <span class="fn">m</span> <span class="fn">m</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#monadFunctorRefl">monadFunctorRefl</a> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">monadMap</span> := <span class="fn">fun {<span class="fn">α</span>} <span class="fn">f</span> =&gt <span class="fn"><span class="fn">f</span> <span class="fn">α</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Except"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2788-L2792">source</a></div><div class="attributes">@[unbox]</div>
<div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Except">Except</a></span><span class="decl_args">
<span class="fn">(ε : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn">Type v</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max u v)</span></div></div><ul class="constructors"><li class="constructor" id="Except.error"><div class="inductive_ctor_doc"><p>A failure value of type <code>ε</code></p></div>error: <span class="fn">{<span class="fn">ε</span> : <span class="fn">Type u</span>} → <span class="fn">{<span class="fn">α</span> : <span class="fn">Type v</span>} → <span class="fn"><span class="fn">ε</span> → <span class="fn"><a href=".././Init/Prelude.html#Except">Except</a> <span class="fn">ε</span> <span class="fn">α</span></span></span></span></span></li><li class="constructor" id="Except.ok"><div class="inductive_ctor_doc"><p>A success value of type <code>α</code></p></div>ok: <span class="fn">{<span class="fn">ε</span> : <span class="fn">Type u</span>} → <span class="fn">{<span class="fn">α</span> : <span class="fn">Type v</span>} → <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Prelude.html#Except">Except</a> <span class="fn">ε</span> <span class="fn">α</span></span></span></span></span></li></ul><p><code><a href=".././Init/Prelude.html#Except">Except</a> ε α</code> is a type which represents either an error of type <code>ε</code>, or an "ok"
value of type <code>α</code>. The error type is listed first because
<code><a href=".././Init/Prelude.html#Except">Except</a> ε : Type → Type</code> is a <code><a href=".././Init/Prelude.html#Monad">Monad</a></code>: the pure operation is <code>ok</code> and the bind
operation returns the first encountered <code>error</code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Except" class="instances-for-list"></ul></details></div></div><div class="decl" id="instInhabitedExcept"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2796-L2797">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedExcept">instInhabitedExcept</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type v</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">ε</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><a href=".././Init/Prelude.html#Except">Except</a> <span class="fn">ε</span> <span class="fn">α</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instInhabitedExcept</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#Except.error">Except.error</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="MonadExceptOf"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2814-L2821">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadExceptOf">MonadExceptOf</a></span><span class="decl_args">
<span class="fn">(ε : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type v</span> → <span class="fn">Type w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u (v + 1)) w)</span></div></div><ul class="structure_fields" id="MonadExceptOf.mk"><li id="MonadExceptOf.throw" class="structure_field"><div class="structure_field_doc"><p><code><a href=".././Init/Prelude.html#EStateM.throw">throw</a> : ε → m α</code> "throws an error" of type <code>ε</code> to the nearest enclosing
catch block.</p></div><div class="structure_field_info">throw : <span class="fn">{<span class="fn">α</span> : <span class="fn">Type v</span>} → <span class="fn"><span class="fn">ε</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></span></div></li><li id="MonadExceptOf.tryCatch" class="structure_field"><div class="structure_field_doc"><p><code><a href=".././Init/Prelude.html#EStateM.tryCatch">tryCatch</a> (body : m α) (handler : ε → m α) : m α</code> will catch any errors in
<code>body</code> and pass the resulting error to <code>handler</code>.
Errors in <code>handler</code> will not be caught.</p></div><div class="structure_field_info">tryCatch : <span class="fn">{<span class="fn">α</span> : <span class="fn">Type v</span>} → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn">(<span class="fn"><span class="fn">ε</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span>) → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></span></span></div></li></ul><p>An implementation of Haskell's <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html#t:MonadError"><code>MonadError</code></a> class. A <code>MonadError ε m</code> is a
monad <code>m</code> with two operations:</p><ul>
<li><code><a href=".././Init/Prelude.html#EStateM.throw">throw</a> : ε → m α</code> "throws an error" of type <code>ε</code> to the nearest enclosing
catch block</li>
<li><code><a href=".././Init/Prelude.html#EStateM.tryCatch">tryCatch</a> (body : m α) (handler : ε → m α) : m α</code> will catch any errors in
<code>body</code> and pass the resulting error to <code>handler</code>.
Errors in <code>handler</code> will not be caught.</li>
</ul><p>The <code>try ... catch e => ...</code> syntax inside <code>do</code> blocks is sugar for the
<code><a href=".././Init/Prelude.html#EStateM.tryCatch">tryCatch</a></code> operation.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadExceptOf" class="instances-list"></ul></details></div></div><div class="decl" id="throwThe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2827-L2828">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#throwThe">throwThe</a></span><span class="decl_args">
<span class="fn">(ε : <span class="fn">Type u</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type v</span> → <span class="fn">Type w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadExceptOf">MonadExceptOf</a> <span class="fn">ε</span> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn">ε</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><p>This is the same as <code><a href=".././Init/Prelude.html#EStateM.throw">throw</a></code>, but allows specifying the particular error type
in case the monad supports throwing more than one type of error.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#throwThe">throwThe</a> <span class="fn">ε</span> <span class="fn">e</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadExceptOf.throw">MonadExceptOf.throw</a> <span class="fn">e</span></span></span></li></ul></details></div></div><div class="decl" id="tryCatchThe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2834-L2835">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#tryCatchThe">tryCatchThe</a></span><span class="decl_args">
<span class="fn">(ε : <span class="fn">Type u</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type v</span> → <span class="fn">Type w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadExceptOf">MonadExceptOf</a> <span class="fn">ε</span> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(handle : <span class="fn"><span class="fn">ε</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><p>This is the same as <code><a href=".././Init/Prelude.html#EStateM.tryCatch">tryCatch</a></code>, but allows specifying the particular error type
in case the monad supports throwing more than one type of error.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#tryCatchThe">tryCatchThe</a> <span class="fn">ε</span> <span class="fn">x</span> <span class="fn">handle</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadExceptOf.tryCatch">MonadExceptOf.tryCatch</a> <span class="fn">x</span> <span class="fn">handle</span></span></span></li></ul></details></div></div><div class="decl" id="MonadExcept"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2838-L2845">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadExcept">MonadExcept</a></span><span class="decl_args">
<span class="fn">(ε : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type u</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type v</span> → <span class="fn">Type w</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (max u (v + 1)) w)</span></div></div><ul class="structure_fields" id="MonadExcept.mk"><li id="MonadExcept.throw" class="structure_field"><div class="structure_field_doc"><p><code><a href=".././Init/Prelude.html#EStateM.throw">throw</a> : ε → m α</code> "throws an error" of type <code>ε</code> to the nearest enclosing
catch block.</p></div><div class="structure_field_info">throw : <span class="fn">{<span class="fn">α</span> : <span class="fn">Type v</span>} → <span class="fn"><span class="fn">ε</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></span></div></li><li id="MonadExcept.tryCatch" class="structure_field"><div class="structure_field_doc"><p><code><a href=".././Init/Prelude.html#EStateM.tryCatch">tryCatch</a> (body : m α) (handler : ε → m α) : m α</code> will catch any errors in
<code>body</code> and pass the resulting error to <code>handler</code>.
Errors in <code>handler</code> will not be caught.</p></div><div class="structure_field_info">tryCatch : <span class="fn">{<span class="fn">α</span> : <span class="fn">Type v</span>} → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn">(<span class="fn"><span class="fn">ε</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span>) → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></span></span></div></li></ul><p>Similar to <code><a href=".././Init/Prelude.html#MonadExceptOf">MonadExceptOf</a></code>, but <code>ε</code> is an <code><a href=".././Init/Prelude.html#outParam">outParam</a></code> for convenience.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadExcept" class="instances-list"></ul></details></div></div><div class="decl" id="MonadExcept.ofExcept"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2848-L2850">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadExcept.ofExcept">MonadExcept.ofExcept</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u_1</span> → <span class="fn">Type u_2</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u_3</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadExcept">MonadExcept</a> <span class="fn">ε</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Except">Except</a> <span class="fn">ε</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></div></div><p>"Unwraps" an <code><a href=".././Init/Prelude.html#Except">Except</a> ε α</code> to get the <code>α</code>, or throws the exception otherwise.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#MonadExcept.ofExcept">ofExcept</a> <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">_fun_discr</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Except.error">Except.ok</a> <span class="fn">a</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">a</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#Except.error">Except.error</a> <span class="fn">e</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#MonadExcept.throw">throw</a> <span class="fn">e</span></span></span></span></li></ul></details></div></div><div class="decl" id="instMonadExcept"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2854-L2856">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadExcept">instMonadExcept</a></span><span class="decl_args">
<span class="fn">(ε : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type u</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type v</span> → <span class="fn">Type w</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadExceptOf">MonadExceptOf</a> <span class="fn">ε</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadExcept">MonadExcept</a> <span class="fn">ε</span> <span class="fn">m</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instMonadExcept">instMonadExcept</a> <span class="fn">ε</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">throw</span> := <span class="fn">fun {<span class="fn">α</span>} =&gt <span class="fn"><a href=".././Init/Prelude.html#throwThe">throwThe</a> <span class="fn">ε</span></span></span>, <span class="fn">tryCatch</span> := <span class="fn">fun {<span class="fn">α</span>} =&gt <span class="fn"><a href=".././Init/Prelude.html#tryCatchThe">tryCatchThe</a> <span class="fn">ε</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="MonadExcept.orElse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2862-L2863">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadExcept.orElse">MonadExcept.orElse</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type v</span> → <span class="fn">Type w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadExcept">MonadExcept</a> <span class="fn">ε</span> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type v</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(t₁ : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(t₂ : <span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><p>A <code><a href=".././Init/Prelude.html#MonadExcept">MonadExcept</a></code> can implement <code>t₁ <|> t₂</code> as <code>try t₁ catch _ => t₂</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#MonadExcept.orElse">MonadExcept.orElse</a> <span class="fn">t₁</span> <span class="fn">t₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadExcept.tryCatch">tryCatch</a> <span class="fn">t₁</span> <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn"><span class="fn">t₂</span> <a href=".././Init/Prelude.html#Unit.unit">()</a></span></span></span></span></li></ul></details></div></div><div class="decl" id="MonadExcept.instOrElse"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2865-L2866">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadExcept.instOrElse">MonadExcept.instOrElse</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type v</span> → <span class="fn">Type w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadExcept">MonadExcept</a> <span class="fn">ε</span> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type v</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#OrElse">OrElse</a> (<span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">MonadExcept.instOrElse</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">orElse</span> := <span class="fn">MonadExcept.orElse</span> }</span></span></li></ul></details></div></div><div class="decl" id="ReaderT"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2876-L2877">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT">ReaderT</a></span><span class="decl_args">
<span class="fn">(ρ : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max u v)</span></div></div><p>An implementation of Haskell's <a href="https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT"><code>ReaderT</code></a>. This is a monad transformer which
equips a monad with additional read-only state, of type <code>ρ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">ρ</span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span>)</span></li></ul></details></div></div><div class="decl" id="instInhabitedReaderT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2879-L2880">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instInhabitedReaderT">instInhabitedReaderT</a></span><span class="decl_args">
<span class="fn">(ρ : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">α</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instInhabitedReaderT">instInhabitedReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">fun <span class="fn">x</span> =&gt <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="ReaderT.run"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2886-L2887">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.run">ReaderT.run</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(r : <span class="fn">ρ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><p>If <code>x : <a href=".././Init/Prelude.html#ReaderT">ReaderT</a> ρ m α</code> and <code>r : ρ</code>, then <code>x.<a href=".././Init/Prelude.html#ReaderT.run">run</a> r : ρ</code> runs the monad with the
given reader state.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#ReaderT.run">ReaderT.run</a> <span class="fn">x</span> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <span class="fn">r</span></span></span></li></ul></details></div></div><div class="decl" id="ReaderT.instMonadLiftReaderT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2894-L2895">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.instMonadLiftReaderT">ReaderT.instMonadLiftReaderT</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadLift">MonadLift</a> <span class="fn">m</span> (<span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">ReaderT.instMonadLiftReaderT</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">monadLift</span> := <span class="fn">fun {<span class="fn">α</span>} <span class="fn">x</span> <span class="fn">x_1</span> =&gt <span class="fn">x</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="ReaderT.instMonadExceptOfReaderT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2897-L2899">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.instMonadExceptOfReaderT">ReaderT.instMonadExceptOfReaderT</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="decl_args">
<span class="fn">(ε : <span class="fn">Type u_1</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadExceptOf">MonadExceptOf</a> <span class="fn">ε</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadExceptOf">MonadExceptOf</a> <span class="fn">ε</span> (<span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#ReaderT.instMonadExceptOfReaderT">ReaderT.instMonadExceptOfReaderT</a> <span class="fn">ε</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">throw</span> := <span class="fn">fun {<span class="fn">α</span>} <span class="fn">e</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#liftM">liftM</a> (<span class="fn"><a href=".././Init/Prelude.html#MonadExcept.throw">throw</a> <span class="fn">e</span></span>)</span></span>, <span class="fn">tryCatch</span> := <span class="fn">fun {<span class="fn">α</span>} <span class="fn">x</span> <span class="fn">c</span> <span class="fn">r</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#tryCatchThe">tryCatchThe</a> <span class="fn">ε</span> (<span class="fn"><span class="fn">x</span> <span class="fn">r</span></span>) <span class="fn">fun <span class="fn">e</span> =&gt <span class="fn"><span class="fn">c</span> <span class="fn">e</span> <span class="fn">r</span></span></span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="ReaderT.read"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2907-L2908">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.read">ReaderT.read</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">ρ</span></span></div></div><p><code>(← read) : ρ</code> gets the read-only state of a <code><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> ρ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">ReaderT.read</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">pure</span></span></li></ul></details></div></div><div class="decl" id="ReaderT.pure"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2911-L2912">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.pure">ReaderT.pure</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">α</span></span></div></div><p>The <code><a href=".././Init/Prelude.html#ReaderT.pure">pure</a></code> operation of the <code><a href=".././Init/Prelude.html#ReaderT">ReaderT</a></code> monad.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#ReaderT.pure">ReaderT.pure</a> <span class="fn">a</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">a</span></span></span></li></ul></details></div></div><div class="decl" id="ReaderT.bind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2915-L2916">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.bind">ReaderT.bind</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">β</span></span></div></div><p>The <code><a href=".././Init/Prelude.html#ReaderT.bind">bind</a></code> operation of the <code><a href=".././Init/Prelude.html#ReaderT">ReaderT</a></code> monad.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#ReaderT.bind">ReaderT.bind</a> <span class="fn">x</span> <span class="fn">f</span> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let a ← <span class="fn"><span class="fn">x</span> <span class="fn">r</span></span>
  <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">r</span></span></span></span></li></ul></details></div></div><div class="decl" id="ReaderT.instFunctorReaderT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2918-L2920">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.instFunctorReaderT">ReaderT.instFunctorReaderT</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Functor">Functor</a> (<span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">ReaderT.instFunctorReaderT</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">map</span> := <span class="fn">fun {<span class="fn">α </span>β} <span class="fn">f</span> <span class="fn">x</span> <span class="fn">r</span> =&gt <span class="fn"><span class="fn">f</span> <a href=".././Init/Prelude.html#Functor.map">&lt$&gt</a> <span class="fn"><span class="fn">x</span> <span class="fn">r</span></span></span></span>, <span class="fn">mapConst</span> := <span class="fn">fun {<span class="fn">α </span>β} <span class="fn">a</span> <span class="fn">x</span> <span class="fn">r</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Functor.mapConst">Functor.mapConst</a> <span class="fn">a</span> (<span class="fn"><span class="fn">x</span> <span class="fn">r</span></span>)</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="ReaderT.instApplicativeReaderT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2922-L2926">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.instApplicativeReaderT">ReaderT.instApplicativeReaderT</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Applicative">Applicative</a> (<span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">ReaderT.instApplicativeReaderT</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">Applicative.mk</span></span></li></ul></details></div></div><div class="decl" id="ReaderT.instMonadReaderT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2928-L2929">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.instMonadReaderT">ReaderT.instMonadReaderT</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> (<span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">ReaderT.instMonadReaderT</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">Monad.mk</span></span></li></ul></details></div></div><div class="decl" id="ReaderT.instMonadFunctorReaderT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2931-L2932">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.instMonadFunctorReaderT">ReaderT.instMonadFunctorReaderT</a></span><span class="decl_args">
<span class="fn">(ρ : <span class="fn">Type u_1</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u_1</span> → <span class="fn">Type u_2</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a> <span class="fn">m</span> (<span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#ReaderT.instMonadFunctorReaderT">ReaderT.instMonadFunctorReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">monadMap</span> := <span class="fn">fun {<span class="fn">α</span>} <span class="fn">f</span> <span class="fn">x</span> <span class="fn">ctx</span> =&gt <span class="fn"><span class="fn">f</span> <span class="fn">α</span> (<span class="fn"><span class="fn">x</span> <span class="fn">ctx</span></span>)</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="ReaderT.adapt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2938-L2939">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#ReaderT.adapt">ReaderT.adapt</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ' : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">ρ'</span> → <span class="fn">ρ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ'</span> <span class="fn">m</span> <span class="fn">α</span></span></span></div></div><p><code><a href=".././Init/Prelude.html#ReaderT.adapt">adapt</a> (f : ρ' → ρ)</code> precomposes function <code>f</code> on the reader state of a
<code><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> ρ</code>, yielding a <code><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> ρ'</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#ReaderT.adapt">ReaderT.adapt</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">r</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> (<span class="fn"><span class="fn">f</span> <span class="fn">r</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="MonadReaderOf"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2957-L2959">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadReaderOf">MonadReaderOf</a></span><span class="decl_args">
<span class="fn">(ρ : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type v</span></div></div><ul class="structure_fields" id="MonadReaderOf.mk"><li id="MonadReaderOf.read" class="structure_field"><div class="structure_field_doc"><p><code>(← read) : ρ</code> reads the state out of monad <code>m</code>.</p></div><div class="structure_field_info">read : <span class="fn"><span class="fn">m</span> <span class="fn">ρ</span></span></div></li></ul><p>An implementation of <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader"><code>MonadReader</code></a>. It does not contain <code>local</code> because this
function cannot be lifted using <code>monadLift</code>. Instead, the <code>MonadReaderAdapter</code>
class provides the more general <code>adaptReader</code> function.</p><p>Note: This class can be seen as a simplification of the more "principled" definition</p><pre><code>class <a href=".././Init/Prelude.html#MonadReaderOf">MonadReaderOf</a> (ρ : Type u) (n : Type u → Type u) where
  lift {α : Type u} : ({m : Type u → Type u} → [Monad m] → <a href=".././Init/Prelude.html#ReaderT">ReaderT</a> ρ m α) → n α
</code></pre><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadReaderOf" class="instances-list"></ul></details></div></div><div class="decl" id="readThe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2965-L2966">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#readThe">readThe</a></span><span class="decl_args">
<span class="fn">(ρ : <span class="fn">Type u</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadReaderOf">MonadReaderOf</a> <span class="fn">ρ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">ρ</span></span></div></div><p>Like <code><a href=".././Init/Prelude.html#ReaderT.read">read</a></code>, but with <code>ρ</code> explicit. This is useful if a monad supports
<code><a href=".././Init/Prelude.html#MonadReaderOf">MonadReaderOf</a></code> for multiple different types <code>ρ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#readThe">readThe</a> <span class="fn">ρ</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">MonadReaderOf.read</span></span></li></ul></details></div></div><div class="decl" id="MonadReader"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2969-L2971">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadReader">MonadReader</a></span><span class="decl_args">
<span class="fn">(ρ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type u</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type v</span></div></div><ul class="structure_fields" id="MonadReader.mk"><li id="MonadReader.read" class="structure_field"><div class="structure_field_doc"><p><code>(← read) : ρ</code> reads the state out of monad <code>m</code>.</p></div><div class="structure_field_info">read : <span class="fn"><span class="fn">m</span> <span class="fn">ρ</span></span></div></li></ul><p>Similar to <code><a href=".././Init/Prelude.html#MonadReaderOf">MonadReaderOf</a></code>, but <code>ρ</code> is an <code><a href=".././Init/Prelude.html#outParam">outParam</a></code> for convenience.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadReader" class="instances-list"></ul></details></div></div><div class="decl" id="instMonadReader"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2975-L2976">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadReader">instMonadReader</a></span><span class="decl_args">
<span class="fn">(ρ : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadReaderOf">MonadReaderOf</a> <span class="fn">ρ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadReader">MonadReader</a> <span class="fn">ρ</span> <span class="fn">m</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instMonadReader">instMonadReader</a> <span class="fn">ρ</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">read</span> := <span class="fn"><a href=".././Init/Prelude.html#readThe">readThe</a> <span class="fn">ρ</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instMonadReaderOf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2978-L2979">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadReaderOf">instMonadReaderOf</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadLift">MonadLift</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadReaderOf">MonadReaderOf</a> <span class="fn">ρ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadReaderOf">MonadReaderOf</a> <span class="fn">ρ</span> <span class="fn">n</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instMonadReaderOf</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">read</span> := <span class="fn"><a href=".././Init/Prelude.html#liftM">liftM</a> <span class="fn">read</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instMonadReaderOfReaderT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2981-L2982">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadReaderOfReaderT">instMonadReaderOfReaderT</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadReaderOf">MonadReaderOf</a> <span class="fn">ρ</span> (<span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instMonadReaderOfReaderT</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">read</span> := <span class="fn">ReaderT.read</span> }</span></span></li></ul></details></div></div><div class="decl" id="MonadWithReaderOf"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L2991-L2994">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadWithReaderOf">MonadWithReaderOf</a></span><span class="decl_args">
<span class="fn">(ρ : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (u + 1) v)</span></div></div><ul class="structure_fields" id="MonadWithReaderOf.mk"><li id="MonadWithReaderOf.withReader" class="structure_field"><div class="structure_field_doc"><p><code>withReader (f : ρ → ρ) (x : m α) : m α</code>  runs the inner <code>x : m α</code> inside
a modified context after applying the function <code>f : ρ → ρ</code>.</p></div><div class="structure_field_info">withReader : <span class="fn">{<span class="fn">α</span> : <span class="fn">Type u</span>} → <span class="fn">(<span class="fn"><span class="fn">ρ</span> → <span class="fn">ρ</span></span>) → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></span></span></div></li></ul><p><code><a href=".././Init/Prelude.html#MonadWithReaderOf">MonadWithReaderOf</a> ρ</code> adds the operation <code>withReader : (ρ → ρ) → m α → m α</code>.
This runs the inner <code>x : m α</code> inside a modified context after applying the
function <code>f : ρ → ρ</code>. In addition to <code><a href=".././Init/Prelude.html#ReaderT">ReaderT</a></code> itself, this operation lifts
over most monad transformers, so it allows us to apply <code>withReader</code> to monads
deeper in the stack.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadWithReaderOf" class="instances-list"></ul></details></div></div><div class="decl" id="withTheReader"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3000-L3001">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#withTheReader">withTheReader</a></span><span class="decl_args">
<span class="fn">(ρ : <span class="fn">Type u</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadWithReaderOf">MonadWithReaderOf</a> <span class="fn">ρ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">ρ</span> → <span class="fn">ρ</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><p>Like <code>withReader</code>, but with <code>ρ</code> explicit. This is useful if a monad supports
<code><a href=".././Init/Prelude.html#MonadWithReaderOf">MonadWithReaderOf</a></code> for multiple different types <code>ρ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#withTheReader">withTheReader</a> <span class="fn">ρ</span> <span class="fn">f</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadWithReaderOf.withReader">MonadWithReaderOf.withReader</a> <span class="fn">f</span> <span class="fn">x</span></span></span></li></ul></details></div></div><div class="decl" id="MonadWithReader"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3004-L3007">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadWithReader">MonadWithReader</a></span><span class="decl_args">
<span class="fn">(ρ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type u</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (u + 1) v)</span></div></div><ul class="structure_fields" id="MonadWithReader.mk"><li id="MonadWithReader.withReader" class="structure_field"><div class="structure_field_doc"><p><code>withReader (f : ρ → ρ) (x : m α) : m α</code>  runs the inner <code>x : m α</code> inside
a modified context after applying the function <code>f : ρ → ρ</code>.</p></div><div class="structure_field_info">withReader : <span class="fn">{<span class="fn">α</span> : <span class="fn">Type u</span>} → <span class="fn">(<span class="fn"><span class="fn">ρ</span> → <span class="fn">ρ</span></span>) → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></span></span></div></li></ul><p>Similar to <code><a href=".././Init/Prelude.html#MonadWithReaderOf">MonadWithReaderOf</a></code>, but <code>ρ</code> is an <code><a href=".././Init/Prelude.html#outParam">outParam</a></code> for convenience.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadWithReader" class="instances-list"></ul></details></div></div><div class="decl" id="instMonadWithReader"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3011-L3012">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadWithReader">instMonadWithReader</a></span><span class="decl_args">
<span class="fn">(ρ : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadWithReaderOf">MonadWithReaderOf</a> <span class="fn">ρ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadWithReader">MonadWithReader</a> <span class="fn">ρ</span> <span class="fn">m</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instMonadWithReader">instMonadWithReader</a> <span class="fn">ρ</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">withReader</span> := <span class="fn">fun {<span class="fn">α</span>} =&gt <span class="fn"><a href=".././Init/Prelude.html#withTheReader">withTheReader</a> <span class="fn">ρ</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instMonadWithReaderOf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3014-L3015">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadWithReaderOf">instMonadWithReaderOf</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadWithReaderOf">MonadWithReaderOf</a> <span class="fn">ρ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadWithReaderOf">MonadWithReaderOf</a> <span class="fn">ρ</span> <span class="fn">n</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instMonadWithReaderOf</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">withReader</span> := <span class="fn">fun {<span class="fn">α</span>} <span class="fn">f</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#MonadFunctorT.monadMap">monadMap</a> <span class="fn">fun {<span class="fn">β</span>} =&gt <span class="fn"><a href=".././Init/Prelude.html#withTheReader">withTheReader</a> <span class="fn">ρ</span> <span class="fn">f</span></span></span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="instMonadWithReaderOfReaderT"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3017-L3018">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadWithReaderOfReaderT">instMonadWithReaderOfReaderT</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ρ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadWithReaderOf">MonadWithReaderOf</a> <span class="fn">ρ</span> (<span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <span class="fn">ρ</span> <span class="fn">m</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instMonadWithReaderOfReaderT</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">withReader</span> := <span class="fn">fun {<span class="fn">α</span>} <span class="fn">f</span> <span class="fn">x</span> <span class="fn">ctx</span> =&gt <span class="fn"><span class="fn">x</span> (<span class="fn"><span class="fn">f</span> <span class="fn">ctx</span></span>)</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="MonadStateOf"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3026-L3037">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a></span><span class="decl_args">
<span class="fn">(σ : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (u + 1) v)</span></div></div><ul class="structure_fields" id="MonadStateOf.mk"><li id="MonadStateOf.get" class="structure_field"><div class="structure_field_doc"><p><code>(← get) : σ</code> gets the state out of a monad <code>m</code>.</p></div><div class="structure_field_info">get : <span class="fn"><span class="fn">m</span> <span class="fn">σ</span></span></div></li><li id="MonadStateOf.set" class="structure_field"><div class="structure_field_doc"><p><code><a href=".././Init/Prelude.html#List.set">set</a> (s : σ)</code> replaces the state with value <code>s</code>.</p></div><div class="structure_field_info">set : <span class="fn"><span class="fn">σ</span> → <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></span></div></li><li id="MonadStateOf.modifyGet" class="structure_field"><div class="structure_field_doc"><p><code><a href=".././Init/Prelude.html#EStateM.modifyGet">modifyGet</a> (f : σ → α × σ)</code> applies <code>f</code> to the current state, replaces
the state with the return value, and returns a computed value.</p><p>It is equivalent to <code>do let (a, s) := f (← get); put s; <a href=".././Init/Prelude.html#ReaderT.pure">pure</a> a</code>, but
<code><a href=".././Init/Prelude.html#EStateM.modifyGet">modifyGet</a> f</code> may be preferable because the former does not use the state
linearly (without sufficient inlining).</p></div><div class="structure_field_info">modifyGet : <span class="fn">{<span class="fn">α</span> : <span class="fn">Type u</span>} → <span class="fn">(<span class="fn"><span class="fn">σ</span> → <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">σ</span></span></span>) → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></span></div></li></ul><p>An implementation of <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html"><code>MonadState</code></a>. In contrast to the Haskell implementation,
we use overlapping instances to derive instances automatically from <code>monadLift</code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadStateOf" class="instances-list"></ul></details></div></div><div class="decl" id="getThe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3045-L3046">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#getThe">getThe</a></span><span class="decl_args">
<span class="fn">(σ : <span class="fn">Type u</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a> <span class="fn">σ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">σ</span></span></div></div><p>Like <code>withReader</code>, but with <code>ρ</code> explicit. This is useful if a monad supports
<code><a href=".././Init/Prelude.html#MonadWithReaderOf">MonadWithReaderOf</a></code> for multiple different types <code>ρ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#getThe">getThe</a> <span class="fn">σ</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">MonadStateOf.get</span></span></li></ul></details></div></div><div class="decl" id="modifyThe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3052-L3053">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#modifyThe">modifyThe</a></span><span class="decl_args">
<span class="fn">(σ : <span class="fn">Type u</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a> <span class="fn">σ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">σ</span> → <span class="fn">σ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div><p>Like <code><a href=".././Init/Prelude.html#modify">modify</a></code>, but with <code>σ</code> explicit. This is useful if a monad supports
<code><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a></code> for multiple different types <code>σ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#modifyThe">modifyThe</a> <span class="fn">σ</span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadStateOf.modifyGet">MonadStateOf.modifyGet</a> <span class="fn">fun <span class="fn">s</span> =&gt <span class="fn">(<a href=".././Init/Prelude.html#PUnit.unit">PUnit.unit</a>, <span class="fn"><span class="fn">f</span> <span class="fn">s</span></span>)</span></span></span></span></li></ul></details></div></div><div class="decl" id="modifyGetThe"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3059-L3060">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#modifyGetThe">modifyGetThe</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(σ : <span class="fn">Type u</span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a> <span class="fn">σ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">σ</span> → <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">σ</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><p>Like <code><a href=".././Init/Prelude.html#EStateM.modifyGet">modifyGet</a></code>, but with <code>σ</code> explicit. This is useful if a monad supports
<code><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a></code> for multiple different types <code>σ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#modifyGetThe">modifyGetThe</a> <span class="fn">σ</span> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadStateOf.modifyGet">MonadStateOf.modifyGet</a> <span class="fn">f</span></span></span></li></ul></details></div></div><div class="decl" id="MonadState"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3063-L3074">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#MonadState">MonadState</a></span><span class="decl_args">
<span class="fn">(σ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type u</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type (max (u + 1) v)</span></div></div><ul class="structure_fields" id="MonadState.mk"><li id="MonadState.get" class="structure_field"><div class="structure_field_doc"><p><code>(← get) : σ</code> gets the state out of a monad <code>m</code>.</p></div><div class="structure_field_info">get : <span class="fn"><span class="fn">m</span> <span class="fn">σ</span></span></div></li><li id="MonadState.set" class="structure_field"><div class="structure_field_doc"><p><code><a href=".././Init/Prelude.html#List.set">set</a> (s : σ)</code> replaces the state with value <code>s</code>.</p></div><div class="structure_field_info">set : <span class="fn"><span class="fn">σ</span> → <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></span></div></li><li id="MonadState.modifyGet" class="structure_field"><div class="structure_field_doc"><p><code><a href=".././Init/Prelude.html#EStateM.modifyGet">modifyGet</a> (f : σ → α × σ)</code> applies <code>f</code> to the current state, replaces
the state with the return value, and returns a computed value.</p><p>It is equivalent to <code>do let (a, s) := f (← get); put s; <a href=".././Init/Prelude.html#ReaderT.pure">pure</a> a</code>, but
<code><a href=".././Init/Prelude.html#EStateM.modifyGet">modifyGet</a> f</code> may be preferable because the former does not use the state
linearly (without sufficient inlining).</p></div><div class="structure_field_info">modifyGet : <span class="fn">{<span class="fn">α</span> : <span class="fn">Type u</span>} → <span class="fn">(<span class="fn"><span class="fn">σ</span> → <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">σ</span></span></span>) → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></span></div></li></ul><p>Similar to <code><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a></code>, but <code>σ</code> is an <code><a href=".././Init/Prelude.html#outParam">outParam</a></code> for convenience.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-MonadState" class="instances-list"></ul></details></div></div><div class="decl" id="instMonadState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3078-L3081">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadState">instMonadState</a></span><span class="decl_args">
<span class="fn">(σ : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a> <span class="fn">σ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadState">MonadState</a> <span class="fn">σ</span> <span class="fn">m</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#instMonadState">instMonadState</a> <span class="fn">σ</span> <span class="fn">m</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">get</span> := <span class="fn"><a href=".././Init/Prelude.html#getThe">getThe</a> <span class="fn">σ</span></span>, <span class="fn">set</span> := <span class="fn">set</span>, <span class="fn">modifyGet</span> := <span class="fn">fun {<span class="fn">α</span>} <span class="fn">f</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#MonadStateOf.modifyGet">MonadStateOf.modifyGet</a> <span class="fn">f</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="modify"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3089-L3090">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#modify">modify</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadState">MonadState</a> <span class="fn">σ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">σ</span> → <span class="fn">σ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div><p><code><a href=".././Init/Prelude.html#modify">modify</a> (f : σ → σ)</code> applies the function <code>f</code> to the state.</p><p>It is equivalent to <code>do put (f (← get))</code>, but <code><a href=".././Init/Prelude.html#modify">modify</a> f</code> may be preferable
because the former does not use the state linearly (without sufficient inlining).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#modify">modify</a> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadState.modifyGet">modifyGet</a> <span class="fn">fun <span class="fn">s</span> =&gt <span class="fn">(<a href=".././Init/Prelude.html#PUnit.unit">PUnit.unit</a>, <span class="fn"><span class="fn">f</span> <span class="fn">s</span></span>)</span></span></span></span></li></ul></details></div></div><div class="decl" id="getModify"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3096-L3097">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#getModify">getModify</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadState">MonadState</a> <span class="fn">σ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">σ</span> → <span class="fn">σ</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">σ</span></span></div></div><p><code><a href=".././Init/Prelude.html#getModify">getModify</a> f</code> gets the state, applies function <code>f</code>, and returns the old value
of the state. It is equivalent to <code><a href=".././Init/Prelude.html#List.get">get</a> <* <a href=".././Init/Prelude.html#modify">modify</a> f</code> but may be more efficient.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#getModify">getModify</a> <span class="fn">f</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadState.modifyGet">modifyGet</a> <span class="fn">fun <span class="fn">s</span> =&gt <span class="fn">(<span class="fn">s</span>, <span class="fn"><span class="fn">f</span> <span class="fn">s</span></span>)</span></span></span></span></li></ul></details></div></div><div class="decl" id="instMonadStateOf"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3101-L3104">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instMonadStateOf">instMonadStateOf</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type v</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <span class="fn"><span class="fn">Type u</span> → <span class="fn">Type w</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadLift">MonadLift</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a> <span class="fn">σ</span> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a> <span class="fn">σ</span> <span class="fn">n</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instMonadStateOf</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">get</span> := <span class="fn"><a href=".././Init/Prelude.html#liftM">liftM</a> <span class="fn">MonadStateOf.get</span></span>, <span class="fn">set</span> := <span class="fn">fun <span class="fn">s</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#liftM">liftM</a> (<span class="fn"><a href=".././Init/Prelude.html#MonadStateOf.set">set</a> <span class="fn">s</span></span>)</span></span>, <span class="fn">modifyGet</span> := <span class="fn">fun {<span class="fn">α</span>} <span class="fn">f</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#MonadLiftT.monadLift">monadLift</a> (<span class="fn"><a href=".././Init/Prelude.html#MonadState.modifyGet">modifyGet</a> <span class="fn">f</span></span>)</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="EStateM.Result"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3112-L3116">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.Result">EStateM.Result</a></span><span class="decl_args">
<span class="fn">(ε : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(σ : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="constructors"><li class="constructor" id="EStateM.Result.ok"><div class="inductive_ctor_doc"><p>A success value of type <code>α</code>, and a new state <code>σ</code>.</p></div>ok: <span class="fn">{<span class="fn">ε </span>σ α : <span class="fn">Type u</span>} → <span class="fn"><span class="fn">α</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result">EStateM.Result</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></span></span></span></li><li class="constructor" id="EStateM.Result.error"><div class="inductive_ctor_doc"><p>A failure value of type <code>ε</code>, and a new state <code>σ</code>.</p></div>error: <span class="fn">{<span class="fn">ε </span>σ α : <span class="fn">Type u</span>} → <span class="fn"><span class="fn">ε</span> → <span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result">EStateM.Result</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></span></span></span></li></ul><p><code><a href=".././Init/Prelude.html#EStateM.Result">Result</a> ε σ α</code> is equivalent to <code><a href=".././Init/Prelude.html#Except">Except</a> ε α × σ</code>, but using a single
combined inductive yields a more efficient data representation.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-EStateM.Result" class="instances-for-list"></ul></details></div></div><div class="decl" id="EStateM.instInhabitedResult"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3120-L3121">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.instInhabitedResult">EStateM.instInhabitedResult</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">ε</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">σ</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><a href=".././Init/Prelude.html#EStateM.Result">EStateM.Result</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">EStateM.instInhabitedResult</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">default</span> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="EStateM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3130-L3130">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM">EStateM</a></span><span class="decl_args">
<span class="fn">(ε : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(σ : <span class="fn">Type u</span>)</span></span>
<span class="decl_args">
<span class="fn">(α : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><p><code><a href=".././Init/Prelude.html#EStateM">EStateM</a> ε σ</code> is a combined error and state monad, equivalent to
<code><a href=".././Init/Control/Except.html#ExceptT">ExceptT</a> ε (StateM σ)</code> but more efficient.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result">EStateM.Result</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></span>)</span></li></ul></details></div></div><div class="decl" id="EStateM.instInhabitedEStateM"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3136-L3137">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.instInhabitedEStateM">EStateM.instInhabitedEStateM</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <span class="fn">ε</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">EStateM.instInhabitedEStateM</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">fun <span class="fn">s</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">default</span> <span class="fn">s</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="EStateM.pure"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3140-L3141">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.pure">EStateM.pure</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(a : <span class="fn">α</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></div></div><p>The <code><a href=".././Init/Prelude.html#ReaderT.pure">pure</a></code> operation of the <code><a href=".././Init/Prelude.html#EStateM">EStateM</a></code> monad.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#EStateM.pure">EStateM.pure</a> <span class="fn">a</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <span class="fn">a</span> <span class="fn">s</span></span></span></li></ul></details></div></div><div class="decl" id="EStateM.set"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3144-L3145">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.set">EStateM.set</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(s : <span class="fn">σ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div><p>The <code><a href=".././Init/Prelude.html#List.set">set</a></code> operation of the <code><a href=".././Init/Prelude.html#EStateM">EStateM</a></code> monad.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#EStateM.set">EStateM.set</a> <span class="fn">s</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <a href=".././Init/Prelude.html#PUnit.unit">PUnit.unit</a> <span class="fn">s</span></span></span></li></ul></details></div></div><div class="decl" id="EStateM.get"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3148-L3149">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.get">EStateM.get</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">σ</span></span></div></div><p>The <code><a href=".././Init/Prelude.html#List.get">get</a></code> operation of the <code><a href=".././Init/Prelude.html#EStateM">EStateM</a></code> monad.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#EStateM.get">EStateM.get</a> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <span class="fn">s</span> <span class="fn">s</span></span></span></li></ul></details></div></div><div class="decl" id="EStateM.modifyGet"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3152-L3154">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.modifyGet">EStateM.modifyGet</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">σ</span> → <span class="fn"><span class="fn">α</span> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn">σ</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></div></div><p>The <code><a href=".././Init/Prelude.html#EStateM.modifyGet">modifyGet</a></code> operation of the <code><a href=".././Init/Prelude.html#EStateM">EStateM</a></code> monad.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#EStateM.modifyGet">EStateM.modifyGet</a> <span class="fn">f</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">f</span> <span class="fn">s</span></span> with
  | <span class="fn">(<span class="fn">a</span>, <span class="fn">s</span>)</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <span class="fn">a</span> <span class="fn">s</span></span></span></span></li></ul></details></div></div><div class="decl" id="EStateM.throw"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3157-L3158">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.throw">EStateM.throw</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(e : <span class="fn">ε</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></div></div><p>The <code><a href=".././Init/Prelude.html#EStateM.throw">throw</a></code> operation of the <code><a href=".././Init/Prelude.html#EStateM">EStateM</a></code> monad.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#EStateM.throw">EStateM.throw</a> <span class="fn">e</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span></span></li></ul></details></div></div><div class="decl" id="EStateM.Backtrackable"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3165-L3170">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.Backtrackable">EStateM.Backtrackable</a></span><span class="decl_args">
<span class="fn">(δ : <span class="fn"><a href=".././Init/Prelude.html#outParam">outParam</a> (<span class="fn">Type u</span>)</span>)</span></span>
<span class="decl_args">
<span class="fn">(σ : <span class="fn">Type u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type u</span></div></div><ul class="structure_fields" id="EStateM.Backtrackable.mk"><li id="EStateM.Backtrackable.save" class="structure_field"><div class="structure_field_doc"><p><code>save s : δ</code> retrieves a copy of the backtracking state out of the state.</p></div><div class="structure_field_info">save : <span class="fn"><span class="fn">σ</span> → <span class="fn">δ</span></span></div></li><li id="EStateM.Backtrackable.restore" class="structure_field"><div class="structure_field_doc"><p><code>restore (s : σ) (x : δ) : σ</code> applies the old backtracking state <code>x</code> to
the state <code>s</code> to get a backtracked state <code>s'</code>.</p></div><div class="structure_field_info">restore : <span class="fn"><span class="fn">σ</span> → <span class="fn"><span class="fn">δ</span> → <span class="fn">σ</span></span></span></div></li></ul><p>Auxiliary instance for saving/restoring the "backtrackable" part of the state.
Here <code>σ</code> is the state, and <code>δ</code> is some subpart of it, and we have a
getter and setter for it (a "lens" in the Haskell terminology).</p><details class="instances"><summary>Instances</summary><ul id="instances-list-EStateM.Backtrackable" class="instances-list"></ul></details></div></div><div class="decl" id="EStateM.tryCatch"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3173-L3177">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.tryCatch">EStateM.tryCatch</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#EStateM.Backtrackable">EStateM.Backtrackable</a> <span class="fn">δ</span> <span class="fn">σ</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(handle : <span class="fn"><span class="fn">ε</span> → <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></div></div><p>Implementation of <code><a href=".././Init/Prelude.html#EStateM.tryCatch">tryCatch</a></code> for <code><a href=".././Init/Prelude.html#EStateM">EStateM</a></code> where the state is <code><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#EStateM.tryCatch">EStateM.tryCatch</a> <span class="fn">x</span> <span class="fn">handle</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">let d := <span class="fn"><a href=".././Init/Prelude.html#EStateM.Backtrackable.save">EStateM.Backtrackable.save</a> <span class="fn">s</span></span>;
  <span class="fn">match <span class="fn"><span class="fn">x</span> <span class="fn">s</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span> =&gt <span class="fn"><span class="fn">handle</span> <span class="fn">e</span> (<span class="fn"><a href=".././Init/Prelude.html#EStateM.Backtrackable.restore">EStateM.Backtrackable.restore</a> <span class="fn">s</span> <span class="fn">d</span></span>)</span>
  | <span class="fn">ok</span> =&gt <span class="fn">ok</span></span></span></span></li></ul></details></div></div><div class="decl" id="EStateM.orElse"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3180-L3184">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.orElse">EStateM.orElse</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#EStateM.Backtrackable">EStateM.Backtrackable</a> <span class="fn">δ</span> <span class="fn">σ</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(x₁ : <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x₂ : <span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></div></div><p>Implementation of <code><a href=".././Init/Prelude.html#MonadExcept.orElse">orElse</a></code> for <code><a href=".././Init/Prelude.html#EStateM">EStateM</a></code> where the state is <code><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#EStateM.orElse">EStateM.orElse</a> <span class="fn">x₁</span> <span class="fn">x₂</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">let d := <span class="fn"><a href=".././Init/Prelude.html#EStateM.Backtrackable.save">EStateM.Backtrackable.save</a> <span class="fn">s</span></span>;
  <span class="fn">match <span class="fn"><span class="fn">x₁</span> <span class="fn">s</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">a</span> <span class="fn">s</span></span> =&gt <span class="fn"><span class="fn">x₂</span> <a href=".././Init/Prelude.html#Unit.unit">()</a> (<span class="fn"><a href=".././Init/Prelude.html#EStateM.Backtrackable.restore">EStateM.Backtrackable.restore</a> <span class="fn">s</span> <span class="fn">d</span></span>)</span>
  | <span class="fn">ok</span> =&gt <span class="fn">ok</span></span></span></span></li></ul></details></div></div><div class="decl" id="EStateM.adaptExcept"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3187-L3190">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.adaptExcept">EStateM.adaptExcept</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε' : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">ε</span> → <span class="fn">ε'</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε'</span> <span class="fn">σ</span> <span class="fn">α</span></span></div></div><p>Map the exception type of a <code><a href=".././Init/Prelude.html#EStateM">EStateM</a> ε σ α</code> by a function <code>f : ε → ε'</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#EStateM.adaptExcept">EStateM.adaptExcept</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">x</span> <span class="fn">s</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> (<span class="fn"><span class="fn">f</span> <span class="fn">e</span></span>) <span class="fn">s</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <span class="fn">a</span> <span class="fn">s</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> <span class="fn">a</span> <span class="fn">s</span></span></span></span></li></ul></details></div></div><div class="decl" id="EStateM.bind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3193-L3196">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.bind">EStateM.bind</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">β</span></span></div></div><p>The <code><a href=".././Init/Prelude.html#ReaderT.bind">bind</a></code> operation of the <code><a href=".././Init/Prelude.html#EStateM">EStateM</a></code> monad.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#EStateM.bind">EStateM.bind</a> <span class="fn">x</span> <span class="fn">f</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">x</span> <span class="fn">s</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.ok</a> <span class="fn">a</span> <span class="fn">s</span></span> =&gt <span class="fn"><span class="fn">f</span> <span class="fn">a</span> <span class="fn">s</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span></span></span></li></ul></details></div></div><div class="decl" id="EStateM.map"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3199-L3202">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.map">EStateM.map</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(f : <span class="fn"><span class="fn">α</span> → <span class="fn">β</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">β</span></span></div></div><p>The <code><a href=".././Init/Prelude.html#Option.map">map</a></code> operation of the <code><a href=".././Init/Prelude.html#EStateM">EStateM</a></code> monad.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#EStateM.map">EStateM.map</a> <span class="fn">f</span> <span class="fn">x</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">x</span> <span class="fn">s</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.ok</a> <span class="fn">a</span> <span class="fn">s</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.ok">EStateM.Result.ok</a> (<span class="fn"><span class="fn">f</span> <span class="fn">a</span></span>) <span class="fn">s</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span></span></span></li></ul></details></div></div><div class="decl" id="EStateM.seqRight"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3205-L3208">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.seqRight">EStateM.seqRight</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{β : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(y : <span class="fn"><a href=".././Init/Prelude.html#Unit">Unit</a> → <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">β</span></span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">β</span></span></div></div><p>The <code><a href=".././Init/Prelude.html#EStateM.seqRight">seqRight</a></code> operation of the <code><a href=".././Init/Prelude.html#EStateM">EStateM</a></code> monad.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#EStateM.seqRight">EStateM.seqRight</a> <span class="fn">x</span> <span class="fn">y</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><span class="fn">x</span> <span class="fn">s</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.ok</a> <span class="fn">a</span> <span class="fn">s</span></span> =&gt <span class="fn"><span class="fn">y</span> <a href=".././Init/Prelude.html#Unit.unit">()</a> <span class="fn">s</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">e</span> <span class="fn">s</span></span></span></span></li></ul></details></div></div><div class="decl" id="EStateM.instMonadEStateM"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3210-L3214">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.instMonadEStateM">EStateM.instMonadEStateM</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> (<span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">EStateM.instMonadEStateM</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">Monad.mk</span></span></li></ul></details></div></div><div class="decl" id="EStateM.instOrElseEStateM"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3216-L3217">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.instOrElseEStateM">EStateM.instOrElseEStateM</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#EStateM.Backtrackable">EStateM.Backtrackable</a> <span class="fn">δ</span> <span class="fn">σ</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#OrElse">OrElse</a> (<span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">EStateM.instOrElseEStateM</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">orElse</span> := <span class="fn">EStateM.orElse</span> }</span></span></li></ul></details></div></div><div class="decl" id="EStateM.instMonadStateOfEStateM"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3219-L3222">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.instMonadStateOfEStateM">EStateM.instMonadStateOfEStateM</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadStateOf">MonadStateOf</a> <span class="fn">σ</span> (<span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">EStateM.instMonadStateOfEStateM</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">get</span> := <span class="fn">EStateM.get</span>, <span class="fn">set</span> := <span class="fn">EStateM.set</span>, <span class="fn">modifyGet</span> := <span class="fn">fun {<span class="fn">α</span>} =&gt <span class="fn">EStateM.modifyGet</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="EStateM.instMonadExceptOfEStateM"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3224-L3226">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.instMonadExceptOfEStateM">EStateM.instMonadExceptOfEStateM</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{δ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#EStateM.Backtrackable">EStateM.Backtrackable</a> <span class="fn">δ</span> <span class="fn">σ</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#MonadExceptOf">MonadExceptOf</a> <span class="fn">ε</span> (<span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">EStateM.instMonadExceptOfEStateM</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">throw</span> := <span class="fn">fun {<span class="fn">α</span>} =&gt <span class="fn">EStateM.throw</span></span>, <span class="fn">tryCatch</span> := <span class="fn">fun {<span class="fn">α</span>} =&gt <span class="fn">EStateM.tryCatch</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="EStateM.run"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3229-L3229">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.run">EStateM.run</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(s : <span class="fn">σ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM.Result">EStateM.Result</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span></div></div><p>Execute an <code><a href=".././Init/Prelude.html#EStateM">EStateM</a></code> on initial state <code>s</code> to get a <code><a href=".././Init/Prelude.html#EStateM.Result">Result</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#EStateM.run">EStateM.run</a> <span class="fn">x</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><span class="fn">x</span> <span class="fn">s</span></span></span></li></ul></details></div></div><div class="decl" id="EStateM.run'"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3235-L3238">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.run'">EStateM.run'</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ε : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <span class="fn">ε</span> <span class="fn">σ</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(s : <span class="fn">σ</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <span class="fn">α</span></span></div></div><p>Execute an <code><a href=".././Init/Prelude.html#EStateM">EStateM</a></code> on initial state <code>s</code> for the returned value <code>α</code>.
If the monadic action throws an exception, returns <code>none</code> instead.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#EStateM.run'">EStateM.run'</a> <span class="fn">x</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href=".././Init/Prelude.html#EStateM.run">EStateM.run</a> <span class="fn">x</span> <span class="fn">s</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.ok</a> <span class="fn">v</span> <span class="fn">a</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">v</span></span>
  | <span class="fn"><a href=".././Init/Prelude.html#EStateM.Result.error">EStateM.Result.error</a> <span class="fn">a</span> <span class="fn">a_1</span></span> =&gt <span class="fn">none</span></span></span></li></ul></details></div></div><div class="decl" id="EStateM.dummySave"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3241-L3241">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.dummySave">EStateM.dummySave</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">σ</span> → <a href=".././Init/Prelude.html#PUnit">PUnit</a></span></div></div><p>The <code>save</code> implementation for <code><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a> σ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#EStateM.dummySave">EStateM.dummySave</a> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#PUnit.unit">PUnit.unit</a></span></li></ul></details></div></div><div class="decl" id="EStateM.dummyRestore"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3244-L3244">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.dummyRestore">EStateM.dummyRestore</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">σ</span> → <span class="fn"><a href=".././Init/Prelude.html#PUnit">PUnit</a> → <span class="fn">σ</span></span></span></div></div><p>The <code>restore</code> implementation for <code><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a> σ</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#EStateM.dummyRestore">EStateM.dummyRestore</a> <span class="fn">s</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">s</span></span></li></ul></details></div></div><div class="decl" id="EStateM.nonBacktrackable"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3252-L3254">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#EStateM.nonBacktrackable">EStateM.nonBacktrackable</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{σ : <span class="fn">Type u</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#EStateM.Backtrackable">EStateM.Backtrackable</a> <a href=".././Init/Prelude.html#PUnit">PUnit</a> <span class="fn">σ</span></span></div></div><p>Dummy default instance. This makes every <code>σ</code> trivially "backtrackable"
by doing nothing on backtrack. Because this is the first declared instance
of <code><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a> _ σ</code>, it will be picked only if there are no other
<code><a href=".././Init/Prelude.html#EStateM.Backtrackable">Backtrackable</a> _ σ</code> instances registered.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">EStateM.nonBacktrackable</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">save</span> := <span class="fn">EStateM.dummySave</span>, <span class="fn">restore</span> := <span class="fn">EStateM.dummyRestore</span> }</span></span></li></ul></details></div></div><div class="decl" id="Hashable"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3259-L3261">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Hashable">Hashable</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Sort u</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Sort (max 1 u)</span></div></div><ul class="structure_fields" id="Hashable.mk"><li id="Hashable.hash" class="structure_field"><div class="structure_field_doc"><p>Hashes the value <code>a : α</code> into a <code><a href=".././Init/Prelude.html#UInt64">UInt64</a></code>.</p></div><div class="structure_field_info">hash : <span class="fn"><span class="fn">α</span> → <a href=".././Init/Prelude.html#UInt64">UInt64</a></span></div></li></ul><p>A class for types that can be hashed into a <code><a href=".././Init/Prelude.html#UInt64">UInt64</a></code>.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Hashable" class="instances-list"></ul></details></div></div><div class="decl" id="UInt64.toUSize"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3267-L3267">source</a></div><div class="attributes">@[extern  lean_uint64_to_usize]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#UInt64.toUSize">UInt64.toUSize</a></span><span class="decl_args">
<span class="fn">(u : <a href=".././Init/Prelude.html#UInt64">UInt64</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#USize">USize</a></div></div><p>Converts a <code><a href=".././Init/Prelude.html#UInt64">UInt64</a></code> to a <code><a href=".././Init/Prelude.html#USize">USize</a></code> by reducing modulo <code><a href=".././Init/Prelude.html#USize.size">USize.size</a></code>.</p></div></div><div class="decl" id="USize.toUInt64"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3275-L3284">source</a></div><div class="attributes">@[extern  lean_usize_to_uint64]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#USize.toUInt64">USize.toUInt64</a></span><span class="decl_args">
<span class="fn">(u : <a href=".././Init/Prelude.html#USize">USize</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#UInt64">UInt64</a></div></div><p>Upcast a <code><a href=".././Init/Prelude.html#USize">USize</a></code> to a <code><a href=".././Init/Prelude.html#UInt64">UInt64</a></code>.
This is lossless because <code><a href=".././Init/Prelude.html#USize.size">USize.size</a></code> is either <code>2^32</code> or <code>2^64</code>.
This function is overridden with a native implementation.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#USize.toUInt64">USize.toUInt64</a> <span class="fn">u</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">val</span> := <span class="fn">{ <span class="fn">val</span> := <span class="fn"><span class="fn"><span class="fn">u</span>.val</span>.val</span>, <span class="fn">isLt</span> := <span class="fn">(_ : <span class="fn"><span class="fn"><span class="fn"><span class="fn">u</span>.val</span>.val</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <a href=".././Init/Prelude.html#UInt64.size">UInt64.size</a></span>)</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="mixHash"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3288-L3288">source</a></div><div class="attributes">@[extern  lean_uint64_mix_hash]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#mixHash">mixHash</a></span><span class="decl_args">
<span class="fn">(u₁ : <a href=".././Init/Prelude.html#UInt64">UInt64</a>)</span></span>
<span class="decl_args">
<span class="fn">(u₂ : <a href=".././Init/Prelude.html#UInt64">UInt64</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#UInt64">UInt64</a></div></div><p>An opaque hash mixing operation, used to implement hashing for tuples.</p></div></div><div class="decl" id="instHashableSubtype"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3290-L3291">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHashableSubtype">instHashableSubtype</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Sort u_1</span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Hashable">Hashable</a> <span class="fn">α</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{p : <span class="fn"><span class="fn">α</span> → <span class="fn">Prop</span></span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Hashable">Hashable</a> (<span class="fn"><a href=".././Init/Prelude.html#Subtype">Subtype</a> <span class="fn">p</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">instHashableSubtype</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hash</span> := <span class="fn">fun <span class="fn">a</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Hashable.hash">hash</a> <span class="fn"><span class="fn">a</span>.val</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="String.hash"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3295-L3295">source</a></div><div class="attributes">@[extern  lean_string_hash]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#String.hash">String.hash</a></span><span class="decl_args">
<span class="fn">(s : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#UInt64">UInt64</a></div></div><p>A opaque string hash function.</p></div></div><div class="decl" id="instHashableString"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3297-L3298">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#instHashableString">instHashableString</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Hashable">Hashable</a> <a href=".././Init/Prelude.html#String">String</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#instHashableString">instHashableString</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hash</span> := <a href=".././Init/Prelude.html#String.hash">String.hash</a> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.Name.hash"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3302-L3342">source</a></div><div class="attributes">@[implementedBy Lean.Name.hash._override]</div>
<div class="decl_header"><span class="decl_kind">noncomputable def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.hash">Lean.Name.hash</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <a href=".././Init/Prelude.html#UInt64">UInt64</a></span></div></div><p>A hash function for names, which is stored inside the name itself as a
computed field.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.hash">Lean.Name.hash</a> <a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#UInt64.ofNatCore">UInt64.ofNatCore</a> <span class="fn">1723</span> <span class="fn">(_ : <span class="fn"><span class="fn">1723</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <a href=".././Init/Prelude.html#UInt64.size">UInt64.size</a></span>)</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.hash">Lean.Name.hash</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> <span class="fn">p</span> <span class="fn">s</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#mixHash">mixHash</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.hash">Lean.Name.hash</a> <span class="fn">p</span></span>) (<span class="fn"><a href=".././Init/Prelude.html#String.hash">String.hash</a> <span class="fn">s</span></span>)</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.hash">Lean.Name.hash</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.num">Lean.Name.num</a> <span class="fn">p</span> <span class="fn">v</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#mixHash">mixHash</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.hash">Lean.Name.hash</a> <span class="fn">p</span></span>)
    (<span class="fn">if h : <span class="fn"><span class="fn">v</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <a href=".././Init/Prelude.html#UInt64.size">UInt64.size</a></span> then <span class="fn"><a href=".././Init/Prelude.html#UInt64.ofNatCore">UInt64.ofNatCore</a> <span class="fn">v</span> <span class="fn">h</span></span> else <span class="fn"><a href=".././Init/Prelude.html#UInt64.ofNatCore">UInt64.ofNatCore</a> <span class="fn">17</span> <span class="fn">(_ : <span class="fn"><span class="fn">17</span> <a href=".././Init/Prelude.html#LT.lt">&lt</a> <a href=".././Init/Prelude.html#UInt64.size">UInt64.size</a></span>)</span></span></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Name"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3318-L3342">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="constructors"><li class="constructor" id="Lean.Name.anonymous"><div class="inductive_ctor_doc"><p>The "anonymous" name.</p></div>anonymous: <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></li><li class="constructor" id="Lean.Name.str"><div class="inductive_ctor_doc"><p>A string name. The name <code>Lean.Meta.<a href=".././Init/Prelude.html#ReaderT.run">run</a></code> is represented at</p><pre><code class="language-lean">.str (.str (.str .anonymous "Lean") "Meta") "run"
</code></pre></div>str: <span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <span class="fn"><a href=".././Init/Prelude.html#String">String</a> → <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span></span></li><li class="constructor" id="Lean.Name.num"><div class="inductive_ctor_doc"><p>A numerical name. This kind of name is used, for example, to create hierarchical names for
free variables and metavariables. The identifier <code>_uniq.231</code> is represented as</p><pre><code class="language-lean">.num (.str .anonymous "_uniq") 231
</code></pre></div>num: <span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span></span></li></ul><p>Hierarchical names. We use hierarchical names to name declarations and
for creating unique identifiers for free variables and metavariables.</p><p>You can create hierarchical names using the following quotation notation.</p><pre><code>`Lean.Meta.whnf
</code></pre><p>It is short for <code>.str (.str (.str .anonymous "Lean") "Meta") "whnf"</code>
You can use double quotes to request Lean to statically check whether the name
corresponds to a Lean declaration in scope.</p><pre><code>``Lean.Meta.whnf
</code></pre><p>If the name is not in scope, Lean will report an error.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Name" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.instInhabitedName"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3344-L3345">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instInhabitedName">Lean.instInhabitedName</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.instInhabitedName">Lean.instInhabitedName</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.instHashableName"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3347-L3348">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instHashableName">Lean.instHashableName</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Hashable">Hashable</a> <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.instHashableName">Lean.instHashableName</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">hash</span> := <a href=".././Init/Prelude.html#Lean.Name.hash">Lean.Name.hash</a> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.Name.mkStr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3356-L3357">source</a></div><div class="attributes">@[inline, export lean_name_mk_string]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr">Lean.Name.mkStr</a></span><span class="decl_args">
<span class="fn">(p : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(s : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p><code>.str p s</code> is now the preferred form.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr">Lean.Name.mkStr</a> <span class="fn">p</span> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> <span class="fn">p</span> <span class="fn">s</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Name.mkNum"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3363-L3364">source</a></div><div class="attributes">@[inline, export lean_name_mk_numeral]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkNum">Lean.Name.mkNum</a></span><span class="decl_args">
<span class="fn">(p : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(v : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p><code>.num p v</code> is now the preferred form.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkNum">Lean.Name.mkNum</a> <span class="fn">p</span> <span class="fn">v</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.num">Lean.Name.num</a> <span class="fn">p</span> <span class="fn">v</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Name.mkSimple"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3369-L3370">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkSimple">Lean.Name.mkSimple</a></span><span class="decl_args">
<span class="fn">(s : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p>Short for <code>.str .anonymous s</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkSimple">Lean.Name.mkSimple</a> <span class="fn">s</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> <a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a> <span class="fn">s</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Name.mkStr1"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3373-L3374">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr1">Lean.Name.mkStr1</a></span><span class="decl_args">
<span class="fn">(s₁ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p>Make name <code>s₁</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr1">Lean.Name.mkStr1</a> <span class="fn">s₁</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> <a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a> <span class="fn">s₁</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Name.mkStr2"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3377-L3378">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr2">Lean.Name.mkStr2</a></span><span class="decl_args">
<span class="fn">(s₁ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₂ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p>Make name <code>s₁.s₂</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr2">Lean.Name.mkStr2</a> <span class="fn">s₁</span> <span class="fn">s₂</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> <a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a> <span class="fn">s₁</span></span>) <span class="fn">s₂</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Name.mkStr3"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3381-L3382">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr3">Lean.Name.mkStr3</a></span><span class="decl_args">
<span class="fn">(s₁ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₂ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₃ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p>Make name <code>s₁.s₂.s₃</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr3">Lean.Name.mkStr3</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">s₃</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> <a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a> <span class="fn">s₁</span></span>) <span class="fn">s₂</span></span>) <span class="fn">s₃</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Name.mkStr4"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3385-L3386">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr4">Lean.Name.mkStr4</a></span><span class="decl_args">
<span class="fn">(s₁ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₂ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₃ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₄ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p>Make name <code>s₁.s₂.s₃.s₄</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr4">Lean.Name.mkStr4</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">s₃</span> <span class="fn">s₄</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> <a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a> <span class="fn">s₁</span></span>) <span class="fn">s₂</span></span>) <span class="fn">s₃</span></span>) <span class="fn">s₄</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Name.mkStr5"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3389-L3390">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr5">Lean.Name.mkStr5</a></span><span class="decl_args">
<span class="fn">(s₁ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₂ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₃ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₄ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₅ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p>Make name <code>s₁.s₂.s₃.s₄.s₅</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr5">Lean.Name.mkStr5</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">s₃</span> <span class="fn">s₄</span> <span class="fn">s₅</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> <a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a> <span class="fn">s₁</span></span>) <span class="fn">s₂</span></span>) <span class="fn">s₃</span></span>) <span class="fn">s₄</span></span>) <span class="fn">s₅</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Name.mkStr6"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3393-L3394">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr6">Lean.Name.mkStr6</a></span><span class="decl_args">
<span class="fn">(s₁ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₂ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₃ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₄ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₅ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₆ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p>Make name <code>s₁.s₂.s₃.s₄.s₅.s₆</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr6">Lean.Name.mkStr6</a> <span class="fn">s₁</span> <span class="fn">s₂</span> <span class="fn">s₃</span> <span class="fn">s₄</span> <span class="fn">s₅</span> <span class="fn">s₆</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a>
    (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> <a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a> <span class="fn">s₁</span></span>) <span class="fn">s₂</span></span>) <span class="fn">s₃</span></span>) <span class="fn">s₄</span></span>) <span class="fn">s₅</span></span>)
    <span class="fn">s₆</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Name.mkStr7"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3397-L3398">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr7">Lean.Name.mkStr7</a></span><span class="decl_args">
<span class="fn">(s₁ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₂ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₃ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₄ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₅ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₆ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₇ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p>Make name <code>s₁.s₂.s₃.s₄.s₅.s₆.s₇</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Name.mkStr8"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3401-L3402">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.mkStr8">Lean.Name.mkStr8</a></span><span class="decl_args">
<span class="fn">(s₁ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₂ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₃ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₄ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₅ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₆ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₇ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(s₈ : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p>Make name <code>s₁.s₂.s₃.s₄.s₅.s₆.s₇.s₈</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Name.beq"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3406-L3410">source</a></div><div class="attributes">@[extern  lean_name_eq]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.beq">Lean.Name.beq</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><p>(Boolean) equality comparator for names.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.beq">Lean.Name.beq</a> <a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a> <a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.true">true</a></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.beq">Lean.Name.beq</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> <span class="fn">p₁</span> <span class="fn">s₁</span></span>) (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> <span class="fn">p₂</span> <span class="fn">s₂</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn"><span class="fn">s₁</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">s₂</span></span> <a href=".././Init/Prelude.html#and">&amp&amp</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.beq">Lean.Name.beq</a> <span class="fn">p₁</span> <span class="fn">p₂</span></span></span>)</span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.beq">Lean.Name.beq</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.num">Lean.Name.num</a> <span class="fn">p₁</span> <span class="fn">n₁</span></span>) (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.num">Lean.Name.num</a> <span class="fn">p₂</span> <span class="fn">n₂</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn"><span class="fn">n₁</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">n₂</span></span> <a href=".././Init/Prelude.html#and">&amp&amp</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.beq">Lean.Name.beq</a> <span class="fn">p₁</span> <span class="fn">p₂</span></span></span>)</span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.beq">Lean.Name.beq</a> <span class="fn">_fun_discr</span> <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></li></ul></details></div></div><div class="decl" id="Lean.Name.instBEqName"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3412-L3413">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.instBEqName">Lean.Name.instBEqName</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#BEq">BEq</a> <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.instBEqName">Lean.Name.instBEqName</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">beq</span> := <a href=".././Init/Prelude.html#Lean.Name.beq">Lean.Name.beq</a> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.Name.append"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3422-L3425">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.append">Lean.Name.append</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></div><p>Append two hierarchical names. Example:</p><pre><code class="language-lean">`Lean.Meta ++ `Tactic.simp
</code></pre><p>return <code>Lean.Meta.Tactic.simp</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.append">Lean.Name.append</a> <span class="fn">_fun_discr</span> <a href=".././Init/Prelude.html#Lean.Name.anonymous">Lean.Name.anonymous</a></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">_fun_discr</span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.append">Lean.Name.append</a> <span class="fn">_fun_discr</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> <span class="fn">p</span> <span class="fn">s</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr">Lean.Name.mkStr</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.append">Lean.Name.append</a> <span class="fn">_fun_discr</span> <span class="fn">p</span></span>) <span class="fn">s</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.append">Lean.Name.append</a> <span class="fn">_fun_discr</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.num">Lean.Name.num</a> <span class="fn">p</span> <span class="fn">d</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkNum">Lean.Name.mkNum</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.append">Lean.Name.append</a> <span class="fn">_fun_discr</span> <span class="fn">p</span></span>) <span class="fn">d</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Name.instAppendName"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3427-L3428">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.instAppendName">Lean.Name.instAppendName</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Append">Append</a> <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.instAppendName">Lean.Name.instAppendName</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">append</span> := <a href=".././Init/Prelude.html#Lean.Name.append">Lean.Name.append</a> }</span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Syntax">Syntax <a class="hover-link" href="#Syntax">#</a></h1></div><div class="decl" id="Lean.SourceInfo"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3435-L3467">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.SourceInfo">Lean.SourceInfo</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="constructors"><li class="constructor" id="Lean.SourceInfo.original"><div class="inductive_ctor_doc"><p>Token from original input with whitespace and position information.
<code>leading</code> will be inferred after parsing by <code>Syntax.updateLeading</code>. During parsing,
it is not at all clear what the preceding token was, especially with backtracking.</p></div>original: <span class="fn"><a href=".././Init/Prelude.html#Substring">Substring</a> → <span class="fn"><a href=".././Init/Prelude.html#String.Pos">String.Pos</a> → <span class="fn"><a href=".././Init/Prelude.html#Substring">Substring</a> → <span class="fn"><a href=".././Init/Prelude.html#String.Pos">String.Pos</a> → <a href=".././Init/Prelude.html#Lean.SourceInfo">Lean.SourceInfo</a></span></span></span></span></li><li class="constructor" id="Lean.SourceInfo.synthetic"><div class="inductive_ctor_doc"><p>Synthesized syntax (e.g. from a quotation) annotated with a span from the original source.
In the delaborator, we "misuse" this constructor to store synthetic positions identifying
subterms.</p><p>The <code>canonical</code> flag on synthetic syntax is enabled for syntax that is not literally part
of the original input syntax but should be treated "as if" the user really wrote it
for the purpose of hovers and error messages. This is usually used on identifiers,
to connect the binding site to the user's original syntax even if the name of the identifier
changes during expansion, as well as on tokens where we will attach targeted messages.</p><p>The syntax <code>token%$stx</code> in a syntax quotation will annotate the token <code>token</code> with the span
from <code>stx</code> and also mark it as canonical.</p><p>As a rough guide, a macro expansion should only use a given piece of input syntax in
a single canonical token, although this is sometimes violated when the same identifier
is used to declare two binders, as in the macro expansion for dependent if:</p><pre><code>`(if $h : $cond then $t else $e) ~>
`(dite $cond (fun $h => $t) (fun $h => $t))
</code></pre><p>In these cases if the user hovers over <code>h</code> they will see information about both binding sites.</p></div>synthetic: <span class="fn"><a href=".././Init/Prelude.html#String.Pos">String.Pos</a> → <a href=".././Init/Prelude.html#String.Pos">String.Pos</a> → <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Prelude.html#Bool">Bool</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span> → <a href=".././Init/Prelude.html#Lean.SourceInfo">Lean.SourceInfo</a></span></span></li><li class="constructor" id="Lean.SourceInfo.none"><div class="inductive_ctor_doc"><p>Synthesized token without position information.</p></div>none: <a href=".././Init/Prelude.html#Lean.SourceInfo">Lean.SourceInfo</a></li></ul><p>Source information of tokens.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.SourceInfo" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.instInhabitedSourceInfo"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3469-L3469">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instInhabitedSourceInfo">Lean.instInhabitedSourceInfo</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Lean.SourceInfo">Lean.SourceInfo</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.instInhabitedSourceInfo">Lean.instInhabitedSourceInfo</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <a href=".././Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.SourceInfo.getPos?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3477-L3482">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.SourceInfo.getPos?">Lean.SourceInfo.getPos?</a></span><span class="decl_args">
<span class="fn">(info : <a href=".././Init/Prelude.html#Lean.SourceInfo">Lean.SourceInfo</a>)</span></span>
<span class="decl_args">
<span class="fn">(canonicalOnly : <span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Prelude.html#Bool">Bool</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a></span></div></div><p>Gets the position information from a <code><a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a></code>, if available.
If <code>originalOnly</code> is true, then <code>.synthetic</code> syntax will also return <code>none</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.SyntaxNodeKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3493-L3493">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><p>A <code><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></code> classifies <code>Syntax.node</code> values. It is an abbreviation for
<code><a href=".././Init/Prelude.html#Lean.Name">Name</a></code>, and you can use name literals to construct <code><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></code>s, but
they need not refer to declarations in the environment. Conventionally, a
<code><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></code> will correspond to the <code>Parser</code> or <code>ParserDesc</code> declaration
that parses it.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Syntax-AST">Syntax AST <a class="hover-link" href="#Syntax-AST">#</a></h1></div><div class="decl" id="Lean.Syntax.Preresolved"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3502-L3506">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.Preresolved">Lean.Syntax.Preresolved</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="constructors"><li class="constructor" id="Lean.Syntax.Preresolved.namespace"><div class="inductive_ctor_doc"><p>A potential namespace reference</p></div>namespace: <span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <a href=".././Init/Prelude.html#Lean.Syntax.Preresolved">Lean.Syntax.Preresolved</a></span></li><li class="constructor" id="Lean.Syntax.Preresolved.decl"><div class="inductive_ctor_doc"><p>A potential global constant or section variable reference, with additional field accesses</p></div>decl: <span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#String">String</a></span> → <a href=".././Init/Prelude.html#Lean.Syntax.Preresolved">Lean.Syntax.Preresolved</a></span></span></li></ul><p>Binding information resolved and stored at compile time of a syntax quotation.
Note: We do not statically know whether a syntax expects a namespace or term name,
so a <code>Syntax.ident</code> may contain both preresolution kinds.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Syntax.Preresolved" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Syntax"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3511-L3546">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="constructors"><li class="constructor" id="Lean.Syntax.missing"><div class="inductive_ctor_doc"><p>A <code>missing</code> syntax corresponds to a portion of the syntax tree that is
missing because of a parse error. The indexing operator on Syntax also
returns <code>missing</code> for indexing out of bounds.</p></div>missing: <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></li><li class="constructor" id="Lean.Syntax.node"><div class="inductive_ctor_doc"><p>Node in the syntax tree.</p><p>The <code>info</code> field is used by the delaborator to store the position of the
subexpression corresponding to this node. The parser sets the <code>info</code> field
to <code>none</code>.
The parser sets the <code>info</code> field to <code>none</code>, with position retrieval continuing recursively.
Nodes created by quotatons use the result from <code><a href=".././Init/Prelude.html#Lean.SourceInfo.fromRef">SourceInfo.fromRef</a></code> so that they are marked
as synthetic even when the leading/trailing token is not.
The delaborator uses the <code>info</code> field to store the position of the subexpression
corresponding to this node.</p><p>(Remark: the <code>node</code> constructor did not have an <code>info</code> field in previous
versions. This caused a bug in the interactive widgets, where the popup for
<code>a + b</code> was the same as for <code>a</code>. The delaborator used to associate
subexpressions with pretty-printed syntax by setting the (string) position
of the first atom/identifier to the (expression) position of the
subexpression. For example, both <code>a</code> and <code>a + b</code> have the same first
identifier, and so their infos got mixed up.)</p></div>node: <span class="fn"><a href=".././Init/Prelude.html#Lean.SourceInfo">Lean.SourceInfo</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a> → <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span> → <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span></span></span></li><li class="constructor" id="Lean.Syntax.atom"><div class="inductive_ctor_doc"><p>An <code>atom</code> corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside <code>syntax</code> declarations.
For example, in <code>(x + y)</code>, <code>"("</code>, <code>"+"</code> and <code>")"</code> are <code>atom</code>
and <code>x</code> and <code>y</code> are <code>ident</code>.</p></div>atom: <span class="fn"><a href=".././Init/Prelude.html#Lean.SourceInfo">Lean.SourceInfo</a> → <span class="fn"><a href=".././Init/Prelude.html#String">String</a> → <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span></span></li><li class="constructor" id="Lean.Syntax.ident"><div class="inductive_ctor_doc"><p>An <code>ident</code> corresponds to an identifier as parsed by the <code>ident</code> or
<code>rawIdent</code> parsers.</p><ul>
<li><code>rawVal</code> is the literal substring from the input file</li>
<li><code>val</code> is the parsed identifier (with hygiene)</li>
<li><code>preresolved</code> is the list of possible declarations this could refer to</li>
</ul></div>ident: <span class="fn"><a href=".././Init/Prelude.html#Lean.SourceInfo">Lean.SourceInfo</a> → <span class="fn"><a href=".././Init/Prelude.html#Substring">Substring</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Lean.Syntax.Preresolved">Lean.Syntax.Preresolved</a></span> → <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span></span></span></span></li></ul><p>Syntax objects used by the parser, macro expander, delaborator, etc.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Syntax" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.SyntaxNodeKinds"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3549-L3549">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">Lean.SyntaxNodeKinds</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><p><code><a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">SyntaxNodeKinds</a></code> is a set of <code><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">SyntaxNodeKind</a></code> (implemented as a list).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">Lean.SyntaxNodeKinds</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></span></span></li></ul></details></div></div><div class="decl" id="Lean.TSyntax"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3558-L3560">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a></span><span class="decl_args">
<span class="fn">(ks : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">Lean.SyntaxNodeKinds</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="Lean.TSyntax.mk"><li id="Lean.TSyntax.raw" class="structure_field"><div class="structure_field_doc"><p>The underlying <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> value.</p></div><div class="structure_field_info">raw : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></div></li></ul><p>A <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> value of one of the given syntax kinds.
Note that while syntax quotations produce/expect <code><a href=".././Init/Prelude.html#Lean.TSyntax">TSyntax</a></code> values of the correct kinds,
this is not otherwise enforced and can easily be circumvented by direct use of the constructor.
The namespace <code>TSyntax.Compat</code> can be opened to expose a general coercion from <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> to any
<code><a href=".././Init/Prelude.html#Lean.TSyntax">TSyntax</a> ks</code> for porting older code.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.TSyntax" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.instInhabitedSyntax"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3562-L3563">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instInhabitedSyntax">Lean.instInhabitedSyntax</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.instInhabitedSyntax">Lean.instInhabitedSyntax</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <a href=".././Init/Prelude.html#Lean.Syntax.missing">Lean.Syntax.missing</a> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.instInhabitedTSyntax"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3565-L3566">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instInhabitedTSyntax">Lean.instInhabitedTSyntax</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ks : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">Lean.SyntaxNodeKinds</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">ks</span></span>)</span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Lean.instInhabitedTSyntax</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">raw</span> := <span class="fn">default</span> }</span> }</span></span></li></ul></details></div></div><div class="mod_doc"><p>Builtin kinds</p></div><div class="decl" id="Lean.choiceKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3574-L3574">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.choiceKind">Lean.choiceKind</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></div></div><p>The <code><a href=".././Init/Prelude.html#Classical.choice">choice</a></code> kind is used when a piece of syntax has multiple parses, and the
determination of which to use is deferred until typing information is available.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.choiceKind">Lean.choiceKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr1">Lean.Name.mkStr1</a> <span class="fn">&quotchoice&quot</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.nullKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3577-L3577">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.nullKind">Lean.nullKind</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></div></div><p>The null kind is used for raw list parsers like <code>many</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.nullKind">Lean.nullKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr1">Lean.Name.mkStr1</a> <span class="fn">&quotnull&quot</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.groupKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3583-L3583">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.groupKind">Lean.groupKind</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></div></div><p>The <code>group</code> kind is by the <code>group</code> parser, to avoid confusing with the null
kind when used inside <code><a href=".././Init/Control/Basic.html#optional">optional</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.groupKind">Lean.groupKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr1">Lean.Name.mkStr1</a> <span class="fn">&quotgroup&quot</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.identKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3590-L3590">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.identKind">Lean.identKind</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></div></div><p><code>ident</code> is not actually used as a node kind, but it is returned by
<code><a href=".././Init/Prelude.html#Lean.Syntax.getKind">getKind</a></code> in the <code>ident</code> case so that things that handle different node
kinds can also handle <code>ident</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.identKind">Lean.identKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr1">Lean.Name.mkStr1</a> <span class="fn">&quotident&quot</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.strLitKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3593-L3593">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.strLitKind">Lean.strLitKind</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></div></div><p><code>str</code> is the node kind of string literals like <code>"foo"</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.strLitKind">Lean.strLitKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr1">Lean.Name.mkStr1</a> <span class="fn">&quotstr&quot</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.charLitKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3596-L3596">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.charLitKind">Lean.charLitKind</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></div></div><p><code>char</code> is the node kind of character literals like <code>'A'</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.charLitKind">Lean.charLitKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr1">Lean.Name.mkStr1</a> <span class="fn">&quotchar&quot</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.numLitKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3599-L3599">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.numLitKind">Lean.numLitKind</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></div></div><p><code>num</code> is the node kind of number literals like <code>42</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.numLitKind">Lean.numLitKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr1">Lean.Name.mkStr1</a> <span class="fn">&quotnum&quot</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.scientificLitKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3602-L3602">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.scientificLitKind">Lean.scientificLitKind</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></div></div><p><code>scientific</code> is the node kind of floating point literals like <code>1.23e-3</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.scientificLitKind">Lean.scientificLitKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr1">Lean.Name.mkStr1</a> <span class="fn">&quotscientific&quot</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.nameLitKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3605-L3605">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.nameLitKind">Lean.nameLitKind</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></div></div><p><code>name</code> is the node kind of name literals like <code>`foo</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.nameLitKind">Lean.nameLitKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr1">Lean.Name.mkStr1</a> <span class="fn">&quotname&quot</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.fieldIdxKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3608-L3608">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.fieldIdxKind">Lean.fieldIdxKind</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></div></div><p><code>fieldIdx</code> is the node kind of projection indices like the <code>2</code> in <code>x.2</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.fieldIdxKind">Lean.fieldIdxKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr1">Lean.Name.mkStr1</a> <span class="fn">&quotfieldIdx&quot</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.interpolatedStrLitKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3614-L3614">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.interpolatedStrLitKind">Lean.interpolatedStrLitKind</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></div></div><p><code><a href=".././Init/Prelude.html#Lean.interpolatedStrLitKind">interpolatedStrLitKind</a></code> is the node kind of interpolated string literal
fragments like <code>"value = {</code> and <code>}"</code> in <code>s!"value = {x}"</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.interpolatedStrLitKind">Lean.interpolatedStrLitKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr1">Lean.Name.mkStr1</a> <span class="fn">&quotinterpolatedStrLitKind&quot</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.interpolatedStrKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3619-L3619">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.interpolatedStrKind">Lean.interpolatedStrKind</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></div></div><p><code><a href=".././Init/Prelude.html#Lean.interpolatedStrKind">interpolatedStrKind</a></code> is the node kind of an interpolated string literal
like <code>"value = {x}"</code> in <code>s!"value = {x}"</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.interpolatedStrKind">Lean.interpolatedStrKind</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr1">Lean.Name.mkStr1</a> <span class="fn">&quotinterpolatedStrKind&quot</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.getKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3628-L3636">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getKind">Lean.Syntax.getKind</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a></div></div><p>Gets the kind of a <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> node. For non-<code>node</code> syntax, we use "pseudo kinds":
<code><a href=".././Init/Prelude.html#Lean.identKind">identKind</a></code> for <code>ident</code>, <code>missing</code> for <code>missing</code>, and the atom's string literal
for atoms.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Syntax.setKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3642-L3645">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.setKind">Lean.Syntax.setKind</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(k : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></div></div><p>Changes the kind at the root of a <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> node to <code>k</code>.
Does nothing for non-<code>node</code> nodes.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.setKind">Lean.Syntax.setKind</a> <span class="fn">stx</span> <span class="fn">k</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">stx</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">args</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">k</span> <span class="fn">args</span></span>
  | <span class="fn">x</span> =&gt <span class="fn">stx</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.isOfKind"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3648-L3649">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.isOfKind">Lean.Syntax.isOfKind</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(k : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Is this a syntax with node kind <code>k</code>?</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.isOfKind">Lean.Syntax.isOfKind</a> <span class="fn">stx</span> <span class="fn">k</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.getKind">Lean.Syntax.getKind</a> <span class="fn">stx</span></span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">k</span></span>)</span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.getArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3655-L3658">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getArg">Lean.Syntax.getArg</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(i : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></div></div><p>Gets the <code>i</code>'th argument of the syntax node. This can also be written <code>stx[i]</code>.
Returns <code>missing</code> if <code>i</code> is out of range.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.getArg">Lean.Syntax.getArg</a> <span class="fn">stx</span> <span class="fn">i</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">stx</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">args</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Array.getD">Array.getD</a> <span class="fn">args</span> <span class="fn">i</span> <a href=".././Init/Prelude.html#Lean.Syntax.missing">Lean.Syntax.missing</a></span>
  | <span class="fn">x</span> =&gt <span class="fn">Lean.Syntax.missing</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.instGetElemSyntaxNatTrue"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3660-L3661">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.instGetElemSyntaxNatTrue">Lean.Syntax.instGetElemSyntaxNatTrue</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#GetElem">GetElem</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> <a href=".././Init/Prelude.html#Nat">Nat</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> <span class="fn">fun <span class="fn">x</span> <span class="fn">x</span> =&gt <a href=".././Init/Prelude.html#True">True</a></span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.instGetElemSyntaxNatTrue">Lean.Syntax.instGetElemSyntaxNatTrue</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">getElem</span> := <span class="fn">fun <span class="fn">stx</span> <span class="fn">i</span> <span class="fn">x</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.getArg">Lean.Syntax.getArg</a> <span class="fn">stx</span> <span class="fn">i</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.getArgs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3664-L3667">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getArgs">Lean.Syntax.getArgs</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span></div></div><p>Gets the list of arguments of the syntax node, or <code>#[]</code> if it's not a <code>node</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.getArgs">Lean.Syntax.getArgs</a> <span class="fn">stx</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">stx</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">args</span></span> =&gt <span class="fn">args</span>
  | <span class="fn">x</span> =&gt <span class="fn">Array.empty</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.getNumArgs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3670-L3673">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getNumArgs">Lean.Syntax.getNumArgs</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>Gets the number of arguments of the syntax node, or <code>0</code> if it's not a <code>node</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.getNumArgs">Lean.Syntax.getNumArgs</a> <span class="fn">stx</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">stx</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">kind</span> <span class="fn">args</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Array.size">Array.size</a> <span class="fn">args</span></span>
  | <span class="fn">x</span> =&gt <span class="fn">0</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.getOptional?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3679-L3684">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getOptional?">Lean.Syntax.getOptional?</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span></div></div><p>Assuming <code>stx</code> was parsed by <code><a href=".././Init/Control/Basic.html#optional">optional</a></code>, returns the enclosed syntax
if it parsed something and <code>none</code> otherwise.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Syntax.isMissing"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3687-L3689">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.isMissing">Lean.Syntax.isMissing</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Is this syntax <code>.missing</code>?</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.isMissing">Lean.Syntax.isMissing</a> <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">_fun_discr</span> with
  | <span class="fn">Lean.Syntax.missing</span> =&gt <a href=".././Init/Prelude.html#Bool.true">true</a>
  | <span class="fn">x</span> =&gt <span class="fn">false</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.isNodeOf"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3692-L3693">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.isNodeOf">Lean.Syntax.isNodeOf</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(k : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Is this syntax a <code>node</code> with kind <code>k</code>?</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.isNodeOf">Lean.Syntax.isNodeOf</a> <span class="fn">stx</span> <span class="fn">k</span> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.isOfKind">Lean.Syntax.isOfKind</a> <span class="fn">stx</span> <span class="fn">k</span></span> <a href=".././Init/Prelude.html#and">&amp&amp</a> <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.getNumArgs">Lean.Syntax.getNumArgs</a> <span class="fn">stx</span></span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">n</span></span></span>)</span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.isIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3696-L3698">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.isIdent">Lean.Syntax.isIdent</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><p><code>stx.<a href=".././Init/Prelude.html#Lean.Syntax.isIdent">isIdent</a></code> is <code>true</code> iff <code>stx</code> is an identifier.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.isIdent">Lean.Syntax.isIdent</a> <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">_fun_discr</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.ident">Lean.Syntax.ident</a> <span class="fn">info</span> <span class="fn">rawVal</span> <span class="fn">val</span> <span class="fn">preresolved</span></span> =&gt <a href=".././Init/Prelude.html#Bool.true">true</a>
  | <span class="fn">x</span> =&gt <span class="fn">false</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.getId"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3701-L3703">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getId">Lean.Syntax.getId</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></div><p>If this is a <code>ident</code>, return the parsed value, else <code>.anonymous</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.getId">Lean.Syntax.getId</a> <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">_fun_discr</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.ident">Lean.Syntax.ident</a> <span class="fn">info</span> <span class="fn">rawVal</span> <span class="fn">val</span> <span class="fn">preresolved</span></span> =&gt <span class="fn">val</span>
  | <span class="fn">x</span> =&gt <span class="fn">Lean.Name.anonymous</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.setArgs"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3709-L3712">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.setArgs">Lean.Syntax.setArgs</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(args : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></div></div><p>Updates the argument list without changing the node kind.
Does nothing for non-<code>node</code> nodes.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.setArgs">Lean.Syntax.setArgs</a> <span class="fn">stx</span> <span class="fn">args</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">stx</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">k</span> <span class="fn">args</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">k</span> <span class="fn">args</span></span>
  | <span class="fn">stx</span> =&gt <span class="fn">stx</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.setArg"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3718-L3721">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.setArg">Lean.Syntax.setArg</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(i : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args">
<span class="fn">(arg : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></div></div><p>Updates the <code>i</code>'th argument of the syntax.
Does nothing for non-<code>node</code> nodes, or if <code>i</code> is out of bounds of the node list.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.setArg">Lean.Syntax.setArg</a> <span class="fn">stx</span> <span class="fn">i</span> <span class="fn">arg</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn">stx</span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">k</span> <span class="fn">args</span></span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.node">Lean.Syntax.node</a> <span class="fn">info</span> <span class="fn">k</span> (<span class="fn"><a href=".././Init/Prelude.html#Array.setD">Array.setD</a> <span class="fn">args</span> <span class="fn">i</span> <span class="fn">arg</span></span>)</span>
  | <span class="fn">stx</span> =&gt <span class="fn">stx</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.getHeadInfo?"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3724-L3736">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getHeadInfo?">Lean.Syntax.getHeadInfo?</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#Lean.SourceInfo">Lean.SourceInfo</a></span></span></div></div><p>Retrieve the left-most node or leaf's info in the Syntax tree.</p></div></div><div class="decl" id="Lean.Syntax.getHeadInfo?.loop"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3728-L3733">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getHeadInfo?.loop">Lean.Syntax.getHeadInfo?.loop</a></span><span class="decl_args">
<span class="fn">(args : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#Lean.SourceInfo">Lean.SourceInfo</a></span></div></div></div></div><div class="decl" id="Lean.Syntax.getHeadInfo"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3739-L3742">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getHeadInfo">Lean.Syntax.getHeadInfo</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SourceInfo">Lean.SourceInfo</a></div></div><p>Retrieve the left-most leaf's info in the Syntax tree, or <code>none</code> if there is no token.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.getHeadInfo">Lean.Syntax.getHeadInfo</a> <span class="fn">stx</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.getHeadInfo?">Lean.Syntax.getHeadInfo?</a> <span class="fn">stx</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">info</span></span> =&gt <span class="fn">info</span>
  | <span class="fn">none</span> =&gt <span class="fn">Lean.SourceInfo.none</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.getPos?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3749-L3750">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getPos?">Lean.Syntax.getPos?</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(canonicalOnly : <span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Prelude.html#Bool">Bool</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a></span></div></div><p>Get the starting position of the syntax, if possible.
If <code>canonicalOnly</code> is true, non-canonical <code>synthetic</code> nodes are treated as not carrying
position information.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.getPos?">Lean.Syntax.getPos?</a> <span class="fn">stx</span> <span class="fn">canonicalOnly</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.SourceInfo.getPos?">Lean.SourceInfo.getPos?</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.getHeadInfo">Lean.Syntax.getHeadInfo</a> <span class="fn">stx</span></span>) <span class="fn">canonicalOnly</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.getTailPos?"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3758-L3777">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getTailPos?">Lean.Syntax.getTailPos?</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(canonicalOnly : <span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Prelude.html#Bool">Bool</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a></span></div></div><p>Get the ending position of the syntax, if possible.
If <code>canonicalOnly</code> is true, non-canonical <code>synthetic</code> nodes are treated as not carrying
position information.</p></div></div><div class="decl" id="Lean.Syntax.getTailPos?.loop"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3770-L3775">source</a></div><div class="decl_header"><span class="decl_kind">partial def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.getTailPos?.loop">Lean.Syntax.getTailPos?.loop</a></span><span class="decl_args">
<span class="fn">(canonicalOnly : <span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Prelude.html#Bool">Bool</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(args : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span>)</span></span>
<span class="decl_args">
<span class="fn">(i : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#String.Pos">String.Pos</a></span></div></div></div></div><div class="decl" id="Lean.Syntax.SepArray"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3783-L3786">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.SepArray">Lean.Syntax.SepArray</a></span><span class="decl_args">
<span class="fn">(sep : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="Lean.Syntax.SepArray.mk"><li id="Lean.Syntax.SepArray.elemsAndSeps" class="structure_field"><div class="structure_field_doc"><p>The array of elements and separators, ordered like
<code>#[el1, sep1, el2, sep2, el3]</code>.</p></div><div class="structure_field_info">elemsAndSeps : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span></div></li></ul><p>An array of syntax elements interspersed with separators. Can be coerced
to/from <code><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> to automatically remove/insert the separators.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Syntax.SepArray" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Syntax.TSepArray"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3789-L3792">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.TSepArray">Lean.Syntax.TSepArray</a></span><span class="decl_args">
<span class="fn">(ks : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">Lean.SyntaxNodeKinds</a>)</span></span>
<span class="decl_args">
<span class="fn">(sep : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="Lean.Syntax.TSepArray.mk"><li id="Lean.Syntax.TSepArray.elemsAndSeps" class="structure_field"><div class="structure_field_doc"><p>The array of elements and separators, ordered like
<code>#[el1, sep1, el2, sep2, el3]</code>.</p></div><div class="structure_field_info">elemsAndSeps : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span></div></li></ul><p>A typed version of <code><a href=".././Init/Prelude.html#Lean.Syntax.SepArray">SepArray</a></code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Syntax.TSepArray" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.TSyntaxArray"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3797-L3797">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.TSyntaxArray">Lean.TSyntaxArray</a></span><span class="decl_args">
<span class="fn">(ks : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">Lean.SyntaxNodeKinds</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><p>An array of syntaxes of kind <code>ks</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.TSyntaxArray">Lean.TSyntaxArray</a> <span class="fn">ks</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.TSyntax">Lean.TSyntax</a> <span class="fn">ks</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.TSyntaxArray.rawImpl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3800-L3800">source</a></div><div class="decl_header"><span class="decl_kind">unsafe def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.TSyntaxArray.rawImpl">Lean.TSyntaxArray.rawImpl</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ks : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">Lean.SyntaxNodeKinds</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.TSyntaxArray">Lean.TSyntaxArray</a> <span class="fn">ks</span></span> → <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span></span></div></div><p>Implementation of <code><a href=".././Init/Prelude.html#Lean.TSyntaxArray.raw">TSyntaxArray.raw</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Lean.TSyntaxArray.rawImpl</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">unsafeCast</span></span></li></ul></details></div></div><div class="decl" id="Lean.TSyntaxArray.raw"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3804-L3804">source</a></div><div class="attributes">@[implementedBy Lean.TSyntaxArray.rawImpl]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.TSyntaxArray.raw">Lean.TSyntaxArray.raw</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ks : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">Lean.SyntaxNodeKinds</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(as : <span class="fn"><a href=".././Init/Prelude.html#Lean.TSyntaxArray">Lean.TSyntaxArray</a> <span class="fn">ks</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span></div></div><p>Converts a <code><a href=".././Init/Prelude.html#Lean.TSyntaxArray">TSyntaxArray</a></code> to an <code><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code>, without reallocation.</p></div></div><div class="decl" id="Lean.TSyntaxArray.mkImpl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3807-L3807">source</a></div><div class="decl_header"><span class="decl_kind">unsafe def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.TSyntaxArray.mkImpl">Lean.TSyntaxArray.mkImpl</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ks : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">Lean.SyntaxNodeKinds</a>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span> → <span class="fn"><a href=".././Init/Prelude.html#Lean.TSyntaxArray">Lean.TSyntaxArray</a> <span class="fn">ks</span></span></span></div></div><p>Implementation of <code><a href=".././Init/Prelude.html#Lean.TSyntaxArray.mk">TSyntaxArray.mk</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Lean.TSyntaxArray.mkImpl</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">unsafeCast</span></span></li></ul></details></div></div><div class="decl" id="Lean.TSyntaxArray.mk"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3811-L3811">source</a></div><div class="attributes">@[implementedBy Lean.TSyntaxArray.mkImpl]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.TSyntaxArray.mk">Lean.TSyntaxArray.mk</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{ks : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKinds">Lean.SyntaxNodeKinds</a>}</span></span>
</span><span class="decl_args">
<span class="fn">(as : <span class="fn"><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.TSyntaxArray">Lean.TSyntaxArray</a> <span class="fn">ks</span></span></div></div><p>Converts an <code><a href=".././Init/Prelude.html#Array">Array</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> to a <code><a href=".././Init/Prelude.html#Lean.TSyntaxArray">TSyntaxArray</a></code>, without reallocation.</p></div></div><div class="decl" id="Lean.SourceInfo.fromRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3814-L3824">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.SourceInfo.fromRef">Lean.SourceInfo.fromRef</a></span><span class="decl_args">
<span class="fn">(ref : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(canonical : <span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Prelude.html#Bool">Bool</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.SourceInfo">Lean.SourceInfo</a></div></div><p>Constructs a synthetic <code><a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a></code> using a <code>ref : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> for the span.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.mkAtom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3827-L3828">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.mkAtom">Lean.mkAtom</a></span><span class="decl_args">
<span class="fn">(val : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></div></div><p>Constructs a synthetic <code>atom</code> with no source info.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.mkAtom">Lean.mkAtom</a> <span class="fn">val</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.atom">Lean.Syntax.atom</a> <a href=".././Init/Prelude.html#Lean.SourceInfo.none">Lean.SourceInfo.none</a> <span class="fn">val</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.mkAtomFrom"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3831-L3832">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.mkAtomFrom">Lean.mkAtomFrom</a></span><span class="decl_args">
<span class="fn">(src : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(val : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args">
<span class="fn">(canonical : <span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Prelude.html#Bool">Bool</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></div></div><p>Constructs a synthetic <code>atom</code> with source info coming from <code>src</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.mkAtomFrom">Lean.mkAtomFrom</a> <span class="fn">src</span> <span class="fn">val</span> <span class="fn">canonical</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.atom">Lean.Syntax.atom</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.SourceInfo.fromRef">Lean.SourceInfo.fromRef</a> <span class="fn">src</span> <span class="fn">canonical</span></span>) <span class="fn">val</span></span></span></li></ul></details></div></div><div class="mod_doc"><h1 class="markdown-heading" id="Parser-descriptions">Parser descriptions <a class="hover-link" href="#Parser-descriptions">#</a></h1></div><div class="decl" id="Lean.ParserDescr"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3840-L3882">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="constructors"><li class="constructor" id="Lean.ParserDescr.const"><div class="inductive_ctor_doc"><p>A (named) nullary parser, like <code>ppSpace</code></p></div>const: <span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></span></li><li class="constructor" id="Lean.ParserDescr.unary"><div class="inductive_ctor_doc"><p>A (named) unary parser, like <code>group(p)</code></p></div>unary: <span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a> → <a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></span></span></li><li class="constructor" id="Lean.ParserDescr.binary"><div class="inductive_ctor_doc"><p>A (named) binary parser, like <code>orelse</code> or <code>andthen</code>
(written as <code>p1 <|> p2</code> and <code>p1 p2</code> respectively in <code>syntax</code>)</p></div>binary: <span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a> → <a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a> → <a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></span></span></li><li class="constructor" id="Lean.ParserDescr.node"><div class="inductive_ctor_doc"><p>Parses using <code>p</code>, then pops the stack to create a new node with kind <code>kind</code>.
The precedence <code>prec</code> is used to determine whether the parser should apply given
the current precedence level.</p></div>node: <span class="fn"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a> → <span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a> → <a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></span></span></span></li><li class="constructor" id="Lean.ParserDescr.trailingNode"><div class="inductive_ctor_doc"><p>Like <code>node</code> but for trailing parsers (which start with a nonterminal).
Assumes the lhs is already on the stack, and parses using <code>p</code>, then pops the
stack including the lhs to create a new node with kind <code>kind</code>.
The precedence <code>prec</code> and <code>lhsPrec</code> are used to determine whether the parser
should apply.</p></div>trailingNode: <span class="fn"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a> → <span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Nat">Nat</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a> → <a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></span></span></span></li><li class="constructor" id="Lean.ParserDescr.symbol"><div class="inductive_ctor_doc"><p>A literal symbol parser: parses <code>val</code> as a literal.
This parser does not work on identifiers, so <code>symbol</code> arguments are declared
as "keywords" and cannot be used as identifiers anywhere in the file.</p></div>symbol: <span class="fn"><a href=".././Init/Prelude.html#String">String</a> → <a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></span></li><li class="constructor" id="Lean.ParserDescr.nonReservedSymbol"><div class="inductive_ctor_doc"><p>Like <code>symbol</code>, but without reserving <code>val</code> as a keyword.
If <code>includeIdent</code> is true then <code>ident</code> will be reinterpreted as <code>atom</code> if it matches.</p></div>nonReservedSymbol: <span class="fn"><a href=".././Init/Prelude.html#String">String</a> → <span class="fn"><a href=".././Init/Prelude.html#Bool">Bool</a> → <a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></span></span></li><li class="constructor" id="Lean.ParserDescr.cat"><div class="inductive_ctor_doc"><p>Parses using the category parser <code>catName</code> with right binding power
(i.e. precedence) <code>rbp</code>.</p></div>cat: <span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <span class="fn"><a href=".././Init/Prelude.html#Nat">Nat</a> → <a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></span></span></li><li class="constructor" id="Lean.ParserDescr.parser"><div class="inductive_ctor_doc"><p>Parses using another parser <code>declName</code>, which can be either
a <code>Parser</code> or <code><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></code>.</p></div>parser: <span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></span></li><li class="constructor" id="Lean.ParserDescr.nodeWithAntiquot"><div class="inductive_ctor_doc"><p>Like <code>node</code>, but also declares that the body can be matched using an antiquotation
with name <code>name</code>. For example, <code>def $id:declId := 1</code> uses an antiquotation with
name <code>declId</code> in the place where a <code>declId</code> is expected.</p></div>nodeWithAntiquot: <span class="fn"><a href=".././Init/Prelude.html#String">String</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a> → <a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></span></span></span></li><li class="constructor" id="Lean.ParserDescr.sepBy"><div class="inductive_ctor_doc"><p>A <code>sepBy(p, sep)</code> parses 0 or more occurrences of <code>p</code> separated by <code>sep</code>.
<code>psep</code> is usually the same as <code>symbol sep</code>, but it can be overridden.
<code>sep</code> is only used in the antiquot syntax: <code>$x;*</code> would match if <code>sep</code> is <code>";"</code>.
<code>allowTrailingSep</code> is true if e.g. <code>a, b,</code> is also allowed to match.</p></div>sepBy: <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a> → <span class="fn"><a href=".././Init/Prelude.html#String">String</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a> → <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Prelude.html#Bool">Bool</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span> → <a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></span></span></span></span></li><li class="constructor" id="Lean.ParserDescr.sepBy1"><div class="inductive_ctor_doc"><p><code>sepBy1</code> is just like <code>sepBy</code>, except it takes 1 or more instead of
0 or more occurrences of <code>p</code>.</p></div>sepBy1: <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a> → <span class="fn"><a href=".././Init/Prelude.html#String">String</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a> → <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#optParam">optParam</a> <a href=".././Init/Prelude.html#Bool">Bool</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span> → <a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></span></span></span></span></li></ul><p>A <code><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></code> is a grammar for parsers. This is used by the <code>syntax</code> command
to produce parsers without having to <code>import <a href=".././Lean.html">Lean</a></code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.ParserDescr" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.instInhabitedParserDescr"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3884-L3885">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instInhabitedParserDescr">Lean.instInhabitedParserDescr</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.instInhabitedParserDescr">Lean.instInhabitedParserDescr</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#Lean.ParserDescr.symbol">Lean.ParserDescr.symbol</a> <span class="fn">&quot&quot</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.TrailingParserDescr"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3893-L3893">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><p>Although <code><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">TrailingParserDescr</a></code> is an abbreviation for <code><a href=".././Init/Prelude.html#Lean.ParserDescr">ParserDescr</a></code>, Lean will
look at the declared type in order to determine whether to add the parser to
the leading or trailing parser table. The determination is done automatically
by the <code>syntax</code> command.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.TrailingParserDescr">Lean.TrailingParserDescr</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Lean.ParserDescr">Lean.ParserDescr</a></span></li></ul></details></div></div><div class="mod_doc"><p>Runtime support for making quotation terms auto-hygienic, by mangling identifiers
introduced by them with a "macro scope" supplied by the context. Details to appear in a
paper soon.</p></div><div class="decl" id="Lean.MacroScope"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3907-L3907">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MacroScope">Lean.MacroScope</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><p>A macro scope identifier is just a <code><a href=".././Init/Prelude.html#Nat">Nat</a></code> that gets bumped every time we
enter a new macro scope. Within a macro scope, all occurrences of identifier <code>x</code>
parse to the same thing, but <code>x</code> parsed from different macro scopes will
produce different identifiers.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroScope">Lean.MacroScope</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Nat">Nat</a></span></li></ul></details></div></div><div class="decl" id="Lean.reservedMacroScope"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3909-L3909">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.reservedMacroScope">Lean.reservedMacroScope</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>Macro scope used internally. It is not available for our frontend.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.reservedMacroScope">Lean.reservedMacroScope</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">0</span></span></li></ul></details></div></div><div class="decl" id="Lean.firstFrontendMacroScope"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3911-L3911">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.firstFrontendMacroScope">Lean.firstFrontendMacroScope</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>First macro scope available for our frontend</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.firstFrontendMacroScope">Lean.firstFrontendMacroScope</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.reservedMacroScope">Lean.reservedMacroScope</a> <a href=".././Init/Prelude.html#HAdd.hAdd">+</a> <span class="fn">1</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.MonadRef"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3919-L3923">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MonadRef">Lean.MonadRef</a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type</span> → <span class="fn">Type</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type 1</span></div></div><ul class="structure_fields" id="Lean.MonadRef.mk"><li id="Lean.MonadRef.getRef" class="structure_field"><div class="structure_field_doc"><p>Get the current value of the <code>ref</code></p></div><div class="structure_field_info">getRef : <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span></div></li><li id="Lean.MonadRef.withRef" class="structure_field"><div class="structure_field_doc"><p>Run <code>x : m α</code> with a modified value for the <code>ref</code></p></div><div class="structure_field_info">withRef : <span class="fn">{<span class="fn">α</span> : <span class="fn">Type</span>} → <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></span></span></div></li></ul><p>A <code><a href=".././Init/Prelude.html#Lean.MonadRef">MonadRef</a></code> is a monad that has a <code>ref : <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> in the read-only state.
This is used to keep track of the location where we are working; if an exception
is thrown, the <code>ref</code> gives the location where the error will be reported,
assuming no more specific location is provided.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Lean.MonadRef" class="instances-list"></ul></details></div></div><div class="decl" id="Lean.instMonadRef"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3927-L3929">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instMonadRef">Lean.instMonadRef</a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type</span> → <span class="fn">Type</span></span>)</span></span>
<span class="decl_args">
<span class="fn">(n : <span class="fn"><span class="fn">Type</span> → <span class="fn">Type</span></span>)</span></span>
<span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadLift">MonadLift</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Lean.MonadRef">Lean.MonadRef</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MonadRef">Lean.MonadRef</a> <span class="fn">n</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.instMonadRef">Lean.instMonadRef</a> <span class="fn">m</span> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">getRef</span> := <span class="fn"><a href=".././Init/Prelude.html#liftM">liftM</a> <span class="fn">Lean.getRef</span></span>, <span class="fn">withRef</span> := <span class="fn">fun {<span class="fn">α</span>} <span class="fn">ref</span> <span class="fn">x</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#MonadFunctorT.monadMap">monadMap</a> (<span class="fn">fun {<span class="fn">β</span>} =&gt <span class="fn"><a href=".././Init/Prelude.html#Lean.MonadRef.withRef">Lean.MonadRef.withRef</a> <span class="fn">ref</span></span></span>) <span class="fn">x</span></span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.replaceRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3935-L3938">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.replaceRef">Lean.replaceRef</a></span><span class="decl_args">
<span class="fn">(ref : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(oldRef : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></div></div><p>Replaces <code>oldRef</code> with <code>ref</code>, unless <code>ref</code> has no position info.
This biases us to having a valid span to report an error on.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.replaceRef">Lean.replaceRef</a> <span class="fn">ref</span> <span class="fn">oldRef</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.getPos?">Lean.Syntax.getPos?</a> <span class="fn">ref</span></span> with
  | <span class="fn"><a href=".././Init/Prelude.html#Option.some">some</a> <span class="fn">val</span></span> =&gt <span class="fn">ref</span>
  | <span class="fn">x</span> =&gt <span class="fn">oldRef</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.withRef"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3945-L3948">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.withRef">Lean.withRef</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type</span> → <span class="fn">Type</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Lean.MonadRef">Lean.MonadRef</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(ref : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></div></div><p>Run <code>x : m α</code> with a modified value for the <code>ref</code>. This is not exactly
the same as <code>MonadRef.<a href=".././Init/Prelude.html#Lean.withRef">withRef</a></code>, because it uses <code><a href=".././Init/Prelude.html#Lean.replaceRef">replaceRef</a></code> to avoid putting
syntax with bad spans in the state.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.withRef">Lean.withRef</a> <span class="fn">ref</span> <span class="fn">x</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let oldRef ← <span class="fn">Lean.getRef</span>
  let ref : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> := <span class="fn"><a href=".././Init/Prelude.html#Lean.replaceRef">Lean.replaceRef</a> <span class="fn">ref</span> <span class="fn">oldRef</span></span>
  <span class="fn"><a href=".././Init/Prelude.html#Lean.MonadRef.withRef">Lean.MonadRef.withRef</a> <span class="fn">ref</span> <span class="fn">x</span></span></span></span></li></ul></details></div></div><div class="decl" id="Lean.MonadQuotation"><div class="class"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3958-L3977">source</a></div><div class="decl_header"><span class="decl_kind">class</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MonadQuotation">Lean.MonadQuotation</a></span><span class="decl_args">
<span class="fn">(m : <span class="fn"><span class="fn">Type</span> → <span class="fn">Type</span></span>)</span></span>
<span class="decl_extends">extends</span><span class="decl_parent">
<span class="fn"><a class="break_within" href=".././Init/Prelude.html#Lean.MonadRef">Lean.MonadRef</a></span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type 1</span></div></div><ul class="structure_fields" id="Lean.MonadQuotation.mk"><li id="Lean.MonadQuotation.getCurrMacroScope" class="structure_field"><div class="structure_field_doc"><p>Get the fresh scope of the current macro invocation</p></div><div class="structure_field_info">getCurrMacroScope : <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#Lean.MacroScope">Lean.MacroScope</a></span></div></li><li id="Lean.MonadQuotation.getMainModule" class="structure_field"><div class="structure_field_doc"><p>Get the module name of the current file. This is used to ensure that
hygienic names don't clash across multiple files.</p></div><div class="structure_field_info">getMainModule : <span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></li><li id="Lean.MonadQuotation.withFreshMacroScope" class="structure_field"><div class="structure_field_doc"><p>Execute action in a new macro invocation context. This transformer should be
used at all places that morally qualify as the beginning of a "macro call",
e.g. <code>elabCommand</code> and <code>elabTerm</code> in the case of the elaborator. However, it
can also be used internally inside a "macro" if identifiers introduced by
e.g. different recursive calls should be independent and not collide. While
returning an intermediate syntax tree that will recursively be expanded by
the elaborator can be used for the same effect, doing direct recursion inside
the macro guarded by this transformer is often easier because one is not
restricted to passing a single syntax tree. Modelling this helper as a
transformer and not just a monadic action ensures that the current macro
scope before the recursive call is restored after it, as expected.</p></div><div class="structure_field_info">withFreshMacroScope : <span class="fn">{<span class="fn">α</span> : <span class="fn">Type</span>} → <span class="fn"><span class="fn"><span class="fn">m</span> <span class="fn">α</span></span> → <span class="fn"><span class="fn">m</span> <span class="fn">α</span></span></span></span></div></li></ul><p>A monad that supports syntax quotations. Syntax quotations (in term
position) are monadic values that when executed retrieve the current "macro
scope" from the monad and apply it to every identifier they introduce
(independent of whether this identifier turns out to be a reference to an
existing declaration, or an actually fresh binding during further
elaboration). We also apply the position of the result of <code>getRef</code> to each
introduced symbol, which results in better error positions than not applying
any position.</p><details class="instances"><summary>Instances</summary><ul id="instances-list-Lean.MonadQuotation" class="instances-list"></ul></details></div></div><div class="decl" id="Lean.MonadRef.mkInfoFromRefPos"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3982-L3983">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MonadRef.mkInfoFromRefPos">Lean.MonadRef.mkInfoFromRefPos</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type</span> → <span class="fn">Type</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Lean.MonadRef">Lean.MonadRef</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#Lean.SourceInfo">Lean.SourceInfo</a></span></div></div><p>Construct a synthetic <code><a href=".././Init/Prelude.html#Lean.SourceInfo">SourceInfo</a></code> from the <code>ref</code> in the monad state.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Lean.MonadRef.mkInfoFromRefPos</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let a ← <span class="fn">Lean.getRef</span>
  <span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.SourceInfo.fromRef">Lean.SourceInfo.fromRef</a> <span class="fn">a</span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.instMonadQuotation"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L3985-L3988">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instMonadQuotation">Lean.instMonadQuotation</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type</span> → <span class="fn">Type</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">{n : <span class="fn"><span class="fn">Type</span> → <span class="fn">Type</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadFunctor">MonadFunctor</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#MonadLift">MonadLift</a> <span class="fn">m</span> <span class="fn">n</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation">Lean.MonadQuotation</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation">Lean.MonadQuotation</a> <span class="fn">n</span></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Lean.instMonadQuotation</span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation.mk">Lean.MonadQuotation.mk</a> (<span class="fn"><a href=".././Init/Prelude.html#liftM">liftM</a> <span class="fn">Lean.getCurrMacroScope</span></span>) (<span class="fn"><a href=".././Init/Prelude.html#liftM">liftM</a> <span class="fn">Lean.getMainModule</span></span>) <span class="fn">fun {<span class="fn">α</span>} =&gt
    <span class="fn"><a href=".././Init/Prelude.html#MonadFunctorT.monadMap">monadMap</a> <span class="fn">fun {<span class="fn">β</span>} =&gt <span class="fn">Lean.withFreshMacroScope</span></span></span></span></span></span></li></ul></details></div></div><div class="mod_doc"><p>We represent a name with macro scopes as</p><pre><code><actual name>._@.(<module_name>.<scopes>)*.<module_name>._hyg.<scopes>
</code></pre><p>Example: suppose the module name is <code><a href=".././Init/Data/List/Basic.html">Init.Data.List.Basic</a></code>, and name is <code>foo.bla</code>, and macroscopes [2, 5]</p><pre><code>foo.bla._@.Init.Data.List.Basic._hyg.2.5
</code></pre><p>We may have to combine scopes from different files/modules.
The main modules being processed is always the right most one.
This situation may happen when we execute a macro generated in
an imported file in the current file.</p><pre><code>foo.bla._@.Init.Data.List.Basic.2.1.Init.Lean.Expr._hyg.4
</code></pre><p>The delimiter <code>_hyg</code> is used just to improve the <code><a href=".././Init/Prelude.html#Lean.Name.hasMacroScopes">hasMacroScopes</a></code> performance.</p></div><div class="decl" id="Lean.Name.hasMacroScopes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4012-L4015">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.hasMacroScopes">Lean.Name.hasMacroScopes</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Does this name have hygienic macro scopes?</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.hasMacroScopes">Lean.Name.hasMacroScopes</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.str">Lean.Name.str</a> <span class="fn">pre</span> <span class="fn">s</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><span class="fn">s</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn">&quot_hyg&quot</span></span>)</span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.hasMacroScopes">Lean.Name.hasMacroScopes</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.num">Lean.Name.num</a> <span class="fn">p</span> <span class="fn">i</span></span>)</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.hasMacroScopes">Lean.Name.hasMacroScopes</a> <span class="fn">p</span></span></span></li><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.hasMacroScopes">Lean.Name.hasMacroScopes</a> <span class="fn">_fun_discr</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Bool.false">false</a></span></li></ul></details></div></div><div class="decl" id="Lean.Name.eraseMacroScopes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4026-L4029">source</a></div><div class="attributes">@[export lean_erase_macro_scopes]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.eraseMacroScopes">Lean.Name.eraseMacroScopes</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p>Remove the macro scopes from the name.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.eraseMacroScopes">Lean.Name.eraseMacroScopes</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.hasMacroScopes">Lean.Name.hasMacroScopes</a> <span class="fn">n</span></span> with
  | <a href=".././Init/Prelude.html#Bool.false">true</a> =&gt <span class="fn"><a href=".././Init/Prelude.html#_private.Init.Prelude.0.Lean.eraseMacroScopesAux">Lean.eraseMacroScopesAux</a> <span class="fn">n</span></span>
  | <a href=".././Init/Prelude.html#Bool.false">false</a> =&gt <a href=".././Init/Prelude.html#Bool.false">n</a></span></span></li></ul></details></div></div><div class="decl" id="Lean.Name.simpMacroScopes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4037-L4040">source</a></div><div class="attributes">@[export lean_simp_macro_scopes]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Name.simpMacroScopes">Lean.Name.simpMacroScopes</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p>Helper function we use to create binder names that do not need to be unique.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.simpMacroScopes">Lean.Name.simpMacroScopes</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">match <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.hasMacroScopes">Lean.Name.hasMacroScopes</a> <span class="fn">n</span></span> with
  | <a href=".././Init/Prelude.html#Bool.false">true</a> =&gt <span class="fn"><a href=".././Init/Prelude.html#_private.Init.Prelude.0.Lean.simpMacroScopesAux">Lean.simpMacroScopesAux</a> <span class="fn">n</span></span>
  | <a href=".././Init/Prelude.html#Bool.false">false</a> =&gt <a href=".././Init/Prelude.html#Bool.false">n</a></span></span></li></ul></details></div></div><div class="decl" id="Lean.MacroScopesView"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4050-L4059">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MacroScopesView">Lean.MacroScopesView</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="Lean.MacroScopesView.mk"><li id="Lean.MacroScopesView.name" class="structure_field"><div class="structure_field_doc"><p>The original (unhygienic) name.</p></div><div class="structure_field_info">name : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></li><li id="Lean.MacroScopesView.imported" class="structure_field"><div class="structure_field_doc"><p>All the name components <code>(<module_name>.<scopes>)*</code> from the imports
concatenated together.</p></div><div class="structure_field_info">imported : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></li><li id="Lean.MacroScopesView.mainModule" class="structure_field"><div class="structure_field_doc"><p>The main module in which this identifier was parsed.</p></div><div class="structure_field_info">mainModule : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></li><li id="Lean.MacroScopesView.scopes" class="structure_field"><div class="structure_field_doc"><p>The list of macro scopes.</p></div><div class="structure_field_info">scopes : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Lean.MacroScope">Lean.MacroScope</a></span></div></li></ul><p>A <code><a href=".././Init/Prelude.html#Lean.MacroScopesView">MacroScopesView</a></code> represents a parsed hygienic name. <code><a href=".././Init/Prelude.html#Lean.extractMacroScopes">extractMacroScopes</a></code>
will decode it from a <code><a href=".././Init/Prelude.html#Lean.Name">Name</a></code>, and <code>.<a href=".././Init/Prelude.html#Lean.MacroScopesView.review">review</a></code> will re-encode it. The grammar of a
hygienic name is:</p><pre><code><name>._@.(<module_name>.<scopes>)*.<mainModule>._hyg.<scopes>
</code></pre><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.MacroScopesView" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.instInhabitedMacroScopesView"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4061-L4062">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.instInhabitedMacroScopesView">Lean.instInhabitedMacroScopesView</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Lean.MacroScopesView">Lean.MacroScopesView</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.instInhabitedMacroScopesView">Lean.instInhabitedMacroScopesView</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">name</span> := <span class="fn">default</span>, <span class="fn">imported</span> := <span class="fn">default</span>, <span class="fn">mainModule</span> := <span class="fn">default</span>, <span class="fn">scopes</span> := <span class="fn">default</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.MacroScopesView.review"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4065-L4070">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MacroScopesView.review">Lean.MacroScopesView.review</a></span><span class="decl_args">
<span class="fn">(view : <a href=".././Init/Prelude.html#Lean.MacroScopesView">Lean.MacroScopesView</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p>Encode a hygienic name from the parsed pieces.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.extractMacroScopes"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4103-L4106">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.extractMacroScopes">Lean.extractMacroScopes</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.MacroScopesView">Lean.MacroScopesView</a></div></div><p>Revert all <code><a href=".././Init/Prelude.html#Lean.addMacroScope">addMacroScope</a></code> calls. <code>v = <a href=".././Init/Prelude.html#Lean.extractMacroScopes">extractMacroScopes</a> n → n = v.<a href=".././Init/Prelude.html#Lean.MacroScopesView.review">review</a></code>.
This operation is useful for analyzing/transforming the original identifiers, then adding back
the scopes (via <code><a href=".././Init/Prelude.html#Lean.MacroScopesView.review">MacroScopesView.review</a></code>).</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.addMacroScope"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4109-L4122">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.addMacroScope">Lean.addMacroScope</a></span><span class="decl_args">
<span class="fn">(mainModule : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(scp : <a href=".././Init/Prelude.html#Lean.MacroScope">Lean.MacroScope</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></div><p>Add a new macro scope onto the name <code>n</code>, in the given <code>mainModule</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.MonadQuotation.addMacroScope"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4128-L4131">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MonadQuotation.addMacroScope">Lean.MonadQuotation.addMacroScope</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{m : <span class="fn"><span class="fn">Type</span> → <span class="fn">Type</span></span>}</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation">Lean.MonadQuotation</a> <span class="fn">m</span></span>]</span></span>
</span><span class="impl_arg"><span class="decl_args">
<span class="fn">[inst : <span class="fn"><a href=".././Init/Prelude.html#Monad">Monad</a> <span class="fn">m</span></span>]</span></span>
</span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><span class="fn">m</span> <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></div><p>Add a new macro scope onto the name <code>n</code>, using the monad state to supply the
main module and current macro scope.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation.addMacroScope">Lean.MonadQuotation.addMacroScope</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let mainModule ← <span class="fn">Lean.getMainModule</span>
  let scp ← <span class="fn">Lean.getCurrMacroScope</span>
  <span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.addMacroScope">Lean.addMacroScope</a> <span class="fn">mainModule</span> <span class="fn">n</span> <span class="fn">scp</span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.defaultMaxRecDepth"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4134-L4134">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.defaultMaxRecDepth">Lean.defaultMaxRecDepth</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Nat">Nat</a></div></div><p>The default maximum recursion depth. This is adjustable using the <code>maxRecDepth</code> option.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.defaultMaxRecDepth">Lean.defaultMaxRecDepth</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">512</span></span></li></ul></details></div></div><div class="decl" id="Lean.maxRecDepthErrorMessage"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4137-L4138">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.maxRecDepthErrorMessage">Lean.maxRecDepthErrorMessage</a></span><span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#String">String</a></div></div><p>The message to display on stack overflow.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.maxRecDepthErrorMessage">Lean.maxRecDepthErrorMessage</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn">&quotmaximum recursion depth has been reached (use `set_option maxRecDepth &ltnum&gt` to increase limit)&quot</span></span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.matchesNull"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4143-L4144">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.matchesNull">Lean.Syntax.matchesNull</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Nat">Nat</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Is this syntax a null <code>node</code>?</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.matchesNull">Lean.Syntax.matchesNull</a> <span class="fn">stx</span> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.isNodeOf">Lean.Syntax.isNodeOf</a> <span class="fn">stx</span> <a href=".././Init/Prelude.html#Lean.nullKind">Lean.nullKind</a> <span class="fn">n</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.matchesIdent"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4154-L4155">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.matchesIdent">Lean.Syntax.matchesIdent</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(id : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Function used for determining whether a syntax pattern <code>`(id)</code> is matched.
There are various conceivable notions of when two syntactic identifiers should be regarded as identical,
but semantic definitions like whether they refer to the same global name cannot be implemented without
context information (i.e. <code>MonadResolveName</code>). Thus in patterns we default to the structural solution
of comparing the identifiers' <code><a href=".././Init/Prelude.html#Lean.Name">Name</a></code> values, though we at least do so modulo macro scopes so that
identifiers that "look" the same match. This is particularly useful when dealing with identifiers that
do not actually refer to Lean bindings, e.g. in the <code>stx</code> pattern <code>`(many($p))</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.matchesIdent">Lean.Syntax.matchesIdent</a> <span class="fn">stx</span> <span class="fn">id</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   (<span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.isIdent">Lean.Syntax.isIdent</a> <span class="fn">stx</span></span> <a href=".././Init/Prelude.html#and">&amp&amp</a> <span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Name.eraseMacroScopes">Lean.Name.eraseMacroScopes</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax.getId">Lean.Syntax.getId</a> <span class="fn">stx</span></span>)</span> <a href=".././Init/Prelude.html#BEq.beq">==</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.Name.eraseMacroScopes">Lean.Name.eraseMacroScopes</a> <span class="fn">id</span></span></span></span>)</span></li></ul></details></div></div><div class="decl" id="Lean.Syntax.matchesLit"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4158-L4163">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Syntax.matchesLit">Lean.Syntax.matchesLit</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(k : <a href=".././Init/Prelude.html#Lean.SyntaxNodeKind">Lean.SyntaxNodeKind</a>)</span></span>
<span class="decl_args">
<span class="fn">(val : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#Bool">Bool</a></div></div><p>Is this syntax a node kind <code>k</code> wrapping an <code>atom _ val</code>?</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Macro.instNonemptyMethodsRef"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4174-L4174">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.instNonemptyMethodsRef">Lean.Macro.instNonemptyMethodsRef</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Nonempty">Nonempty</a> <a href=".././Init/Prelude.html#_private.Init.Prelude.0.Lean.Macro.MethodsRef">Lean.Macro.MethodsRef</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.instNonemptyMethodsRef">Lean.Macro.instNonemptyMethodsRef</a> <a href=".././Init/Prelude.html#Eq">=</a> <a href=".././Init/Prelude.html#Lean.Macro.instNonemptyMethodsRef.proof_1">Lean.Macro.instNonemptyMethodsRef.proof_1</a></span></li></ul></details></div></div><div class="decl" id="Lean.Macro.Context"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4177-L4190">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.Context">Lean.Macro.Context</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="Lean.Macro.Context.mk"><li id="Lean.Macro.Context.methods" class="structure_field"><div class="structure_field_doc"><p>An opaque reference to the <code><a href=".././Init/Prelude.html#Lean.Macro.Methods">Methods</a></code> object. This is done to break a
dependency cycle: the <code><a href=".././Init/Prelude.html#Lean.Macro.Methods">Methods</a></code> involve <code><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a></code> which has not been defined yet.</p></div><div class="structure_field_info">methods : <a href=".././Init/Prelude.html#_private.Init.Prelude.0.Lean.Macro.MethodsRef">Lean.Macro.MethodsRef</a></div></li><li id="Lean.Macro.Context.mainModule" class="structure_field"><div class="structure_field_doc"><p>The currently parsing module.</p></div><div class="structure_field_info">mainModule : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></div></li><li id="Lean.Macro.Context.currMacroScope" class="structure_field"><div class="structure_field_doc"><p>The current macro scope.</p></div><div class="structure_field_info">currMacroScope : <a href=".././Init/Prelude.html#Lean.MacroScope">Lean.MacroScope</a></div></li><li id="Lean.Macro.Context.currRecDepth" class="structure_field"><div class="structure_field_doc"><p>The current recursion depth.</p></div><div class="structure_field_info">currRecDepth : <a href=".././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Macro.Context.maxRecDepth" class="structure_field"><div class="structure_field_doc"><p>The maximum recursion depth.</p></div><div class="structure_field_info">maxRecDepth : <a href=".././Init/Prelude.html#Nat">Nat</a></div></li><li id="Lean.Macro.Context.ref" class="structure_field"><div class="structure_field_doc"><p>The syntax which supplies the position of error messages.</p></div><div class="structure_field_info">ref : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></div></li></ul><p>The read-only context for the <code><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a></code> monad.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Macro.Context" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Macro.Exception"><div class="inductive"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4193-L4199">source</a></div><div class="decl_header"><span class="decl_kind">inductive</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.Exception">Lean.Macro.Exception</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="constructors"><li class="constructor" id="Lean.Macro.Exception.error"><div class="inductive_ctor_doc"><p>A general error, given a message and a span (expressed as a <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code>).</p></div>error: <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <span class="fn"><a href=".././Init/Prelude.html#String">String</a> → <a href=".././Init/Prelude.html#Lean.Macro.Exception">Lean.Macro.Exception</a></span></span></li><li class="constructor" id="Lean.Macro.Exception.unsupportedSyntax"><div class="inductive_ctor_doc"><p>An unsupported syntax exception. We keep this separate because it is
used for control flow: if one macro does not support a syntax then we try
the next one.</p></div>unsupportedSyntax: <a href=".././Init/Prelude.html#Lean.Macro.Exception">Lean.Macro.Exception</a></li></ul><p>An exception in the <code><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a></code> monad.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Macro.Exception" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Macro.State"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4202-L4208">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.State">Lean.Macro.State</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="Lean.Macro.State.mk"><li id="Lean.Macro.State.macroScope" class="structure_field"><div class="structure_field_doc"><p>The global macro scope counter, used for producing fresh scope names.</p></div><div class="structure_field_info">macroScope : <a href=".././Init/Prelude.html#Lean.MacroScope">Lean.MacroScope</a></div></li><li id="Lean.Macro.State.traceMsgs" class="structure_field"><div class="structure_field_doc"><p>The list of trace messages that have been produced, each with a trace
class and a message.</p></div><div class="structure_field_info">traceMsgs : <span class="fn"><a href=".././Init/Prelude.html#List">List</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> <a href=".././Init/Prelude.html#Prod">×</a> <a href=".././Init/Prelude.html#String">String</a></span>)</span></div></li></ul><p>The mutable state for the <code><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a></code> monad.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Macro.State" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Macro.instInhabitedState"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4208-L4208">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.instInhabitedState">Lean.Macro.instInhabitedState</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Lean.Macro.State">Lean.Macro.State</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.instInhabitedState">Lean.Macro.instInhabitedState</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn">{ <span class="fn">macroScope</span> := <span class="fn">default</span>, <span class="fn">traceMsgs</span> := <span class="fn">default</span> }</span> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.MacroM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4222-L4222">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><p>The <code><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a></code> monad is the main monad for macro expansion. It has the
information needed to handle hygienic name generation, and is the monad that
<code>macro</code> definitions live in.</p><p>Notably, this is a (relatively) pure monad: there is no <code><a href=".././Init/System/IO.html#IO">IO</a></code> and no access to
the <code>Environment</code>. That means that things like declaration lookup are
impossible here, as well as <code><a href=".././Init/System/IO.html#IO.Ref">IO.Ref</a></code> or other side-effecting operations.
For more capabilities, macros can instead be written as <code>elab</code> using <code>adaptExpander</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <a href=".././Init/Prelude.html#Lean.Macro.Context">Lean.Macro.Context</a> (<span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <a href=".././Init/Prelude.html#Lean.Macro.Exception">Lean.Macro.Exception</a> <a href=".././Init/Prelude.html#Lean.Macro.State">Lean.Macro.State</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Macro"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4229-L4229">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro">Lean.Macro</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><p>A <code>macro</code> has type <code><a href=".././Init/Prelude.html#Lean.Macro">Macro</a></code>, which is a <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a> → <a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a> <a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code>: it
receives an input syntax and is supposed to "expand" it into another piece of
syntax.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro">Lean.Macro</a> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span></span>)</span></li></ul></details></div></div><div class="decl" id="Lean.Macro.instMonadRefMacroM"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4233-L4235">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.instMonadRefMacroM">Lean.Macro.instMonadRefMacroM</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MonadRef">Lean.MonadRef</a> <a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Macro.addMacroScope"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4238-L4240">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.addMacroScope">Lean.Macro.addMacroScope</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></div><p>Add a new macro scope to the name <code>n</code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.addMacroScope">Lean.Macro.addMacroScope</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let ctx ← <span class="fn">read</span>
  <span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.addMacroScope">Lean.addMacroScope</a> <span class="fn"><span class="fn">ctx</span>.mainModule</span> <span class="fn">n</span> <span class="fn"><span class="fn">ctx</span>.currMacroScope</span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Macro.throwUnsupported"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4243-L4244">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.throwUnsupported">Lean.Macro.throwUnsupported</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type</span>}</span></span>
</span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <span class="fn">α</span></span></div></div><p>Throw an <code>unsupportedSyntax</code> exception.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn">Lean.Macro.throwUnsupported</span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#MonadExcept.throw">throw</a> <a href=".././Init/Prelude.html#Lean.Macro.Exception.unsupportedSyntax">Lean.Macro.Exception.unsupportedSyntax</a></span></span></li></ul></details></div></div><div class="decl" id="Lean.Macro.throwError"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4250-L4252">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.throwError">Lean.Macro.throwError</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(msg : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <span class="fn">α</span></span></div></div><p>Throw a error with the given message,
using the <code>ref</code> for the location information.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.throwError">Lean.Macro.throwError</a> <span class="fn">msg</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let ref ← <span class="fn">Lean.getRef</span>
  <span class="fn"><a href=".././Init/Prelude.html#MonadExcept.throw">throw</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.Exception.error">Lean.Macro.Exception.error</a> <span class="fn">ref</span> <span class="fn">msg</span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Macro.throwErrorAt"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4255-L4256">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.throwErrorAt">Lean.Macro.throwErrorAt</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(ref : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(msg : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <span class="fn">α</span></span></div></div><p>Throw a error with the given message and location information.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.throwErrorAt">Lean.Macro.throwErrorAt</a> <span class="fn">ref</span> <span class="fn">msg</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#Lean.withRef">Lean.withRef</a> <span class="fn">ref</span> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.throwError">Lean.Macro.throwError</a> <span class="fn">msg</span></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.Macro.withFreshMacroScope"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4262-L4264">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.withFreshMacroScope">Lean.Macro.withFreshMacroScope</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <span class="fn">α</span></span></div></div><p>Increments the macro scope counter so that inside the body of <code>x</code> the macro
scope is fresh.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Macro.withIncRecDepth"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4267-L4271">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.withIncRecDepth">Lean.Macro.withIncRecDepth</a></span><span class="impl_arg"><span class="decl_args">
<span class="fn">{α : <span class="fn">Type</span>}</span></span>
</span><span class="decl_args">
<span class="fn">(ref : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args">
<span class="fn">(x : <span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <span class="fn">α</span></span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <span class="fn">α</span></span></div></div><p>Run <code>x</code> with an incremented recursion depth counter.</p><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Macro.instMonadQuotationMacroM"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4273-L4276">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.instMonadQuotationMacroM">Lean.Macro.instMonadQuotationMacroM</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation">Lean.MonadQuotation</a> <a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.instMonadQuotationMacroM">Lean.Macro.instMonadQuotationMacroM</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation.mk">Lean.MonadQuotation.mk</a> (<span class="fn">fun <span class="fn">ctx</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">ctx</span>.currMacroScope</span></span></span>) (<span class="fn">fun <span class="fn">ctx</span> =&gt <span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> <span class="fn"><span class="fn">ctx</span>.mainModule</span></span></span>) <span class="fn">fun {<span class="fn">α</span>} =&gt
    <span class="fn">Lean.Macro.withFreshMacroScope</span></span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Macro.Methods"><div class="structure"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4279-L4293">source</a></div><div class="decl_header"><span class="decl_kind">structure</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.Methods">Lean.Macro.Methods</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><ul class="structure_fields" id="Lean.Macro.Methods.mk"><li id="Lean.Macro.Methods.expandMacro?" class="structure_field"><div class="structure_field_doc"><p>Expands macros in the given syntax. A return value of <code>none</code> means there
was nothing to expand.</p></div><div class="structure_field_info">expandMacro? : <span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> (<span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span>)</span></span></div></li><li id="Lean.Macro.Methods.getCurrNamespace" class="structure_field"><div class="structure_field_doc"><p>Get the current namespace in the file.</p></div><div class="structure_field_info">getCurrNamespace : <span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></li><li id="Lean.Macro.Methods.hasDecl" class="structure_field"><div class="structure_field_doc"><p>Check if a given name refers to a declaration.</p></div><div class="structure_field_info">hasDecl : <span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <a href=".././Init/Prelude.html#Bool">Bool</a></span></span></div></li><li id="Lean.Macro.Methods.resolveNamespace" class="structure_field"><div class="structure_field_doc"><p>Resolves the given name to an overload list of namespaces.</p></div><div class="structure_field_info">resolveNamespace : <span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> (<span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span>)</span></span></div></li><li id="Lean.Macro.Methods.resolveGlobalName" class="structure_field"><div class="structure_field_doc"><p>Resolves the given name to a overload list of global definitions.
The <code><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#String">String</a></code> in each alternative is the deduced list of projections
(which are ambiguous with name components).</p></div><div class="structure_field_info">resolveGlobalName : <span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> (<span class="fn"><a href=".././Init/Prelude.html#List">List</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#String">String</a></span></span>)</span>)</span></span></div></li></ul><p>The opaque methods that are available to <code><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a></code>.</p><details class="instances"><summary>Instances For</summary><ul id="instances-for-list-Lean.Macro.Methods" class="instances-for-list"></ul></details></div></div><div class="decl" id="Lean.Macro.instInhabitedMethods"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4293-L4293">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.instInhabitedMethods">Lean.Macro.instInhabitedMethods</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#Lean.Macro.Methods">Lean.Macro.Methods</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation">One or more equations did not get rendered due to their size.</li></ul></details></div></div><div class="decl" id="Lean.Macro.mkMethodsImp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4296-L4297">source</a></div><div class="decl_header"><span class="decl_kind">unsafe def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.mkMethodsImp">Lean.Macro.mkMethodsImp</a></span><span class="decl_args">
<span class="fn">(methods : <a href=".././Init/Prelude.html#Lean.Macro.Methods">Lean.Macro.Methods</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#_private.Init.Prelude.0.Lean.Macro.MethodsRef">Lean.Macro.MethodsRef</a></div></div><p>Implementation of <code><a href=".././Init/Prelude.html#Lean.Macro.mkMethods">mkMethods</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.mkMethodsImp">Lean.Macro.mkMethodsImp</a> <span class="fn">methods</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#unsafeCast">unsafeCast</a> <span class="fn">methods</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Macro.mkMethods"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4301-L4301">source</a></div><div class="attributes">@[implementedBy Lean.Macro.mkMethodsImp]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.mkMethods">Lean.Macro.mkMethods</a></span><span class="decl_args">
<span class="fn">(methods : <a href=".././Init/Prelude.html#Lean.Macro.Methods">Lean.Macro.Methods</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><a href=".././Init/Prelude.html#_private.Init.Prelude.0.Lean.Macro.MethodsRef">Lean.Macro.MethodsRef</a></div></div><p>Make an opaque reference to a <code><a href=".././Init/Prelude.html#Lean.Macro.Methods">Methods</a></code>.</p></div></div><div class="decl" id="Lean.Macro.instInhabitedMethodsRef"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4303-L4304">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.instInhabitedMethodsRef">Lean.Macro.instInhabitedMethodsRef</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Inhabited">Inhabited</a> <a href=".././Init/Prelude.html#_private.Init.Prelude.0.Lean.Macro.MethodsRef">Lean.Macro.MethodsRef</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.instInhabitedMethodsRef">Lean.Macro.instInhabitedMethodsRef</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">{ <span class="fn">default</span> := <span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.mkMethods">Lean.Macro.mkMethods</a> <span class="fn">default</span></span> }</span></span></li></ul></details></div></div><div class="decl" id="Lean.Macro.getMethodsImp"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4307-L4308">source</a></div><div class="decl_header"><span class="decl_kind">unsafe def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.getMethodsImp">Lean.Macro.getMethodsImp</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <a href=".././Init/Prelude.html#Lean.Macro.Methods">Lean.Macro.Methods</a></span></div></div><p>Implementation of <code><a href=".././Init/Prelude.html#Lean.Macro.getMethods">getMethods</a></code>.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.getMethodsImp">Lean.Macro.getMethodsImp</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let ctx ← <span class="fn">read</span>
  <span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> (<span class="fn"><a href=".././Init/Prelude.html#unsafeCast">unsafeCast</a> <span class="fn"><span class="fn">ctx</span>.methods</span></span>)</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Macro.getMethods"><div class="opaque"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4311-L4311">source</a></div><div class="attributes">@[implementedBy Lean.Macro.getMethodsImp]</div>
<div class="decl_header"><span class="decl_kind">opaque</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.getMethods">Lean.Macro.getMethods</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <a href=".././Init/Prelude.html#Lean.Macro.Methods">Lean.Macro.Methods</a></span></div></div><p>Extract the methods list from the <code><a href=".././Init/Prelude.html#Lean.MacroM">MacroM</a></code> state.</p></div></div><div class="decl" id="Lean.Macro.expandMacro?"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4317-L4318">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.expandMacro?">Lean.Macro.expandMacro?</a></span><span class="decl_args">
<span class="fn">(stx : <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> (<span class="fn"><a href=".././Init/Prelude.html#Option">Option</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span>)</span></div></div><p><code><a href=".././Init/Prelude.html#Lean.Macro.expandMacro?">expandMacro?</a> stx</code> returns <code>some stxNew</code> if <code>stx</code> is a macro,
and <code>stxNew</code> is its expansion.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.expandMacro?">Lean.expandMacro?</a> <span class="fn">stx</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let a ← <a href=".././Init/Prelude.html#Lean.Macro.getMethods">Lean.Macro.getMethods</a>
  <span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.Methods.expandMacro?">Lean.Macro.Methods.expandMacro?</a> <span class="fn">a</span> <span class="fn">stx</span></span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Macro.hasDecl"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4321-L4322">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.hasDecl">Lean.Macro.hasDecl</a></span><span class="decl_args">
<span class="fn">(declName : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <a href=".././Init/Prelude.html#Bool">Bool</a></span></div></div><p>Returns <code>true</code> if the environment contains a declaration with name <code>declName</code></p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.hasDecl">Lean.Macro.hasDecl</a> <span class="fn">declName</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let a ← <a href=".././Init/Prelude.html#Lean.Macro.getMethods">Lean.Macro.getMethods</a>
  <span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.Methods.hasDecl">Lean.Macro.Methods.hasDecl</a> <span class="fn">a</span> <span class="fn">declName</span></span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Macro.getCurrNamespace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4325-L4326">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.getCurrNamespace">Lean.Macro.getCurrNamespace</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span></div></div><p>Gets the current namespace given the position in the file.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.getCurrNamespace">Lean.Macro.getCurrNamespace</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let a ← <a href=".././Init/Prelude.html#Lean.Macro.getMethods">Lean.Macro.getMethods</a>
  <span class="fn"><span class="fn">a</span>.getCurrNamespace</span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Macro.resolveNamespace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4329-L4330">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.resolveNamespace">Lean.Macro.resolveNamespace</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> (<span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a></span>)</span></div></div><p>Resolves the given name to an overload list of namespaces.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.resolveNamespace">Lean.Macro.resolveNamespace</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let a ← <a href=".././Init/Prelude.html#Lean.Macro.getMethods">Lean.Macro.getMethods</a>
  <span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.Methods.resolveNamespace">Lean.Macro.Methods.resolveNamespace</a> <span class="fn">a</span> <span class="fn">n</span></span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Macro.resolveGlobalName"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4337-L4338">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.resolveGlobalName">Lean.Macro.resolveGlobalName</a></span><span class="decl_args">
<span class="fn">(n : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> (<span class="fn"><a href=".././Init/Prelude.html#List">List</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a> <a href=".././Init/Prelude.html#Prod">×</a> <span class="fn"><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#String">String</a></span></span>)</span>)</span></div></div><p>Resolves the given name to a overload list of global definitions.
The <code><a href=".././Init/Prelude.html#List">List</a> <a href=".././Init/Prelude.html#String">String</a></code> in each alternative is the deduced list of projections
(which are ambiguous with name components).</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.resolveGlobalName">Lean.Macro.resolveGlobalName</a> <span class="fn">n</span></span> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn">do
  let a ← <a href=".././Init/Prelude.html#Lean.Macro.getMethods">Lean.Macro.getMethods</a>
  <span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.Methods.resolveGlobalName">Lean.Macro.Methods.resolveGlobalName</a> <span class="fn">a</span> <span class="fn">n</span></span></span></span></li></ul></details></div></div><div class="decl" id="Lean.Macro.trace"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4341-L4342">source</a></div><div class="decl_header"><span class="decl_kind">def</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.Macro.trace">Lean.Macro.trace</a></span><span class="decl_args">
<span class="fn">(clsName : <a href=".././Init/Prelude.html#Lean.Name">Lean.Name</a>)</span></span>
<span class="decl_args">
<span class="fn">(msg : <a href=".././Init/Prelude.html#String">String</a>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MacroM">Lean.MacroM</a> <a href=".././Init/Prelude.html#Unit">Unit</a></span></div></div><p>Add a new trace message, with the given trace class and message.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><span class="fn"><a href=".././Init/Prelude.html#Lean.Macro.trace">Lean.Macro.trace</a> <span class="fn">clsName</span> <span class="fn">msg</span></span> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#modify">modify</a> <span class="fn">fun <span class="fn">s</span> =&gt <span class="fn">{ <span class="fn">macroScope</span> := <span class="fn"><span class="fn">s</span>.macroScope</span>, <span class="fn">traceMsgs</span> := <span class="fn"><span class="fn">(<span class="fn">clsName</span>, <span class="fn">msg</span>)</span> <a href=".././Init/Prelude.html#List.cons">::</a> <span class="fn"><span class="fn">s</span>.traceMsgs</span></span> }</span></span></span></span></li></ul></details></div></div><div class="decl" id="Lean.PrettyPrinter.UnexpandM"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4354-L4354">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.PrettyPrinter.UnexpandM">Lean.PrettyPrinter.UnexpandM</a></span><span class="decl_args">
<span class="fn">(α : <span class="fn">Type</span>)</span></span>
<span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><p>The unexpander monad, essentially <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a> → <a href=".././Init/Prelude.html#Option">Option</a> α</code>. The <code><a href=".././Init/Prelude.html#Lean.Syntax">Syntax</a></code> is the <code>ref</code>,
and it has the possibility of failure without an error message.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.PrettyPrinter.UnexpandM">Lean.PrettyPrinter.UnexpandM</a> <a href=".././Init/Prelude.html#Eq">=</a> <span class="fn"><a href=".././Init/Prelude.html#ReaderT">ReaderT</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> (<span class="fn"><a href=".././Init/Prelude.html#EStateM">EStateM</a> <a href=".././Init/Prelude.html#Unit">Unit</a> <a href=".././Init/Prelude.html#Unit">Unit</a></span>)</span></span></li></ul></details></div></div><div class="decl" id="Lean.PrettyPrinter.Unexpander"><div class="def"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4362-L4362">source</a></div><div class="attributes">@[inline]</div>
<div class="decl_header"><span class="decl_kind">abbrev</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.PrettyPrinter.Unexpander">Lean.PrettyPrinter.Unexpander</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn">Type</span></div></div><p>Function that tries to reverse macro expansions as a post-processing step of delaboration.
While less general than an arbitrary delaborator, it can be declared without importing <code><a href=".././Lean.html">Lean</a></code>.
Used by the <code>[appUnexpander]</code> attribute.</p><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.PrettyPrinter.Unexpander">Lean.PrettyPrinter.Unexpander</a> <a href=".././Init/Prelude.html#Eq">=</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a> → <span class="fn"><a href=".././Init/Prelude.html#Lean.PrettyPrinter.UnexpandM">Lean.PrettyPrinter.UnexpandM</a> <a href=".././Init/Prelude.html#Lean.Syntax">Lean.Syntax</a></span></span>)</span></li></ul></details></div></div><div class="decl" id="Lean.PrettyPrinter.instMonadQuotationUnexpandM"><div class="instance"><div class="gh_link"><a href="https://github.com/leanprover/lean4/blob/e44fd19074259018b9ddcbdb00209492416bc8ac/src/Init/Prelude.lean#L4364-L4370">source</a></div><div class="decl_header"><span class="decl_kind">instance</span>
<span class="decl_name"><a class="break_within" href=".././Init/Prelude.html#Lean.PrettyPrinter.instMonadQuotationUnexpandM">Lean.PrettyPrinter.instMonadQuotationUnexpandM</a></span><span class="decl_args"> :</span><div class="decl_type"><span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation">Lean.MonadQuotation</a> <a href=".././Init/Prelude.html#Lean.PrettyPrinter.UnexpandM">Lean.PrettyPrinter.UnexpandM</a></span></div></div><details><summary>Equations</summary><ul class="equations"><li class="equation"><span class="fn"><a href=".././Init/Prelude.html#Lean.PrettyPrinter.instMonadQuotationUnexpandM">Lean.PrettyPrinter.instMonadQuotationUnexpandM</a> <a href=".././Init/Prelude.html#Eq">=</a>   <span class="fn"><a href=".././Init/Prelude.html#Lean.MonadQuotation.mk">Lean.MonadQuotation.mk</a> (<span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> <span class="fn">0</span></span>) (<span class="fn"><a href=".././Init/Prelude.html#Pure.pure">pure</a> (<span class="fn"><a href=".././Init/Prelude.html#Lean.Name.mkStr1">Lean.Name.mkStr1</a> <span class="fn">&quot_fakeMod&quot</span></span>)</span>) <span class="fn">fun {<span class="fn">α</span>} =&gt <span class="fn">id</span></span></span></span></li></ul></details></div></div></main>
<nav class="nav"><iframe src=".././/navbar.html" class="navframe" frameBorder="0"></iframe></nav></body></html>